# 自动续写功能完整解决方案

## 文档信息
- **版本**: v1.0
- **创建日期**: 2025年
- **状态**: ✅ 可执行方案
- **目标**: 一次性稳定实现自动续写功能

---

## 一、需求分析

### 1.1 功能定位

**自动续写（Auto-Complete）** 是 Binder AI 三层架构中的**第一层**，提供无感知的文本自动补全体验。

### 1.2 核心需求

#### 功能需求
1. ✅ **自动触发**: 光标静止 7 秒后自动触发续写
2. ✅ **幽灵文字显示**: 在光标位置后显示半透明的续写内容
3. ✅ **接受/拒绝**: Ctrl/Cmd+Space 接受，Escape 键取消
4. ✅ **智能清除**: 用户继续输入或移动光标时自动清除
5. ✅ **上下文感知**: 基于文档上下文生成续写内容

#### 非功能需求
1. ✅ **性能**: 响应时间 < 2 秒
2. ✅ **稳定性**: 不干扰正常编辑体验
3. ✅ **兼容性**: 与 TipTap 编辑器完美集成
4. ✅ **可配置**: 触发时间可配置（5-15 秒）

### 1.3 用户场景

**场景 1: 写作中暂停思考**
- 用户正在写文档，突然停下来思考下一步
- 7 秒后，系统自动显示续写建议
- 用户按 Ctrl/Cmd+Space 接受，继续写作

**场景 2: 继续写作**
- 用户正在写一句话，停在中途
- 系统提供续写建议
- 用户按 Escape 拒绝，继续自己写

**场景 3: 灵感启发**
- 用户写了一段内容，不确定如何继续
- 系统提供续写建议作为灵感参考
- 用户参考建议，手动修改后继续

### 1.4 需求颗粒度

#### 触发条件
- ✅ 光标位置在文档中（不在标题栏等非编辑区域）
- ✅ 光标静止时间 ≥ 7 秒（可配置）
- ✅ 光标位置有足够上下文（≥ 50 字符）
- ✅ 光标位置不是文档末尾（末尾不续写）
- ✅ 用户未输入新内容
- ✅ 用户未移动光标

#### 显示规则
- ✅ 续写内容长度：20-50 字符（由后端控制）
- ✅ 显示位置：光标位置之后
- ✅ 显示样式：半透明灰色文字（`opacity: 0.5`）
- ✅ 显示时机：AI 响应到达后立即显示
- ✅ 隐藏时机：用户输入、光标移动、接受/拒绝

#### 交互规则
- ✅ **Ctrl+Space (Windows/Linux) / Cmd+Space (macOS)**: 接受续写，插入内容，清除幽灵文字
- ✅ **Escape 键**: 拒绝续写，清除幽灵文字
- ✅ **继续输入**: 自动清除幽灵文字，不插入续写
- ✅ **光标移动**: 自动清除幽灵文字
- ✅ **文档切换**: 清除幽灵文字

**快捷键设计说明**:
- **不使用 Tab 键**: Tab 在文档编辑中用于缩进和制表，更适合代码编辑器习惯
- **使用 Ctrl/Cmd+Space**: 更符合文档编辑习惯，不会干扰正常编辑操作
- **跨平台适配**: macOS 使用 Cmd+Space，Windows/Linux 使用 Ctrl+Space

#### 性能要求
- ✅ AI 请求响应时间 < 2 秒
- ✅ 显示延迟 < 100ms
- ✅ 不影响编辑器正常操作
- ✅ 请求去重：相同上下文不重复请求
- ✅ 请求取消：用户继续输入时取消未完成的请求

---

## 二、技术方案

### 2.1 架构设计

```
┌─────────────────────────────────────────────────────────┐
│                    自动续写功能架构                        │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  ┌─────────────────────────────────────────────────┐    │
│  │           前端层 (React + TipTap)                │    │
│  │                                                   │    │
│  │  ┌──────────────────────────────────────────┐   │    │
│  │  │  useAutoComplete Hook                    │   │    │
│  │  │  - 监听编辑器事件                        │   │    │
│  │  │  - 触发逻辑（7秒计时）                   │   │    │
│  │  │  - 状态管理                              │   │    │
│  │  └──────────────────────────────────────────┘   │    │
│  │                   ↓                              │    │
│  │  ┌──────────────────────────────────────────┐   │    │
│  │  │  GhostTextExtension (TipTap Extension)   │   │    │
│  │  │  - Decoration 插件                       │   │    │
│  │  │  - 幽灵文字渲染                          │   │    │
│  │  │  - 样式管理                              │   │    │
│  │  └──────────────────────────────────────────┘   │    │
│  │                   ↓                              │    │
│  │  ┌──────────────────────────────────────────┐   │    │
│  │  │  TipTapEditor                            │   │    │
│  │  │  - 编辑器实例                            │   │    │
│  │  │  - 集成 Extension                        │   │    │
│  │  └──────────────────────────────────────────┘   │    │
│  └───────────────────────────────────────────────────┘    │
│                           ↓                                │
│  ┌─────────────────────────────────────────────────┐      │
│  │          IPC 通信层 (Tauri)                     │      │
│  │  - ai_autocomplete 命令                        │      │
│  └─────────────────────────────────────────────────┘      │
│                           ↓                                │
│  ┌─────────────────────────────────────────────────┐      │
│  │           后端层 (Rust)                         │      │
│  │                                                   │      │
│  │  ┌──────────────────────────────────────────┐   │      │
│  │  │  AIService                               │   │      │
│  │  │  - Provider 管理                         │   │      │
│  │  │  - 请求路由                              │   │      │
│  │  └──────────────────────────────────────────┘   │      │
│  │                   ↓                              │      │
│  │  ┌──────────────────────────────────────────┐   │      │
│  │  │  AIProvider (DeepSeek/OpenAI)            │   │      │
│  │  │  - autocomplete() 方法                   │   │      │
│  │  │  - 提示词构建                            │   │      │
│  │  │  - 响应处理                              │   │      │
│  │  └──────────────────────────────────────────┘   │      │
│  └───────────────────────────────────────────────────┘      │
└───────────────────────────────────────────────────────────────┘
```

### 2.2 关键技术选型

#### 前端技术
- **TipTap Extension**: 使用自定义 Extension 创建 Decoration 插件
- **ProseMirror Decoration**: 用于在编辑器内渲染幽灵文字
- **React Hook**: 管理状态和逻辑

#### 后端技术
- **Tauri Command**: `ai_autocomplete` 命令
- **AI Provider**: DeepSeek 优先，OpenAI 备选
- **流式响应**: 非流式（自动补全需要快速响应）

### 2.3 数据流设计

```
1. 用户输入/光标移动
   ↓
2. useAutoComplete Hook 监听事件
   ↓
3. 清除之前的计时器和状态
   ↓
4. 开始 7 秒倒计时
   ↓
5. 7 秒后，检查触发条件
   ↓
6. 提取上下文（光标前 200 字符）
   ↓
7. 调用 ai_autocomplete 命令
   ↓
8. AIService 路由到 AIProvider
   ↓
9. AIProvider 调用 API 生成续写
   ↓
10. 返回续写内容
    ↓
11. useAutoComplete 更新状态
    ↓
12. GhostTextExtension 通过 Decoration 显示
    ↓
13. 用户交互（Ctrl/Cmd+Space/Escape/继续输入）
    ↓
14. 接受/拒绝/清除
```

---

## 三、详细实现方案

### 3.1 前端实现

#### 3.1.1 GhostTextExtension (新建)

**文件路径**: `src/components/Editor/extensions/GhostTextExtension.ts`

**核心实现**:

```typescript
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';
import { Decoration, DecorationSet } from '@tiptap/pm/view';

export interface GhostTextOptions {
  getGhostText: () => { text: string; position: number } | null;
}

export const GhostTextExtension = Extension.create<GhostTextOptions>({
  name: 'ghostText',

  addOptions() {
    return {
      getGhostText: () => null,
    };
  },

  addProseMirrorPlugins() {
    const { getGhostText } = this.options;

    return [
      new Plugin({
        key: new PluginKey('ghostText'),
        state: {
          init() {
            return DecorationSet.empty;
          },
          apply(tr, set, oldState, newState) {
            const ghostText = getGhostText();
            
            // 如果没有幽灵文字，返回空集合
            if (!ghostText) {
              return DecorationSet.empty;
            }

            const { text, position } = ghostText;
            const { doc } = tr;

            // 检查位置是否有效
            if (position < 0 || position > doc.content.size) {
              return DecorationSet.empty;
            }

            // 检查文档是否变化（避免在事务中间显示）
            if (tr.docChanged) {
              return DecorationSet.empty;
            }

            // 创建 widget decoration
            const decoration = Decoration.widget(
              position,
              () => {
                const span = document.createElement('span');
                span.className = 'ghost-text';
                span.textContent = text;
                span.setAttribute('data-ghost-text', 'true');
                return span;
              },
              {
                side: 1, // 在位置之后插入
                ignoreSelection: true,
                key: 'ghost-text-widget',
              }
            );

            return DecorationSet.create(doc, [decoration]);
          },
        },
        props: {
          decorations(state) {
            return this.getState(state);
          },
        },
      }),
    ];
  },
});
```

#### 3.1.2 useAutoComplete Hook (优化)

**文件路径**: `src/hooks/useAutoComplete.ts`

**核心优化点**:

1. **状态管理优化**
   - 使用更精确的状态结构
   - 添加请求取消支持

2. **触发逻辑优化**
   - 更严格的触发条件检查
   - 更好的去重机制

3. **性能优化**
   - 请求取消机制
   - 防抖优化

**完整实现**:

```typescript
import { useState, useEffect, useRef, useCallback } from 'react';
import { invoke } from '@tauri-apps/api/core';
import { Editor } from '@tiptap/react';

export interface AutoCompleteState {
  text: string | null;
  position: number | null;
  isVisible: boolean;
  isLoading: boolean;
}

interface UseAutoCompleteOptions {
  editor: Editor | null;
  triggerDelay?: number; // 触发延迟，默认 7000ms
  minContextLength?: number; // 最小上下文长度，默认 50
  maxLength?: number; // 最大续写长度，默认 50
  enabled?: boolean; // 是否启用，默认 true
}

export function useAutoComplete({
  editor,
  triggerDelay = 7000,
  minContextLength = 50,
  maxLength = 50,
  enabled = true,
}: UseAutoCompleteOptions) {
  const [state, setState] = useState<AutoCompleteState>({
    text: null,
    position: null,
    isVisible: false,
    isLoading: false,
  });

  const triggerTimerRef = useRef<NodeJS.Timeout | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);
  const lastContextRef = useRef<string>('');
  const lastPositionRef = useRef<number>(-1);
  const isUserTypingRef = useRef<boolean>(false);

  // 清除自动补全
  const clear = useCallback(() => {
    setState({
      text: null,
      position: null,
      isVisible: false,
      isLoading: false,
    });

    // 清除计时器
    if (triggerTimerRef.current) {
      clearTimeout(triggerTimerRef.current);
      triggerTimerRef.current = null;
    }

    // 取消请求
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  }, []);

  // 触发自动补全
  const trigger = useCallback(async () => {
    if (!editor || !enabled) return;

    const { from, to } = editor.state.selection;
    
    // 检查是否有选中文本（如果有，不触发）
    if (from !== to) {
      return;
    }

    // 提取上下文（光标前 200 字符）
    const contextStart = Math.max(0, from - 200);
    const context = editor.state.doc.textBetween(contextStart, from);

    // 检查上下文长度
    if (context.length < minContextLength) {
      return;
    }

    // 检查是否在文档末尾（末尾不续写）
    const docSize = editor.state.doc.content.size;
    if (from >= docSize - 1) {
      return;
    }

    // 检查上下文或位置是否变化（去重）
    if (context === lastContextRef.current && from === lastPositionRef.current) {
      return;
    }

    lastContextRef.current = context;
    lastPositionRef.current = from;

    // 设置加载状态
    setState((prev) => ({
      ...prev,
      isLoading: true,
      position: from,
    }));

    // 创建 AbortController 用于取消请求
    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    try {
      const result = await invoke<string | null>('ai_autocomplete', {
        context,
        position: from,
        maxLength: maxLength,
      });

      // 检查请求是否被取消
      if (abortController.signal.aborted) {
        return;
      }

      // 检查位置是否仍然有效
      const currentFrom = editor.state.selection.from;
      if (currentFrom !== from) {
        return; // 光标已移动，不显示
      }

      if (result && result.trim().length > 0) {
        setState({
          text: result.trim(),
          position: from,
          isVisible: true,
          isLoading: false,
        });
      } else {
        clear();
      }
    } catch (error) {
      // 忽略取消错误
      if (error instanceof Error && error.name === 'AbortError') {
        return;
      }

      console.error('自动补全失败:', error);
      clear();
    } finally {
      if (abortControllerRef.current === abortController) {
        abortControllerRef.current = null;
      }
    }
  }, [editor, enabled, minContextLength, maxLength, clear]);

  // 接受补全
  const accept = useCallback(() => {
    if (!editor || !state.text || state.position === null) return;

    editor
      .chain()
      .focus()
      .insertContentAt(state.position, state.text)
      .run();

    clear();
  }, [editor, state, clear]);

  // 监听编辑器事件
  useEffect(() => {
    if (!editor || !enabled) return;

    // 处理选择更新（光标移动）
    const handleSelectionUpdate = () => {
      clear(); // 清除之前的补全
      isUserTypingRef.current = false;

      // 清除之前的计时器
      if (triggerTimerRef.current) {
        clearTimeout(triggerTimerRef.current);
      }

      // 开始新的计时
      triggerTimerRef.current = setTimeout(() => {
        trigger();
      }, triggerDelay);
    };

    // 处理内容更新（用户输入）
    const handleUpdate = () => {
      isUserTypingRef.current = true;
      clear(); // 用户输入时清除补全

      // 清除之前的计时器，重新开始
      if (triggerTimerRef.current) {
        clearTimeout(triggerTimerRef.current);
      }

      triggerTimerRef.current = setTimeout(() => {
        trigger();
      }, triggerDelay);
    };

    // 注册事件监听
    editor.on('selectionUpdate', handleSelectionUpdate);
    editor.on('update', handleUpdate);

    // 初始触发
    triggerTimerRef.current = setTimeout(() => {
      trigger();
    }, triggerDelay);

    return () => {
      editor.off('selectionUpdate', handleSelectionUpdate);
      editor.off('update', handleUpdate);
      clear();
    };
  }, [editor, enabled, triggerDelay, trigger, clear]);

  // 处理键盘事件（Ctrl/Cmd+Space 接受，Escape 拒绝）
  useEffect(() => {
    if (!editor || !state.isVisible) return;

    const handleKeyDown = (event: KeyboardEvent) => {
      // 检测 Ctrl+Space (Windows/Linux) 或 Cmd+Space (macOS)
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      const modifierKey = isMac ? event.metaKey : event.ctrlKey;
      const isAcceptShortcut = modifierKey && event.key === ' ';

      if (isAcceptShortcut && state.isVisible) {
        event.preventDefault();
        event.stopPropagation();
        accept();
      } else if (event.key === 'Escape' && state.isVisible) {
        event.preventDefault();
        event.stopPropagation();
        clear();
      }
    };

    const editorDom = editor.view.dom;
    editorDom.addEventListener('keydown', handleKeyDown, true);

    return () => {
      editorDom.removeEventListener('keydown', handleKeyDown, true);
    };
  }, [editor, state.isVisible, accept, clear]);

  // 暴露 getGhostText 函数供 Extension 使用
  const getGhostText = useCallback(() => {
    if (!state.isVisible || !state.text || state.position === null) {
      return null;
    }
    return {
      text: state.text,
      position: state.position,
    };
  }, [state]);

  return {
    state,
    trigger,
    clear,
    accept,
    getGhostText, // 供 Extension 使用
  };
}
```

#### 3.1.3 TipTapEditor 集成

**文件路径**: `src/components/Editor/TipTapEditor.tsx`

**修改点**:

1. 导入 `GhostTextExtension`
2. 在 `useEditor` 中添加 Extension
3. 集成 `useAutoComplete` Hook
4. 传递 `getGhostText` 到 Extension

**关键代码片段**:

```typescript
import { GhostTextExtension } from './extensions/GhostTextExtension';
import { useAutoComplete } from '../../hooks/useAutoComplete';

// ... 在组件内部

const autoComplete = useAutoComplete({
  editor,
  triggerDelay: 7000,
  minContextLength: 50,
  maxLength: 50,
  enabled: true,
});

const editor = useEditor({
  extensions: [
    StarterKit.configure({
      link: false,
    }),
    Image.configure({ /* ... */ }),
    Link.configure({ /* ... */ }),
    // 添加幽灵文字扩展
    GhostTextExtension.configure({
      getGhostText: autoComplete.getGhostText,
    }),
  ],
  // ... 其他配置
});
```

#### 3.1.4 样式定义

**文件路径**: `src/index.css`

```css
/* 幽灵文字样式 */
.ghost-text {
  color: rgba(156, 163, 175, 0.6); /* gray-400 with opacity */
  opacity: 0.6;
  pointer-events: none;
  user-select: none;
  font-style: italic;
}

.dark .ghost-text {
  color: rgba(156, 163, 175, 0.5);
  opacity: 0.5;
}

/* 确保幽灵文字不影响光标 */
.ghost-text {
  position: relative;
  z-index: -1;
}
```

### 3.2 后端实现

#### 3.2.1 AI Provider 优化

**文件路径**: `src-tauri/src/services/ai_providers/deepseek.rs`

**优化点**:
- 提示词优化
- 响应长度控制
- 错误处理

**关键代码**:

```rust
async fn autocomplete(&self, context: &str, max_length: usize) -> Result<String, AIError> {
    // 截取上下文最后部分（避免过长）
    let context = if context.len() > 500 {
        &context[context.len() - 500..]
    } else {
        context
    };

    let prompt = format!(
        "请继续完成以下文本，只输出续写内容（不超过{}字），不要重复原文：\n\n{}",
        max_length,
        context
    );

    let request = ChatRequest {
        model: "deepseek-chat".to_string(),
        messages: vec![
            ChatMessageRequest {
                role: "system".to_string(),
                content: "你是一个文本自动补全助手。只输出续写内容，不要重复原文。".to_string(),
            },
            ChatMessageRequest {
                role: "user".to_string(),
                content: prompt,
            },
        ],
        temperature: 0.7,
        max_tokens: Some((max_length / 2).max(10) as u32), // 保守估计 token 数
        stream: false,
    };

    // ... 发送请求并处理响应
}
```

### 3.3 状态管理

#### 3.3.1 状态结构

```typescript
interface AutoCompleteState {
  text: string | null;        // 续写内容
  position: number | null;    // 光标位置
  isVisible: boolean;         // 是否显示
  isLoading: boolean;         // 是否加载中
}
```

#### 3.3.2 状态转换

```
初始状态
  ↓ (7秒无输入)
加载中 (isLoading: true)
  ↓ (AI 响应)
显示中 (isVisible: true)
  ↓
接受 (Ctrl/Cmd+Space) / 拒绝 (Escape) / 清除 (输入/移动光标)
  ↓
初始状态
```

---

## 四、实现步骤

### 步骤 1: 创建 GhostTextExtension (30分钟)

1. 创建文件 `src/components/Editor/extensions/GhostTextExtension.ts`
2. 实现 Extension 和 Plugin
3. 测试 Decoration 渲染

### 步骤 2: 优化 useAutoComplete Hook (30分钟)

1. 修改 `src/hooks/useAutoComplete.ts`
2. 添加 `getGhostText` 函数
3. 优化触发逻辑
4. 添加请求取消支持

### 步骤 3: 集成到 TipTapEditor (15分钟)

1. 修改 `src/components/Editor/TipTapEditor.tsx`
2. 导入 Extension
3. 配置 Extension
4. 连接 Hook 和 Extension

### 步骤 4: 样式优化 (15分钟)

1. 修改 `src/index.css`
2. 添加幽灵文字样式
3. 测试暗色模式

### 步骤 5: 后端优化 (可选，30分钟)

1. 优化提示词
2. 优化响应处理
3. 添加错误处理

### 步骤 6: 测试 (30分钟)

1. 功能测试
2. 边界测试
3. 性能测试
4. UI 测试

**总预计时间**: 2.5 小时

---

## 五、测试方案

### 5.1 功能测试

#### 测试用例 1: 基本触发
- **步骤**: 输入 100+ 字符，光标停留 7 秒
- **预期**: 显示幽灵文字
- **优先级**: P0

#### 测试用例 2: Ctrl/Cmd+Space 接受
- **步骤**: 显示幽灵文字后按 Ctrl+Space (Windows/Linux) 或 Cmd+Space (macOS)
- **预期**: 内容插入，幽灵文字消失
- **优先级**: P0
- **注意**: macOS 需要测试编辑器聚焦时拦截，失焦时不影响 Spotlight

#### 测试用例 3: Escape 拒绝
- **步骤**: 显示幽灵文字后按 Escape
- **预期**: 幽灵文字消失，内容未插入
- **优先级**: P0

#### 测试用例 4: 继续输入清除
- **步骤**: 显示幽灵文字后继续输入
- **预期**: 幽灵文字立即消失
- **优先级**: P0

#### 测试用例 5: 光标移动清除
- **步骤**: 显示幽灵文字后移动光标
- **预期**: 幽灵文字立即消失
- **优先级**: P0

### 5.2 边界测试

#### 测试用例 6: 上下文不足
- **步骤**: 输入 < 50 字符，光标停留 7 秒
- **预期**: 不触发续写
- **优先级**: P1

#### 测试用例 7: 文档末尾
- **步骤**: 光标在文档末尾，停留 7 秒
- **预期**: 不触发续写
- **优先级**: P1

#### 测试用例 8: 快速输入
- **步骤**: 快速输入，每 5 秒输入一次
- **预期**: 不触发续写
- **优先级**: P1

#### 测试用例 9: 网络错误
- **步骤**: 断开网络，触发续写
- **预期**: 优雅处理错误，不显示幽灵文字
- **优先级**: P1

#### 测试用例 10: API 超时
- **步骤**: 模拟 API 超时（> 5 秒）
- **预期**: 取消请求，清除加载状态
- **优先级**: P1

### 5.3 性能测试

#### 测试用例 11: 响应时间
- **指标**: AI 响应时间 < 2 秒
- **方法**: 测量从触发到显示的时间
- **优先级**: P1

#### 测试用例 12: 编辑器性能
- **指标**: 不影响编辑器正常操作
- **方法**: 观察编辑器响应速度
- **优先级**: P1

### 5.4 UI 测试

#### 测试用例 13: 样式显示
- **步骤**: 检查幽灵文字样式
- **预期**: 半透明灰色，不影响阅读
- **优先级**: P2

#### 测试用例 14: 暗色模式
- **步骤**: 切换暗色模式
- **预期**: 幽灵文字颜色适配
- **优先级**: P2

#### 测试用例 15: 光标位置
- **步骤**: 检查幽灵文字位置
- **预期**: 准确显示在光标后
- **优先级**: P1

---

## 六、注意事项

### 6.1 技术注意事项

1. **Decoration 更新时机**
   - Decoration 必须在事务完成后更新
   - 使用 `tr.docChanged` 检查避免在事务中间显示

2. **位置同步**
   - 确保幽灵文字位置与光标位置同步
   - 文档变化时需要重新计算位置

3. **请求取消**
   - 使用 AbortController 取消请求
   - 避免内存泄漏

4. **性能优化**
   - 避免频繁触发 AI 请求
   - 使用去重机制

### 6.2 用户体验注意事项

1. **不干扰编辑**
   - 幽灵文字不应该影响正常输入
   - 使用 `pointer-events: none`

2. **清晰的视觉反馈**
   - 半透明样式，清晰但不突兀
   - 加载状态提示（可选）

3. **可预测的行为**
   - 触发条件清晰
   - 交互方式直观

### 6.3 错误处理

1. **网络错误**
   - 优雅降级
   - 不显示错误提示（避免干扰）

2. **API 错误**
   - 记录日志
   - 自动重试（可选）

3. **编辑器错误**
   - 确保不影响编辑器稳定性
   - 使用 try-catch 包裹关键操作

---

## 七、后续优化

### 7.1 功能优化

1. **配置化**
   - 触发时间可配置
   - 续写长度可配置
   - 启用/禁用开关

2. **智能优化**
   - 基于文档类型的提示词优化
   - 上下文长度自适应

3. **性能优化**
   - 请求缓存（相同上下文）
   - 流式响应（可选）

### 7.2 体验优化

1. **加载提示**
   - 显示加载动画
   - 进度提示

2. **预览优化**
   - 高亮关键部分
   - 格式化显示

3. **快捷键扩展**
   - 其他快捷键支持
   - 自定义快捷键

---

## 八、验收标准

### 8.1 功能完整性

- ✅ 自动触发功能正常
- ✅ 幽灵文字显示正常
- ✅ Ctrl/Cmd+Space/Escape 交互正常
- ✅ 自动清除功能正常

### 8.2 性能指标

- ✅ AI 响应时间 < 2 秒
- ✅ 显示延迟 < 100ms
- ✅ 不影响编辑器性能

### 8.3 稳定性

- ✅ 无崩溃
- ✅ 无内存泄漏
- ✅ 错误处理完善

### 8.4 用户体验

- ✅ 不干扰正常编辑
- ✅ 视觉反馈清晰
- ✅ 交互流畅

---

## 九、总结

本方案提供了一个**完整、可执行、稳定**的自动续写功能实现方案，包括：

1. ✅ **清晰的需求分析**: 功能需求、非功能需求、用户场景
2. ✅ **完整的技术方案**: 架构设计、数据流、关键技术选型
3. ✅ **详细的实现方案**: 前端、后端、状态管理
4. ✅ **可执行的实现步骤**: 分步骤实现，预计 2.5 小时
5. ✅ **完善的测试方案**: 功能测试、边界测试、性能测试
6. ✅ **注意事项和后续优化**: 技术注意事项、用户体验、后续优化方向

**目标**: 一次性稳定实现，避免返工。

**关键成功因素**:
- 使用 TipTap Extension 正确集成
- 完善的错误处理
- 清晰的用户交互
- 性能优化

---

**文档版本**: v1.0  
**创建日期**: 2025年  
**状态**: ✅ 可执行

