# 文档编辑功能重新设计方案

## 问题分析

### 当前问题

1. **位置匹配失败的根本原因**
   - 用户传达的修改意图可能是模糊的（如"修改这句话"、"改进这段内容"）
   - 当前方案依赖文本内容匹配，如果用户意图模糊，无法准确定位
   - 前端通过文本搜索匹配位置，对于模糊意图无法工作

2. **编辑器行概念缺失**
   - TipTap/ProseMirror 编辑器没有原生的"行号"概念
   - 编辑器使用块级元素（paragraph、heading等）和文本节点
   - 换行符在 HTML 中可能被转换为 `<br>` 或段落分隔
   - 当前方案试图通过 `split('\n')` 计算行号，但不够准确

3. **AI 无法识别具体位置**
   - AI 只收到完整内容，没有行号信息
   - AI 无法告诉用户"第几行需要修改"
   - 用户意图和实际内容位置之间缺乏桥梁

## 核心设计理念

### 关键洞察

**让 AI 成为位置匹配的决策者，而不是前端**

- AI 理解用户的模糊意图（"修改这句话"、"改进这段内容"）
- AI 识别内容对应的行位置
- AI 在工具调用中明确指定要修改的行范围
- 前端根据 AI 指定的行位置进行精确匹配

### 设计原则

1. **行信息传递**：将内容转换为带行号的格式传递给 AI
2. **AI 意图识别**：AI 识别用户意图，匹配到具体的行位置
3. **精确位置指定**：AI 在工具调用中明确指定要修改的行范围
4. **前端精确匹配**：前端根据行号进行精确匹配，而不是文本搜索

## 新方案设计

### 方案架构

```
用户意图（模糊）
    ↓
AI 接收带行号的内容
    ↓
AI 识别意图，匹配到具体行位置
    ↓
AI 在工具调用中指定行范围
    ↓
前端根据行号精确匹配并应用修改
```

### 一、行信息传递层

#### 1.1 编辑器行概念定义

**TipTap/ProseMirror 编辑器结构**：
- 编辑器使用块级节点（paragraph、heading、list等）
- 每个块级节点可以包含文本节点
- 换行符在 HTML 中可能被转换为：
  - `<p>` 标签（段落分隔）
  - `<br>` 标签（硬换行）
  - 文本中的 `\n`（在某些情况下）

**行号定义**：
- **逻辑行**：按段落和硬换行分割的内容单元
- **显示行**：在编辑器中实际显示的行（可能因换行而多行）
- **内容行**：按 `\n` 分割的文本行（用于匹配）

**行号计算策略**：
```typescript
// 将编辑器内容转换为带行号的内容
function convertContentToLineNumbered(content: string): string {
  // 1. 移除 HTML 标签，保留换行信息
  const textContent = content
    .replace(/<\/p>/g, '\n')  // 段落结束 = 换行
    .replace(/<p[^>]*>/g, '')  // 移除段落开始标签
    .replace(/<br\s*\/?>/g, '\n')  // <br> = 换行
    .replace(/<[^>]*>/g, '')  // 移除其他 HTML 标签
    .replace(/&nbsp;/g, ' ')  // 替换 &nbsp;
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&');
  
  // 2. 按换行符分割
  const lines = textContent.split('\n');
  
  // 3. 添加行号
  const numberedLines = lines.map((line, index) => {
    const lineNum = index + 1;
    return `${lineNum}: ${line}`;
  });
  
  return numberedLines.join('\n');
}
```

#### 1.2 传递给 AI 的内容格式

**当前格式**（问题）：
```
<p>现在，让我们暂时清空脑海中的杂念，只留下两个关键词。

只需记住两个关键词：一个是我，另一个是函数——这是我们探索的起点。

简单来说，你要先相信一件事：世界上所有的逻辑和知识，都能用一个函数来表达。</p>
```

**新格式**（带行号）：
```
1: 现在，让我们暂时清空脑海中的杂念，只留下两个关键词。
2: 
3: 只需记住两个关键词：一个是我，另一个是函数——这是我们探索的起点。
4: 
5: 简单来说，你要先相信一件事：世界上所有的逻辑和知识，都能用一个函数来表达。
```

**增强格式**（带行号和上下文）：
```
当前文档内容（共 10 行）：

1: 现在，让我们暂时清空脑海中的杂念，只留下两个关键词。
2: 
3: 只需记住两个关键词：一个是我，另一个是函数——这是我们探索的起点。
4: 
5: 简单来说，你要先相信一件事：世界上所有的逻辑和知识，都能用一个函数来表达。
6: 
7: Functions describe the world.
8: 函数描述世界。
9: 
10: 我们只需要将现实世界抽象为符号，再设定好相应的运算规则。
```

### 二、AI 意图识别与位置匹配层

#### 2.1 提示词增强

**在上下文提示词中添加**：
```
当前文档内容（带行号）：
{line_numbered_content}

⚠️ 重要：当用户要求编辑文档时，你需要：
1. 识别用户意图中的目标内容（可能是模糊的描述）
2. 在带行号的内容中找到对应的行位置
3. 在工具调用中明确指定要修改的行范围（start_line, end_line）
4. 提供完整的新内容（包含未修改的部分）
```

**工具定义增强**：
```json
{
  "name": "edit_current_editor_document",
  "description": "编辑当前在编辑器中打开的文档。\n\n⚠️ 关键：你必须识别用户意图中的目标内容，并在带行号的内容中找到对应的行位置。\n\n参数说明：\n- content: 完整的新文档内容\n- start_line (可选): 要修改的起始行号（如果用户意图明确指向特定行）\n- end_line (可选): 要修改的结束行号（如果用户意图明确指向特定行）\n- instruction (可选): 修改说明（用于帮助前端理解修改意图）",
  "parameters": {
    "type": "object",
    "properties": {
      "content": {
        "type": "string",
        "description": "完整的新文档内容"
      },
      "start_line": {
        "type": "number",
        "description": "要修改的起始行号（可选，如果用户意图明确指向特定行）"
      },
      "end_line": {
        "type": "number",
        "description": "要修改的结束行号（可选，如果用户意图明确指向特定行）"
      },
      "instruction": {
        "type": "string",
        "description": "修改说明（可选，用于帮助前端理解修改意图）"
      }
    },
    "required": ["content"]
  }
}
```

#### 2.2 AI 工作流程

1. **接收带行号的内容**
   - 从上下文提示词中获取带行号的内容
   - 理解每行的内容和行号

2. **识别用户意图**
   - 分析用户请求（如"修改这句话"、"改进这段内容"）
   - 在带行号的内容中找到对应的行位置

3. **生成新内容**
   - 根据用户意图生成完整的新内容
   - 保持未修改部分不变

4. **指定行范围**（可选但推荐）
   - 如果用户意图明确指向特定行，指定 `start_line` 和 `end_line`
   - 帮助前端更精确地匹配位置

### 三、前端精确匹配层

#### 3.1 行号到文档位置的映射

**建立行号映射表**：
```typescript
interface LineMapping {
  lineNumber: number;  // 行号（1-based）
  startPos: number;    // 在文档中的起始位置（字符索引）
  endPos: number;      // 在文档中的结束位置（字符索引）
  content: string;      // 该行的内容
}

function buildLineMapping(content: string): LineMapping[] {
  // 1. 移除 HTML 标签，保留换行信息
  const textContent = content
    .replace(/<\/p>/g, '\n')
    .replace(/<p[^>]*>/g, '')
    .replace(/<br\s*\/?>/g, '\n')
    .replace(/<[^>]*>/g, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&');
  
  // 2. 按换行符分割，建立映射
  const lines = textContent.split('\n');
  const mappings: LineMapping[] = [];
  let currentPos = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const startPos = currentPos;
    const endPos = currentPos + line.length;
    
    mappings.push({
      lineNumber: i + 1,
      startPos,
      endPos,
      content: line,
    });
    
    currentPos = endPos + 1; // +1 for newline
  }
  
  return mappings;
}
```

#### 3.2 根据行号匹配位置

**如果 AI 指定了行号**：
```typescript
function findTextByLineNumber(
  docText: string,
  lineMapping: LineMapping[],
  startLine: number,
  endLine: number
): { start: number; end: number } | null {
  const startMapping = lineMapping.find(m => m.lineNumber === startLine);
  const endMapping = lineMapping.find(m => m.lineNumber === endLine);
  
  if (!startMapping || !endMapping) {
    return null;
  }
  
  // 转换为 ProseMirror 文档位置
  const textStart = startMapping.startPos;
  const textEnd = endMapping.endPos;
  
  return findTextRangeInDoc(doc, textStart, textEnd);
}
```

**如果 AI 没有指定行号**（回退到文本匹配）：
```typescript
// 使用现有的文本匹配策略（作为备选）
```

### 四、工具调用增强

#### 4.1 工具参数增强

**当前参数**：
```json
{
  "content": "完整的新内容"
}
```

**增强参数**：
```json
{
  "content": "完整的新内容",
  "start_line": 3,  // 可选：要修改的起始行号
  "end_line": 3,    // 可选：要修改的结束行号
  "instruction": "将中文句子替换为英文翻译版本"  // 可选：修改说明
}
```

#### 4.2 后端处理增强

**在 `edit_current_editor_document` 中**：
1. 接收 `start_line` 和 `end_line`（如果提供）
2. 验证行号是否有效
3. 如果提供了行号，在返回的 diff 中标记这些信息
4. 前端可以使用行号进行更精确的匹配

### 五、Diff 数据结构增强

#### 5.1 当前 Diff 结构

```rust
pub struct Diff {
    pub diff_id: String,
    pub diff_area_id: String,
    pub diff_type: DiffType,
    pub original_code: String,
    pub original_start_line: usize,  // 后端计算的行号
    pub original_end_line: usize,
    pub new_code: String,
    pub start_line: usize,
    pub end_line: usize,
    pub context_before: Option<String>,
    pub context_after: Option<String>,
}
```

#### 5.2 增强的 Diff 结构

```rust
pub struct Diff {
    pub diff_id: String,
    pub diff_area_id: String,
    pub diff_type: DiffType,
    pub original_code: String,
    pub original_start_line: usize,
    pub original_end_line: usize,
    pub new_code: String,
    pub start_line: usize,
    pub end_line: usize,
    pub context_before: Option<String>,
    pub context_after: Option<String>,
    // ⚠️ 新增：AI 指定的行号（如果提供）
    pub ai_specified_start_line: Option<usize>,  // AI 在工具调用中指定的起始行号
    pub ai_specified_end_line: Option<usize>,    // AI 在工具调用中指定的结束行号
    pub instruction: Option<String>,              // AI 提供的修改说明
}
```

### 六、前端匹配策略优化

#### 6.1 优先级匹配策略

1. **第一优先级：AI 指定的行号**（如果提供）
   - 使用 `ai_specified_start_line` 和 `ai_specified_end_line`
   - 通过行号映射表直接定位
   - 最准确，适用于 AI 明确识别了行位置的情况

2. **第二优先级：后端计算的行号**（如果 AI 没有指定）
   - 使用 `original_start_line` 和 `original_end_line`
   - 通过行号映射表定位
   - 较准确，适用于后端 diff 计算准确的情况

3. **第三优先级：上下文匹配**（如果行号匹配失败）
   - 使用 `context_before` 和 `context_after`
   - 扩大搜索范围
   - 作为备选方案

4. **第四优先级：文本匹配**（最后备选）
   - 精确文本匹配
   - 规范化文本匹配

#### 6.2 行号匹配实现

```typescript
function findTextByLineNumber(
  editor: Editor,
  lineMapping: LineMapping[],
  startLine: number,
  endLine: number
): { start: number; end: number } | null {
  const startMapping = lineMapping.find(m => m.lineNumber === startLine);
  const endMapping = lineMapping.find(m => m.lineNumber === endLine);
  
  if (!startMapping || !endMapping) {
    console.warn('[findTextByLineNumber] 行号映射失败', {
      startLine,
      endLine,
      availableLines: lineMapping.map(m => m.lineNumber),
    });
    return null;
  }
  
  // 转换为 ProseMirror 文档位置
  const doc = editor.state.doc;
  const textStart = startMapping.startPos;
  const textEnd = endMapping.endPos;
  
  return findTextRangeInDoc(doc, textStart, textEnd);
}
```

## 实施步骤

### 阶段一：基础行号支持（MVP）

1. **前端：行号转换**
   - 实现 `convertContentToLineNumbered` 函数
   - 在传递给后端时，同时传递带行号的内容

2. **后端：行号传递**
   - 在上下文提示词中包含带行号的内容
   - 工具定义中添加 `start_line` 和 `end_line` 参数（可选）

3. **前端：行号映射**
   - 实现 `buildLineMapping` 函数
   - 建立行号到文档位置的映射表

### 阶段二：AI 行号识别（增强）

1. **提示词优化**
   - 明确告诉 AI 如何使用行号
   - 提供行号识别的示例

2. **工具调用增强**
   - AI 在工具调用中指定 `start_line` 和 `end_line`
   - 后端验证并传递行号信息

3. **前端优先使用行号**
   - 如果 AI 指定了行号，优先使用行号匹配
   - 如果行号匹配失败，回退到文本匹配

### 阶段三：完整优化（高级）

1. **智能行号识别**
   - AI 能够识别模糊意图（"这句话"、"这段内容"）
   - AI 能够匹配到具体的行范围

2. **多行编辑支持**
   - 支持跨行编辑
   - 支持多段不连续行的编辑

3. **行号验证**
   - 验证 AI 指定的行号是否有效
   - 如果行号无效，提供错误提示

## 优势分析

### 1. 解决模糊意图问题

**当前方案**：
- 用户："修改这句话"
- AI：生成新内容
- 前端：尝试文本匹配 → 可能失败

**新方案**：
- 用户："修改这句话"
- AI：识别"这句话"对应第 3 行，指定 `start_line: 3, end_line: 3`
- 前端：使用行号直接定位 → 精确匹配

### 2. 提高匹配准确性

**当前方案**：
- 依赖文本内容匹配
- 对于格式变化、内容相似的情况可能失败

**新方案**：
- 优先使用行号匹配（最准确）
- 行号匹配失败时回退到文本匹配（备选）

### 3. 更好的用户体验

**当前方案**：
- 用户意图模糊时，可能匹配失败
- 需要用户提供更精确的描述

**新方案**：
- AI 理解模糊意图，自动识别行位置
- 用户可以使用自然语言描述修改意图

## 注意事项

### 1. 行号计算的准确性

- 必须确保行号计算与 AI 看到的行号一致
- HTML 到文本的转换必须准确
- 换行符的处理必须一致

### 2. 编辑器内容变化

- 如果用户在 AI 编辑过程中修改了内容，行号可能失效
- 需要检测内容变化，重新计算行号

### 3. 大文档性能

- 对于大文档，行号映射表可能很大
- 需要考虑性能优化（延迟计算、缓存等）

### 4. 向后兼容

- 如果 AI 没有指定行号，应该回退到现有的文本匹配策略
- 确保现有功能不受影响

## 测试要点

1. **行号计算准确性**
   - 测试各种 HTML 格式（段落、换行、列表等）
   - 确保行号与 AI 看到的行号一致

2. **AI 行号识别**
   - 测试模糊意图（"这句话"、"这段内容"）
   - 验证 AI 能否正确识别行位置

3. **前端行号匹配**
   - 测试行号匹配的准确性
   - 测试行号匹配失败时的回退机制

4. **边界情况**
   - 空行处理
   - 跨行编辑
   - 大文档性能

