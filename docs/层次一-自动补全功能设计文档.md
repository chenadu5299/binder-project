# 层次一：自动补全（自动续写）功能设计文档

## 文档信息

- **文档版本**：v1.0
- **创建日期**：2025年
- **文档性质**：功能设计文档
- **功能层次**：层次一

## 格式说明

**重要**：本文档中提到的文档格式说明：
- **原生 DOCX**：Word 原生的 .docx 文件，Binder 只能预览，不能编辑
- **t-docx**：Binder 可编辑的文档格式（TipTap 模拟的 DOCX），包括：
  - Binder 生成的文档
  - 从预览模式切换到编辑模式时创建的草稿文件（如 `document.draft.docx`）
  - 所有在 Binder 编辑器中可编辑的文档

本文档中所有涉及"可编辑"、"格式匹配"、"样式继承"等场景下的 DOCX，均指 **t-docx** 格式。

---

## 一、功能定位

### 1.1 核心特性

- **无 UI 窗口**：不占用任何面板空间
- **自动触发**：用户无需主动调用
- **幽灵文字**：在光标后方显示半透明的续写内容
- **非侵入式**：不打断用户写作流程

### 1.2 使用场景

- 写作续写
- 代码补全
- 内容生成

### 1.3 功能边界

- **不共享**：聊天历史、对话上下文
- **共享**：当前文档内容、系统提示词、AI 模型配置

---

## 二、触发机制

### 2.1 触发条件

- 光标在文档中静止不动（无输入、无移动）
- 静止时间达到阈值（默认 7 秒，可配置 5-15 秒）
- 光标位置有足够的上下文（至少 50 字符，可配置）
- 光标位置不是文档末尾
- 用户未输入新内容
- 用户未移动光标

### 2.2 触发逻辑

- 监听编辑器事件（`selectionUpdate`、`update`）
- 光标静止后开始计时
- 达到阈值后调用 AI 生成续写
- 显示幽灵文字

### 2.3 取消机制

- 用户继续输入 → 自动清除
- 用户移动光标 → 自动清除
- 用户按 Esc 键 → 手动清除

---

## 三、提示词设计

### 3.1 提示词结构（优化后）

**完整提示词结构**：
```
[系统提示词]
你是一个专业的写作助手，帮助用户续写内容。

[文档格式信息]
当前文档格式：[格式类型]（.txt、.t-docx、.md、.html 等）
格式要求：[根据格式类型动态生成]

[上下文内容]
上文：[光标前 300-500 字符，优先在段落边界截断]
下文：[光标后 100-200 字符]（如有）

[结构信息]（P1 优先级，可选）
当前位置：[章节/段落/列表位置]
文档结构：[简要结构信息]

[语义信息]（P1 优先级，可选）
主题：[文档主题]
关键实体：[人物、地点、概念等]
情感基调：[当前情感基调]

[风格信息]（P1 优先级，可选）
文体类型：[小说/散文/诗歌/剧本/报告/方案等]
时代背景：[古代/现代/未来]
语言风格：[文言/白话/口语/书面语]
情感基调：[悲伤/喜悦/紧张/平静等]
专业程度：[通俗/专业/学术]

[续写方向]（P0 优先级）
根据上下文分析，续写方向应为：[推进/补充/转折]

[续写要求]
基于以上上下文，续写接下来的内容（50-150 字，以完整句子或完整语义单元结尾）：
- 保持与上文的语义连贯
- 如果下文有内容，确保续写与下文自然衔接
- 保持文档结构的完整性
- 保持主题和情感的一致性
- 保持人物性格和语言风格的一致性（文学创作）
- 保持术语和概念的一致性（专业文档）
- 匹配当前文档格式和样式
```

### 3.2 上下文选择规则（优化后）

#### 3.2.1 上文提取规则

- **提取范围**：光标前 300-500 字符（根据场景动态调整）
  - 简单场景（邮件、便签）：300 字符
  - 中等场景（报告、方案）：500 字符
  - 复杂场景（小说、学术论文）：800-1000 字符（P1 优先级）
- **最小要求**：至少 50 字符
- **截断策略**：优先在段落边界、句子边界截断，保持语义完整性
- **选择策略**：优先选择光标位置附近的内容

#### 3.2.2 下文提取规则（P0 优先级，新增）

- **提取范围**：光标后 100-200 字符（如有）
- **目的**：确保续写与下文自然衔接，避免割裂
- **边界识别**：优先在段落边界、句子边界截断
- **提示词增强**：在提示词中明确要求 AI 分析下文的语义，确保续写与下文自然衔接

#### 3.2.3 结构信息提取（优化：通过提示词和编辑器状态）

- **编辑器状态提取**：从 TipTap 编辑器状态提取结构信息（标题层级、列表层级、段落类型等）
- **结构信息传递**：在提示词中传递结构信息，让 AI 自行分析文档结构
- **提示词增强**：在提示词中明确要求 AI 识别当前所在的结构位置（章节、段落、列表等）

#### 3.2.4 语义和风格信息（优化：通过提示词和记忆库）

- **记忆库信息**：从记忆库获取相关术语、风格偏好、主题信息（如有）
- **提示词增强**：在提示词中明确要求 AI 自行分析：
  - 关键实体（人物、地点、概念等）
  - 文档主题和情感基调
  - 文体类型、语言风格、专业程度
  - 语义连贯性和风格一致性
- **无需独立提取**：不进行独立的语义分析和风格识别，交由 AI 在提示词指导下自行分析

### 3.3 内容限制（优化后）

#### 3.3.1 长度限制（优化）

- **动态调整**：根据场景动态调整续写长度
  - 简单场景：50-100 字
  - 中等场景：100-150 字
  - 复杂场景：150-200 字（P1 优先级）
- **完整性要求**：以完整句子或完整语义单元结尾，而不是固定字数
- **最大长度**：不超过 200 字（避免过长续写）

#### 3.3.2 格式和样式匹配（优化）

**格式识别**：
- 自动识别当前文档格式（.txt、.t-docx、.md、.html 等）
- 识别当前位置格式（段落、列表、表格、代码块等）

**格式要求（动态调整）**：
- **TXT 格式**：纯文本，无格式标记
- **Markdown 格式**：允许 Markdown 语法（粗体、斜体、列表、代码块等），但需与上下文风格一致
- **t-docx 格式**：匹配 t-docx 样式（标题、粗体、斜体、列表等），保持与上下文一致的格式
- **HTML 格式**：允许 HTML 标签，但需与上下文风格一致

**格式约束**：
- 如果上下文在列表中，续写应保持列表格式
- 如果上下文在代码块中，续写应保持代码格式（技术文档）
- 如果上下文有标题层级，续写应匹配层级
- 继承段落的样式（字体、大小、颜色等）

#### 3.3.3 风格要求（优化：通过提示词和记忆库）

- **风格一致性**：保持与上下文风格一致
- **记忆库风格信息**：从记忆库获取用户的风格偏好、常用术语、写作习惯（如有）
- **提示词增强**：在提示词中明确要求 AI 自行识别和分析：
  - 文体类型（小说、散文、诗歌、剧本、报告、方案等）
  - 时代背景（古代、现代、未来）
  - 语言风格（文言、白话、口语、书面语）
  - 情感基调（悲伤、喜悦、紧张、平静等）
  - 专业程度（通俗、专业、学术）
- **风格匹配**：要求 AI 保持与上下文风格一致，参考记忆库中的风格偏好

#### 3.3.4 连贯性要求（优化：通过提示词和记忆库）

- **提示词增强**：在提示词中明确要求 AI 确保：
  - 语义连贯：保持与上文的语义连贯
  - 下文衔接：如果下文有内容，确保续写与下文自然衔接
  - 结构完整：保持文档结构的完整性
  - 主题一致：保持主题和情感的一致性
  - 人物一致性：保持人物性格和语言风格的一致性（文学创作）
- **记忆库术语支持**：从记忆库获取相关术语和概念，在提示词中传递给 AI，确保术语一致性（专业文档）

#### 3.3.5 续写方向（优化：通过提示词）

- **提示词增强**：在提示词中明确要求 AI 根据上下文分析续写方向（推进/补充/转折）
- **方向要求**：
  - 如果方向为"推进"：自然推进情节/逻辑/内容
  - 如果方向为"补充"：补充相关信息/细节/说明
  - 如果方向为"转折"：进行逻辑转折/情感转折/情节转折
- **无需独立识别**：不进行独立的方向识别，交由 AI 在提示词指导下自行判断

---

## 四、工作逻辑结构

### 4.1 前端工作流程（优化后）

```
编辑器事件触发
    ↓
检查触发条件
    ↓
提取上下文（P0 优先级）：
  - 提取上文（光标前 300-500 字符，根据场景动态调整）
  - 提取下文（光标后 100-200 字符，如有）
  - 优先在段落边界、句子边界截断
    ↓
提取编辑器状态（P0 优先级）：
  - 从 TipTap 编辑器状态提取结构信息（标题层级、列表层级、段落类型等）
  - 识别当前位置格式（段落、列表、表格、代码块等）
    ↓
获取记忆库信息（P1 优先级，可选）：
  - 检索相关记忆项（术语、风格偏好、主题信息等）
  - 最多获取 3-5 条相关记忆
    ↓
调用后端 ai_autocomplete（传递上下文、编辑器状态、记忆库信息等）
    ↓
显示幽灵文字（半透明灰色）
    ↓
用户操作：
  - Tab 键 → 接受补全
  - 继续输入 → 清除
  - Esc 键 → 清除
  - 光标移动 → 清除
```

### 4.2 后端工作流程（优化后）

```
接收请求（context, position, max_length, editorState, memoryItems）
    ↓
选择 AI 提供商（优先 DeepSeek，其次 OpenAI）
    ↓
构建增强提示词（P0 优先级）：
  - 整合上下文（上文、下文）
  - 整合编辑器状态信息（结构信息、格式信息）
  - 整合记忆库信息（术语、风格偏好、主题信息等，如有）
  - 在提示词中明确要求 AI 自行分析：
    * 文档结构和当前位置
    * 关键实体、主题、情感基调
    * 文体类型、语言风格、专业程度
    * 续写方向（推进/补充/转折）
    * 风格一致性和术语一致性
  - 根据文档格式和场景类型动态构建提示词
    ↓
调用 AI 生成续写内容：
  - AI 根据提示词自行分析上下文、结构、语义、风格
  - AI 识别续写方向并生成续写内容
    ↓
后处理（P0 优先级）：
  - 格式检查（是否符合格式要求）
  - 长度检查（是否符合长度要求）
  - 基本连贯性检查（简单文本匹配，不进行深度语义分析）
    ↓
返回续写内容（50-150 字，以完整句子结尾）
```

**工作逻辑说明**：
- **静默执行**：层次一的工作过程对用户完全透明，不展示任何中间过程
- **提示词驱动**：通过增强的提示词让 AI 自行分析上下文、结构、语义、风格，无需独立的技术实现
- **记忆库支持**：充分利用记忆库提供术语、风格偏好、主题信息，减少 AI 分析负担
- **编辑器状态利用**：从 TipTap 编辑器状态提取结构信息，无需独立解析
- **后处理简化**：仅进行格式和长度检查，连贯性检查交由 AI 在生成时保证
- **结果展示**：只显示最终结果（幽灵文字），不展示中间过程

### 4.3 状态管理

- **Hook 状态**：`useAutoComplete` 管理状态
- **状态字段**：`text`（续写内容）、`position`（位置）、`isVisible`（是否可见）、`isLoading`（是否加载中）
- **状态更新**：响应编辑器事件和 AI 响应

---

## 五、UI 实现

### 5.1 幽灵文字显示

- **位置**：光标正后方
- **样式**：半透明灰色文字（opacity: 0.4）
- **字体**：与编辑器字体相同
- **长度**：20-50 字符（不超过一行）

### 5.2 交互方式

- **Tab 键**：接受补全，插入幽灵文字
- **继续输入**：自动清除幽灵文字
- **Esc 键**：手动清除幽灵文字
- **光标移动**：自动清除幽灵文字

### 5.3 技术实现

- **Extension**：通过 TipTap Extension 实现幽灵文字显示
- **装饰器**：使用 ProseMirror 装饰器（Decoration）实现
- **位置计算**：根据光标位置计算幽灵文字显示位置

---

## 六、性能要求

### 6.1 响应时间

- **目标**：< 2 秒（从触发到显示续写内容）
- **优化策略**：使用快速模型、限制生成长度、防抖机制

### 6.2 资源占用

- **内存占用**：< 10MB
- **CPU 占用**：< 20%（AI 处理时）

### 6.3 防抖机制

- **触发间隔**：7 秒（可配置 5-15 秒）
- **取消机制**：用户输入或光标移动时立即取消

---

## 七、错误处理

### 7.1 错误类型

- **网络错误**：连接失败、超时
- **API 错误**：API Key 无效、配额不足
- **解析错误**：响应格式错误
- **错误级别分类**：
  - **Error**：严重错误（API Key 无效、网络连接失败）
  - **Warning**：警告信息（配额不足、响应超时）
  - **Info**：提示信息（响应被过滤）

### 7.2 处理策略

- **静默失败**：错误时不显示提示，不影响用户操作（适用于 Info 级别）
- **自动重试**：网络错误自动重试（最多 3 次，指数退避）
- **用户无感**：错误处理对用户透明
- **错误提示优化**：
  - 严重错误（Error）记录日志，但不打扰用户
  - 警告信息（Warning）可在开发者模式下显示
  - 提示信息（Info）完全静默处理

---

## 八、配置选项

### 8.1 可配置项（优化后）

- **触发延迟**：5-15 秒（默认 7 秒）
- **最小上下文长度**：50-200 字符（默认 50 字符）
- **上文长度**：300-500 字符（根据场景动态调整，默认 300 字符）
- **下文长度**：100-200 字符（如有，默认 150 字符）
- **续写长度**：50-150 字（根据场景动态调整，默认 100 字）
- **是否启用**：可开关功能
- **结构感知**：是否启用结构感知功能（P1 优先级，默认关闭）
- **语义分析**：是否启用语义分析功能（P1 优先级，默认关闭）
- **风格识别**：是否启用风格识别功能（P1 优先级，默认关闭）

### 8.2 模型选择

- **优先模型**：DeepSeek Chat（快速模型）
- **备用模型**：OpenAI GPT-3.5 Turbo
- **选择策略**：优先使用快速、低成本的模型

---

## 九、边界情况处理

### 9.1 特殊场景

- **文档末尾**：不触发续写
- **选中文本**：有选中文本时不触发
- **上下文不足**：上下文少于 50 字符时不触发
- **快速输入**：用户快速输入时自动取消

### 9.2 冲突处理

- **与其他功能冲突**：自动补全可被其他高优先级功能中断
- **多光标**：暂不支持多光标场景
- **只读模式**：只读文档不触发

---

## 十、技术实现细节

### 10.1 前端实现

- **Hook**：`useAutoComplete.ts`
- **Extension**：`GhostTextExtension.ts`
- **组件**：`GhostText.tsx`（可选，当前通过 Extension 实现）

### 10.2 后端实现

- **命令**：`ai_autocomplete`
- **服务**：`AIService::autocomplete`
- **提供商**：`DeepSeekProvider`、`OpenAIProvider`

### 10.3 数据流

```
编辑器事件 → useAutoComplete Hook → 后端 ai_autocomplete → AI 服务 → 返回结果 → Extension 显示
```

---

## 十一、测试要点

### 11.1 功能测试

- 触发条件测试
- 续写质量测试
- 交互操作测试
- 边界情况测试

### 11.2 性能测试

- 响应时间测试
- 资源占用测试
- 并发场景测试

---

## 十二、后续优化方向

### 12.1 功能优化（基于分析文档）

#### 12.1.1 P0 优先级（高优先级，必须实现）

- ✅ **上下文增强**：
  - 增加下文感知（读取光标后 100-200 字符）
  - 动态调整上下文长度（根据场景 300-500 字符）
  - 优先在段落边界截断
- ✅ **格式适配优化**：
  - 根据文档格式动态调整格式要求
  - 允许列表格式（在列表场景中）
  - 允许代码格式（在技术文档中）
- ✅ **长度限制优化**：
  - 动态调整续写长度（50-150 字）
  - 以完整句子或完整语义单元结尾

#### 12.1.2 P1 优先级（中优先级，建议实现）

- ⚠️ **编辑器状态提取优化**：
  - 优化从 TipTap 编辑器状态提取结构信息的算法
  - 提取更详细的结构信息（标题层级、列表层级、段落类型等）
  - 在提示词中传递结构信息，让 AI 自行分析
- ⚠️ **记忆库集成优化**：
  - 优化记忆库检索算法，提高相关性
  - 自动检索相关术语、风格偏好、主题信息
  - 在提示词中充分利用记忆库信息
- ⚠️ **提示词优化**：
  - 优化提示词，让 AI 更好地自行分析语义、风格、连贯性
  - 测试不同提示词版本的效果

#### 12.1.3 P2 优先级（低优先级，可选实现）

- 📋 **记忆库术语管理**：
  - 优化记忆库中的术语管理功能
  - 自动从文档中提取术语并保存到记忆库
  - 在提示词中充分利用记忆库中的术语信息
- 📋 **用户偏好学习**：
  - 收集用户的续写选择数据
  - 将用户偏好保存到记忆库
  - 根据记忆库中的偏好调整提示词
- 📋 **提示词持续优化**：
  - A/B 测试不同提示词版本的效果
  - 根据用户反馈持续优化提示词
  - 建立提示词版本管理系统

### 12.2 性能优化

- **减少不必要的 AI 调用**：优化触发条件，避免频繁调用
- **优化上下文提取算法**：提高提取效率，减少计算时间
- **缓存机制**：
  - 缓存编辑器状态提取结果
  - 缓存记忆库检索结果
  - 减少重复计算，提高响应速度
- **响应时间优化**：目标 < 2 秒（从触发到显示续写内容）

### 12.3 实施建议

**分阶段实施**：
1. **第一阶段（P0）**：实现上下文增强（包括下文提取）、格式适配优化、长度限制优化、编辑器状态提取、记忆库集成
2. **第二阶段（P1）**：优化编辑器状态提取、记忆库检索算法、提示词优化
3. **第三阶段（P2）**：记忆库术语管理、用户偏好学习、提示词持续优化

**持续优化**：
- 数据收集：收集用户的续写选择数据，分析用户偏好
- A/B 测试：测试不同提示词版本的效果
- 用户反馈：收集用户反馈，持续优化提示词
- 性能监控：监控响应时间、资源消耗，优化性能

---

**文档版本**：v1.0  
**创建日期**：2025年  
**维护者**：Binder 开发团队

