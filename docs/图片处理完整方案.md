# 图片处理完整方案

## 一、问题分析

### 1.1 当前问题

1. **编辑器图片显示问题**
   - 插入图片后只显示图标，无法正常显示
   - TipTap Image 扩展配置了 `allowBase64: false`，只支持文件路径
   - `insert_image` 命令返回相对路径 `assets/xxx.png`，浏览器无法访问本地文件系统

2. **DOCX 草稿图片处理问题**
   - `convert_document_to_html` 使用 `--extract-media=.` 提取图片
   - 但**没有处理图片路径**，HTML 中可能包含：
     - 相对路径（无法加载）
     - 大量 base64 图片（导致内存溢出和应用崩溃）

3. **内存和性能问题**
   - 大图片直接 base64 会导致内存占用过大
   - 大量图片会导致 HTML 字符串过大，应用崩溃

### 1.2 影响范围

- **编辑器插入图片功能**：无法正常显示
- **DOCX 草稿打开**：带图片的文档会导致应用崩溃
- **用户体验**：图片功能基本不可用

## 二、解决方案

### 2.1 核心策略

**统一图片处理策略**：
1. **小图片（< 1MB）**：直接转换为 base64 data URL
2. **大图片（≥ 1MB）**：先压缩，再转换为 base64 data URL
3. **压缩策略**：使用 WebP 或 JPEG 质量压缩，平衡文件大小和视觉效果

### 2.2 技术方案

#### 方案架构

```
图片处理流程：
┌─────────────────┐
│  插入图片/转换  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  检查图片大小   │
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
< 1MB      ≥ 1MB
    │         │
    │         ▼
    │    ┌─────────────┐
    │    │ 图片压缩    │
    │    │ (WebP/JPEG) │
    │    └─────┬───────┘
    │          │
    └──────┬───┘
           │
           ▼
    ┌─────────────┐
    │ 转换为 base64│
    │  data URL    │
    └─────┬───────┘
          │
          ▼
    ┌─────────────┐
    │ 插入编辑器  │
    │ (TipTap)    │
    └─────────────┘
```

## 三、技术实现

### 3.1 图片压缩策略

#### 压缩方式选择

| 图片类型 | 压缩方式 | 质量参数 | 目标大小 | 说明 |
|---------|---------|---------|---------|------|
| 照片类（JPEG） | WebP 转换 | 85% | < 1MB | JPEG 转 WebP，有质量参数 |
| 图标/截图（PNG） | WebP 转换（保持透明度） | 85% | < 500KB | PNG 转 WebP，WebP 支持透明度，有质量参数 |
| 大图片（> 5MB） | WebP 转换 + 尺寸限制 | 80% | < 2MB | 先缩小尺寸再转 WebP |
| 已有 WebP | WebP 重新编码 | 80-85% | 根据原大小 | 优化现有 WebP |

**注意**：PNG 是无损格式，没有质量参数。文档中提到的"PNG 优化，质量 85%"实际是指将 PNG 转换为 WebP（质量 85%），WebP 支持透明度且压缩比更好。

#### 压缩阈值（初始值，需根据测试结果调优）

- **< 1MB**：不压缩，直接 base64
- **1-5MB**：压缩到 500KB-1MB，质量 85%
- **> 5MB**：压缩到 1-2MB，质量 80%，尺寸限制 2000px

**注意**：这些阈值是初始建议值，实际实施后需要根据以下因素调优：
- 压缩时间是否可接受
- 压缩质量是否满足用户需求
- 内存占用是否合理
- 不同图片类型的压缩效果差异

### 3.2 后端实现

#### 3.2.1 修改 `insert_image` 命令

**位置**：`src-tauri/src/services/image_service.rs`

**功能增强**：
1. 复制图片到 `assets/` 目录（保留原始文件，用于保存 DOCX）
2. 检查图片大小
3. 小图片：直接读取并转换为 base64
4. 大图片：压缩后转换为 base64
5. **返回格式**：返回包含 base64 data URL 和相对路径的结构体

**推荐方案：双路径策略**
- **返回结构**：`{ dataUrl: string, relativePath: string }`
- **dataUrl**：用于编辑器显示（base64 data URL）
- **relativePath**：用于保存 DOCX 时引用原始文件（`assets/xxx.png`）
- **优势**：显示和保存分离，避免 base64 数据丢失，兼容现有保存逻辑

**返回格式示例**：
```json
{
  "dataUrl": "data:image/webp;base64,xxx...",
  "relativePath": "assets/uuid.png"
}
```

#### 3.2.2 新增图片压缩函数

**函数签名**：
```rust
fn compress_image(
    image_path: &Path,
    max_size_kb: usize,  // 目标大小（KB）
    quality: u8,         // 质量（0-100）
) -> Result<Vec<u8>, String>
```

**压缩逻辑**：
1. 使用 `image` crate 读取图片（需要启用 `webp` feature）
2. 检测图片格式（JPEG/PNG/WebP/GIF/BMP）
3. 根据格式选择压缩方式：
   - **JPEG/照片**：转换为 WebP，质量 85%
   - **PNG/图标**：转换为 WebP（保持透明度），质量 85%
   - **WebP**：重新编码优化，质量 80-85%
   - **GIF/BMP**：转换为 WebP，质量 85%
4. **尺寸限制**：如果图片宽度或高度超过 2000px，先按比例缩小
5. **质量降级**：如果压缩后仍超过目标大小，降低质量重试（最多 3 次，每次降低 10%）
6. 返回压缩后的图片数据（Vec<u8>）

#### 3.2.3 修改 `convert_document_to_html` 函数

**位置**：`src-tauri/src/services/pandoc_service.rs`

**功能增强**：
1. 在转换后处理 HTML 中的图片
2. 提取所有 `<img>` 标签
3. 对每个图片：
   - 检查文件大小
   - 小图片：转换为 base64
   - 大图片：压缩后转换为 base64
4. 替换 HTML 中的图片路径为 base64 data URL

### 3.3 前端实现

#### 3.3.1 修改 TipTap Image 扩展配置

**位置**：`src/components/Editor/TipTapEditor.tsx`

**修改内容**：
```typescript
Image.configure({
  inline: true,
  allowBase64: true,  // ✅ 改为 true，允许 base64
  HTMLAttributes: {
    class: 'editor-image',
  },
})
```

#### 3.3.2 图片插入逻辑（无需修改）

**位置**：`src/components/Editor/EditorToolbar.tsx`

**当前逻辑**：
- 调用 `insert_image` 命令
- 使用返回的路径插入图片

**修改后**：
- `insert_image` 返回 `{ dataUrl, relativePath }` 结构
- 使用 `dataUrl` 插入图片到编辑器（base64 data URL）
- **需要修改前端代码**：从返回结构中提取 `dataUrl` 字段
- **保存时**：TipTap 编辑器会保存 `relativePath` 到 HTML，用于后续 DOCX 保存

## 四、实现细节

### 4.1 图片压缩实现

#### 使用 Rust `image` crate

**依赖**：`Cargo.toml`
```toml
[dependencies]
image = { version = "0.24", features = ["webp"] }  # ✅ 必须启用 webp feature（无损编码）
webp = "0.3"  # ✅ 推荐：用于有损 WebP 编码（更好的压缩比）
scraper = "0.18"  # ✅ 用于 HTML 解析（替代正则表达式，更可靠）
```

**WebP 编码方案选择**：
- **方案 A（推荐）**：使用 `webp` crate 进行有损编码
  - 优势：压缩比更好，支持质量参数
  - 实现：`webp::Encoder::from_image(&img).encode(quality)`
- **方案 B**：使用 `image` crate 的 `webp` feature（无损编码）
  - 优势：无需额外依赖
  - 劣势：压缩比不如有损编码

**技术验证**：
- ✅ `image` crate 0.24 支持 WebP 编码，但需要启用 `webp` feature
- ✅ WebP 编码 API：`ImageOutputFormat::WebP(quality)` 或 `ImageFormat::WebP`
- ⚠️ **重要**：`image` crate 0.24 的 `webp` feature 仅支持**无损 WebP 编码**
- ⚠️ **如果需要有损 WebP 编码**（推荐，压缩比更好），需要使用 `webp` crate：
  ```toml
  webp = "0.3"  # 用于有损 WebP 编码
  ```
- ⚠️ **降级方案**：如果 WebP 不可用，降级为 JPEG 压缩（质量 85%）

**压缩函数实现**：
```rust
use image::{ImageFormat, DynamicImage};

fn compress_image(
    image_path: &Path,
    max_size_kb: usize,
    quality: u8,
) -> Result<Vec<u8>, String> {
    // 1. 读取图片
    let img = image::open(image_path)
        .map_err(|e| format!("读取图片失败: {}", e))?;
    
    // 2. 检测格式
    let format = image::ImageFormat::from_path(image_path)
        .unwrap_or(ImageFormat::Png);
    
    // 3. 压缩策略
    let compressed = match format {
        ImageFormat::Jpeg | ImageFormat::Png => {
            // 转换为 WebP
            compress_to_webp(&img, quality, max_size_kb)
        }
        _ => {
            // 其他格式保持原样或转换为 PNG
            compress_to_png(&img, quality, max_size_kb)
        }
    };
    
    Ok(compressed)
}
```

### 4.2 DOCX 图片处理流程

#### 处理步骤

1. **Pandoc 转换**
   - 使用 `--extract-media=.` 提取图片到当前目录
   - 生成包含相对路径的 HTML

2. **图片路径处理**
   - 使用 `scraper` 库解析 HTML（替代正则表达式，更可靠）
   - 提取所有 `<img>` 标签的 `src` 属性
   - 跳过已经是 data URL 的图片（`src.starts_with("data:")`）
   - 构建完整路径：`{当前目录}/{相对路径}`
   - 处理 Pandoc 可能生成的各种路径格式（相对路径、绝对路径等）

3. **图片压缩和转换**
   - 检查图片文件大小
   - 小图片：直接读取并 base64 编码
   - 大图片：压缩后 base64 编码

4. **替换 HTML**
   - 将 `<img src="相对路径">` 替换为 `<img src="data:image/xxx;base64,xxx">`

### 4.3 内存优化

#### 策略

1. **流式处理**
   - 逐个处理图片，避免同时加载所有图片到内存

2. **及时释放**
   - 压缩完成后立即释放原始图片数据
   - 只保留 base64 字符串

3. **大小限制**
   - 单个图片压缩后不超过 2MB
   - 如果压缩后仍超过限制，进一步降低质量

## 五、代码修改清单

### 5.1 后端修改

#### 文件：`src-tauri/src/services/image_service.rs`

1. **修改 `insert_image` 函数**
   - 添加图片大小检查
   - 添加压缩逻辑
   - **返回格式**：返回 `{ dataUrl: string, relativePath: string }` 结构
   - `dataUrl`：用于编辑器显示（base64 data URL）
   - `relativePath`：用于保存 DOCX 时引用原始文件（`assets/xxx.png`）

2. **新增 `compress_image` 函数**
   - 实现图片压缩逻辑
   - 支持 WebP 和 PNG 优化

3. **新增 `image_to_base64` 函数**
   - 将图片数据转换为 base64 data URL
   - 自动检测 MIME 类型

#### 文件：`src-tauri/src/services/pandoc_service.rs`

1. **修改 `convert_document_to_html` 函数**
   - 在返回 HTML 前处理图片路径
   - 调用图片压缩和 base64 转换
   - 替换 HTML 中的图片路径

2. **新增 `process_images_in_html` 函数**
   - 使用 `scraper` 库解析 HTML（替代正则表达式）
   - 扫描 HTML 中的图片标签
   - 处理每个图片（压缩 + base64）
   - 返回处理后的 HTML

3. **新增 `convert_base64_to_relative_path` 函数**（用于保存 DOCX）
   - 将 HTML 中的 base64 data URL 解码
   - 保存到 `assets/` 目录
   - 替换 HTML 中的 `src` 为相对路径

### 5.2 前端修改

#### 文件：`src/components/Editor/TipTapEditor.tsx`

1. **修改 Image 扩展配置**
   - `allowBase64: false` → `allowBase64: true`

#### 文件：`src/components/Editor/EditorToolbar.tsx`

1. **需要修改**
   - `insert_image` 返回 `{ dataUrl, relativePath }` 结构
   - 从返回结构中提取 `dataUrl` 用于插入图片
   - 示例代码：
     ```typescript
     const result = await invoke<{ dataUrl: string; relativePath: string }>('insert_image', {
       documentPath,
       imageSource: selected
     });
     editor.chain().focus().setImage({ src: result.dataUrl }).run();
     ```

## 六、压缩质量参数

### 6.1 质量参数建议

| 场景 | 质量参数 | 说明 |
|-----|---------|------|
| 小图片（< 1MB） | 不压缩 | 保持原始质量 |
| 中等图片（1-5MB） | 85% | 视觉损失很小 |
| 大图片（> 5MB） | 80% | 可接受的视觉损失 |
| 超大图片（> 10MB） | 75% + 尺寸限制 | 必要时缩小尺寸 |

### 6.2 格式选择

- **照片类图片**：优先使用 WebP（更好的压缩比）
- **图标/截图**：使用 PNG 优化（保持透明度）
- **已有 WebP**：直接使用，不重复转换

## 七、测试建议

### 7.1 功能测试

1. **插入图片测试**
   - 小图片（< 1MB）：验证正常显示
   - 大图片（1-5MB）：验证压缩后显示
   - 超大图片（> 5MB）：验证压缩和尺寸限制

2. **DOCX 草稿测试**
   - 无图片文档：验证正常打开
   - 少量图片文档：验证图片正常显示
   - 大量图片文档：验证不崩溃，图片正常显示

3. **内存测试**
   - 打开包含 10+ 张图片的文档
   - 监控内存占用
   - 验证不会导致应用崩溃

### 7.2 性能测试

1. **压缩性能**
   - 测试 5MB 图片压缩时间（目标 < 2秒）
   - 测试 10MB 图片压缩时间（目标 < 5秒）

2. **加载性能**
   - 测试包含 20 张图片的文档打开时间
   - 验证图片逐步加载，不阻塞界面

## 八、风险评估

### 8.1 潜在风险

1. **压缩质量损失**
   - **风险**：压缩后图片质量下降
   - **缓解**：使用高质量参数（80-85%），视觉损失很小

2. **压缩性能**
   - **风险**：大图片压缩耗时
   - **缓解**：异步处理，不阻塞 UI

3. **内存占用**
   - **风险**：大量 base64 图片占用内存
   - **缓解**：压缩后大小限制，及时释放原始数据

### 8.2 兼容性

- **浏览器支持**：base64 data URL 所有现代浏览器都支持
- **TipTap 支持**：Image 扩展支持 base64（需要配置 `allowBase64: true`）
- **Rust image crate**：已包含在依赖中（`image = "0.24"`），无需额外安装

### 8.3 回退方案

如果压缩失败或出现问题：
1. **小图片**：直接使用原始图片 base64（不压缩）
2. **大图片**：如果压缩失败，返回错误信息，提示用户使用较小的图片
3. **DOCX 转换**：如果图片处理失败，保留原始路径，显示占位符

## 九、详细实现步骤

### 9.1 后端实现步骤

#### 步骤 1：增强 ImageService

**文件**：`src-tauri/src/services/image_service.rs`

1. **添加压缩相关依赖检查**
   - 确认 `image` crate 已包含
   - 确认支持 WebP 编码（可能需要 `webp` feature）

2. **实现 `compress_image` 函数**
   ```rust
   fn compress_image(
       image_path: &Path,
       max_size_kb: usize,
       quality: u8,
   ) -> Result<Vec<u8>, String>
   ```
   - 读取图片
   - 检测格式
   - 应用压缩策略
   - 返回压缩后的字节数据

3. **实现 `image_to_base64_data_url` 函数**
   ```rust
   fn image_to_base64_data_url(
       image_data: &[u8],
       mime_type: &str,
   ) -> String
   ```
   - 将图片数据编码为 base64
   - 生成 data URL 格式

4. **修改 `insert_image` 函数**
   - 保留原始逻辑（复制到 assets/）
   - 添加图片处理逻辑：
     - 检查文件大小
     - 小图片：直接读取并 base64
     - 大图片：压缩后 base64
   - 返回 base64 data URL

#### 步骤 2：增强 PandocService

**文件**：`src-tauri/src/services/pandoc_service.rs`

1. **实现 `process_images_in_html` 函数**
   ```rust
   fn process_images_in_html(
       html: &str,
       media_dir: &Path,
       docx_path: &Path,
   ) -> Result<String, String>
   ```
   - 使用正则表达式提取所有 `<img>` 标签
   - 对每个图片：
     - 解析相对路径
     - 构建完整路径
     - 检查文件大小
     - 处理图片（压缩 + base64）
     - 替换 HTML 中的路径

2. **修改 `convert_document_to_html` 函数**
   - 在返回 HTML 前调用 `process_images_in_html`
   - 处理 Pandoc 提取的图片路径

### 9.2 前端实现步骤

#### 步骤 1：修改 TipTap Image 扩展

**文件**：`src/components/Editor/TipTapEditor.tsx`

```typescript
Image.configure({
  inline: true,
  allowBase64: true,  // 改为 true
  HTMLAttributes: {
    class: 'editor-image',
  },
})
```

#### 步骤 2：验证图片显示

- 插入图片后，验证 base64 data URL 能正常显示
- 测试不同大小的图片

### 9.3 错误处理

#### 后端错误处理

1. **图片读取失败**
   - 返回明确的错误信息
   - 记录日志

2. **压缩失败**
   - 尝试降级处理（降低质量重试）
   - 如果仍失败，返回错误

3. **格式不支持**
   - 尝试转换为支持的格式
   - 如果无法转换，返回错误

#### 前端错误处理

1. **图片加载失败**
   - 显示占位符
   - 显示错误提示

2. **base64 数据无效**
   - 验证 data URL 格式
   - 显示错误信息

## 十、压缩算法详细说明

### 10.1 WebP 压缩

#### 优势
- 比 JPEG 小 25-35%
- 比 PNG 小 26%
- 支持透明度
- 现代浏览器广泛支持

#### 实现方式

```rust
use image::{DynamicImage, ImageFormat, ImageOutputFormat};
use std::io::Cursor;

fn encode_to_webp(img: &DynamicImage, quality: u8) -> Result<Vec<u8>, String> {
    let mut buffer = Vec::new();
    let mut cursor = Cursor::new(&mut buffer);
    
    // 使用 ImageOutputFormat::WebP 编码
    // 注意：需要启用 image crate 的 webp feature
    img.write_to(&mut cursor, ImageOutputFormat::WebP(quality))
        .map_err(|e| format!("WebP 编码失败: {}", e))?;
    
    Ok(buffer)
}
```

**技术验证**：
- ✅ `webp` crate 0.3 提供有损 WebP 编码支持（推荐）
- ✅ API：`webp::Encoder::from_rgba(&rgba, width, height).encode(quality)`
- ✅ `image` crate 0.24 的 `webp` feature 提供无损 WebP 编码支持（降级方案）
- ⚠️ 如果 `webp` crate 不可用，降级为 `image` crate 的 WebP 编码
- ⚠️ 如果 WebP 完全不可用，最终降级为 JPEG 压缩（质量 85%）

**实际 API 使用**：
```rust
// 推荐：使用 webp crate（有损编码）
use webp::{Encoder, WebPMemory};
let encoder = Encoder::from_rgba(rgba.as_raw(), width, height);
let webp: WebPMemory = encoder.encode(quality as f32)?;
let webp_data = webp.to_vec();
```

#### 质量参数
- **85%**：高质量，视觉损失很小
- **80%**：平衡质量和大小
- **75%**：可接受的视觉损失

### 10.2 PNG 优化

#### 适用场景
- 图标、截图
- 需要透明度的图片
- 简单图形

#### 优化策略（已改为 WebP 转换）

**注意**：PNG 是无损格式，没有质量参数。推荐将 PNG 转换为 WebP：

1. **WebP 转换**：PNG → WebP（质量 85%）
   - WebP 支持透明度（alpha 通道）
   - 压缩比通常比 PNG 好 26%
   - 有质量参数可调

2. **如果必须保持 PNG 格式**（不推荐）：
   - 颜色量化：减少颜色数量（256 色 → 128 色）
   - 压缩级别：使用 PNG 压缩级别 6-9（`image` crate 的 `png` feature）
   - 尺寸优化：必要时缩小尺寸

**推荐方案**：统一使用 WebP 转换，简化实现逻辑

### 10.3 JPEG 质量压缩

#### 适用场景
- 照片类图片
- 不需要透明度

#### 质量参数
- **85%**：高质量
- **80%**：标准质量
- **75%**：可接受质量

### 10.4 尺寸限制

#### 策略
- 如果图片宽度或高度超过 2000px，按比例缩小
- 保持宽高比
- 缩小后再压缩

#### 实现
```rust
if img.width() > 2000 || img.height() > 2000 {
    let scale = 2000.0 / img.width().max(img.height()) as f32;
    img = img.resize(
        (img.width() as f32 * scale) as u32,
        (img.height() as f32 * scale) as u32,
        image::imageops::FilterType::Lanczos3,
    );
}
```

## 十一、性能优化

### 11.1 异步处理

#### 策略
- 图片压缩使用异步任务
- 不阻塞主线程
- 显示加载进度

#### 实现

```rust
// 使用 tokio::spawn_blocking 处理图片压缩（不阻塞主线程）
let compressed = tokio::task::spawn_blocking(move || {
    compress_image(&img_path, max_size_kb, quality)
}).await
.map_err(|e| format!("压缩任务失败: {}", e))??;

// 批量处理时，使用并发控制（最多同时处理 3 张图片）
use tokio::sync::Semaphore;
use std::sync::Arc;
let semaphore = Arc::new(Semaphore::new(3));

// 收集所有任务
let mut tasks = Vec::new();

for img_path in image_paths {
    let permit = semaphore.clone().acquire_owned().await?;
    let img_path_clone = img_path.clone();
    
    let task = tokio::spawn(async move {
        let _permit = permit;
        let compressed = tokio::task::spawn_blocking(move || {
            compress_image(&img_path_clone, max_size_kb, quality)
        }).await??;
        Ok::<_, String>(compressed)
    });
    
    tasks.push(task);
}

// 等待所有任务完成
for task in tasks {
    let result = task.await??;
    // 处理结果...
}
```

#### 进度回调（可选，用于前端显示进度）

```rust
// 定义进度回调类型
type ProgressCallback = Box<dyn Fn(usize, usize) + Send + Sync>;

// 在批量处理时调用
let total = image_paths.len();
for (index, img_path) in image_paths.iter().enumerate() {
    // 调用进度回调（前端可以显示进度条）
    if let Some(callback) = &progress_callback {
        callback(index + 1, total);
    }
    
    // 处理图片...
    let compressed = tokio::task::spawn_blocking(move || {
        compress_image(img_path, max_size_kb, quality)
    }).await??;
    
    // 处理结果...
}
```

**前端进度显示示例**：
```typescript
// 前端可以监听进度事件
const progressCallback = (current: number, total: number) => {
  const progress = (current / total) * 100;
  console.log(`图片处理进度: ${progress.toFixed(1)}%`);
  // 更新 UI 进度条
};
```

### 11.2 缓存机制

#### 策略
- 压缩后的图片可以缓存
- 使用文件哈希作为缓存键
- 避免重复压缩

#### 实现位置
- 缓存目录：`{cache_dir}/compressed_images/`
- 缓存键：文件路径 + 修改时间 + 压缩参数

### 11.3 批量处理优化

#### DOCX 转换中的图片处理
- 逐个处理图片，避免同时加载所有图片
- 使用进度回调，显示处理进度
- 处理失败时继续处理其他图片

## 十二、开发计划

### 12.1 第一阶段：基础功能

**目标**：实现图片压缩和 base64 转换

1. ✅ 实现 `compress_image` 函数
2. ✅ 实现 `image_to_base64_data_url` 函数
3. ✅ 修改 `insert_image` 返回 base64
4. ✅ 修改 TipTap Image 扩展配置

**预计时间**：2-3 小时

### 12.2 第二阶段：DOCX 图片处理

**目标**：处理 DOCX 转换中的图片

1. ✅ 实现 `process_images_in_html` 函数
2. ✅ 修改 `convert_document_to_html` 函数
3. ✅ 测试带图片的 DOCX 文档

**预计时间**：2-3 小时

### 12.3 第三阶段：优化和测试

**目标**：性能优化和全面测试

1. ✅ 添加错误处理
2. ✅ 性能优化（异步处理）
3. ✅ 内存测试
4. ✅ 兼容性测试

**预计时间**：2-3 小时

**总计**：6-9 小时

## 十三、代码示例

### 13.1 完整的压缩函数示例

```rust
use image::{DynamicImage, ImageFormat};
use std::path::Path;

fn compress_image(
    image_path: &Path,
    max_size_kb: usize,
    quality: u8,
) -> Result<Vec<u8>, String> {
    // 1. 读取图片
    let mut img = image::open(image_path)
        .map_err(|e| format!("读取图片失败: {}", e))?;
    
    // 2. 检测格式
    let format = image::ImageFormat::from_path(image_path)
        .unwrap_or(ImageFormat::Png);
    
    // 3. 尺寸限制（如果图片过大）
    if img.width() > 2000 || img.height() > 2000 {
        let scale = 2000.0 / img.width().max(img.height()) as f32;
        img = img.resize(
            (img.width() as f32 * scale) as u32,
            (img.height() as f32 * scale) as u32,
            image::imageops::FilterType::Lanczos3,
        );
    }
    
    // 4. 压缩策略（统一转换为 WebP）
    let compressed = encode_to_webp(&img, quality)?;
    
    // 5. 验证大小，如果超过限制则降级重试
    if compressed.len() > max_size_kb * 1024 {
        // 降级策略：最多重试 3 次
        let mut current_quality = quality;
        let mut current_compressed = compressed;
        
        for attempt in 1..=3 {
            if current_compressed.len() <= max_size_kb * 1024 {
                break;
            }
            
            // 降低质量
            current_quality = current_quality.saturating_sub(10);
            if current_quality < 50 {
                // 如果质量太低，尝试缩小尺寸
                let scale = 0.8;
                img = img.resize(
                    (img.width() as f32 * scale) as u32,
                    (img.height() as f32 * scale) as u32,
                    image::imageops::FilterType::Lanczos3,
                );
                current_quality = 75; // 重置质量
            }
            
            current_compressed = encode_to_webp(&img, current_quality)?;
            
            if attempt == 3 && current_compressed.len() > max_size_kb * 1024 {
                return Err(format!(
                    "图片压缩后仍超过限制 ({}KB > {}KB)，请使用较小的图片",
                    current_compressed.len() / 1024,
                    max_size_kb
                ));
            }
        }
        
        Ok(current_compressed)
    } else {
        Ok(compressed)
    }
}

// WebP 编码辅助函数（使用 webp crate 进行有损编码）
fn encode_to_webp(img: &DynamicImage, quality: u8) -> Result<Vec<u8>, String> {
    use webp::{Encoder, WebPMemory};
    
    // 将 DynamicImage 转换为 RGB/RGBA
    let rgba = img.to_rgba8();
    let (width, height) = rgba.dimensions();
    
    // 使用 webp crate 进行有损编码
    let encoder = Encoder::from_rgba(rgba.as_raw(), width, height);
    let webp: WebPMemory = encoder.encode(quality as f32)
        .map_err(|e| format!("WebP 编码失败: {}", e))?;
    
    Ok(webp.to_vec())
}

// 降级方案：如果 webp crate 不可用，使用 JPEG 压缩
#[cfg(not(feature = "webp"))]
fn encode_to_webp_fallback(img: &DynamicImage, quality: u8) -> Result<Vec<u8>, String> {
    use image::{ImageOutputFormat};
    use std::io::Cursor;
    
    let mut buffer = Vec::new();
    let mut cursor = Cursor::new(&mut buffer);
    
    // 降级为 JPEG 压缩
    img.write_to(&mut cursor, ImageOutputFormat::Jpeg(quality))
        .map_err(|e| format!("JPEG 编码失败: {}", e))?;
    
    Ok(buffer)
}
```

### 13.2 HTML 图片处理示例（使用 scraper 库）

```rust
use scraper::{Html, Selector};
use std::path::Path;

fn process_images_in_html(
    html: &str,
    media_dir: &Path,
    docx_path: &Path,
) -> Result<String, String> {
    // 使用 scraper 解析 HTML（比正则表达式更可靠）
    let document = Html::parse_document(html);
    let img_selector = Selector::parse("img")
        .map_err(|e| format!("选择器解析失败: {}", e))?;
    
    let mut processed_html = html.to_string();
    let mut replacements = Vec::new();
    
    // 从后往前替换，避免索引偏移
    for element in document.select(&img_selector) {
        if let Some(src_attr) = element.value().attr("src") {
            // 跳过已经是 data URL 的图片
            if src_attr.starts_with("data:") {
                continue;
            }
            
            // 处理相对路径
            let img_path = if src_attr.starts_with("/") {
                // 绝对路径
                Path::new(src_attr).to_path_buf()
            } else {
                // 相对路径
                media_dir.join(src_attr)
            };
            
            if !img_path.exists() {
                eprintln!("⚠️ 图片文件不存在: {:?}", img_path);
                continue;
            }
            
            // 处理图片
            match process_single_image(&img_path) {
                Ok(data_url) => {
                    replacements.push((src_attr.to_string(), data_url));
                }
                Err(e) => {
                    eprintln!("⚠️ 图片处理失败: {:?}, 错误: {}", img_path, e);
                }
            }
        }
    }
    
    // 替换所有找到的图片路径
    for (old_src, new_src) in replacements {
        processed_html = processed_html.replace(&old_src, &new_src);
    }
    
    Ok(processed_html)
}

fn process_single_image(img_path: &Path) -> Result<String, String> {
    let metadata = std::fs::metadata(img_path)
        .map_err(|e| format!("无法读取图片元数据: {}", e))?;
    let file_size = metadata.len();
    
    let image_data = if file_size < 1024 * 1024 {
        // 小图片：直接读取
        std::fs::read(img_path)
            .map_err(|e| format!("读取图片失败: {}", e))?
    } else {
        // 大图片：压缩
        compress_image(img_path, 1024, 85)
            .map_err(|e| format!("压缩图片失败: {}", e))?
    };
    
    // 转换为 base64 data URL
    // MIME 类型检测：优先使用文件扩展名，如果压缩后是 WebP，使用 image/webp
    let mime_type = if image_data.len() > 12 && &image_data[0..4] == b"RIFF" && &image_data[8..12] == b"WEBP" {
        "image/webp"  // 检测到 WebP 文件头
    } else {
        detect_mime_type_by_extension(img_path)?
    };
    
    let base64_str = general_purpose::STANDARD.encode(&image_data);
    Ok(format!("data:{};base64,{}", mime_type, base64_str))
}

// MIME 类型检测函数（基于文件扩展名）
fn detect_mime_type_by_extension(img_path: &Path) -> Result<&'static str, String> {
    let ext = img_path.extension()
        .and_then(|e| e.to_str())
        .unwrap_or("")
        .to_lowercase();
    
    match ext.as_str() {
        "png" => Ok("image/png"),
        "jpg" | "jpeg" => Ok("image/jpeg"),
        "gif" => Ok("image/gif"),
        "webp" => Ok("image/webp"),
        "svg" => Ok("image/svg+xml"),
        "bmp" => Ok("image/bmp"),
        _ => Ok("image/png"), // 默认 PNG
    }
}
```

## 十四、注意事项

### 14.1 图片格式支持

#### 支持的输入格式
- JPEG/JPG
- PNG
- WebP
- GIF（转换为 PNG）
- BMP（转换为 PNG）

#### 输出格式
- 小图片：保持原格式（base64）
- 大图片：优先使用 WebP（base64）

### 14.2 文件大小限制

#### 建议限制

- **单个图片**：压缩后不超过 2MB
- **文档总图片**：不超过 50MB（所有图片 base64 总和）

**超限处理策略**：

1. **单个图片超过 2MB**：
   - 第 1 次：降低质量 10%，重新压缩
   - 第 2 次：降低质量 10% + 缩小尺寸 20%，重新压缩
   - 第 3 次：如果仍超过，返回错误：`"图片过大，压缩后仍超过 2MB。请使用较小的图片或手动压缩。"`
   - 记录错误日志

2. **文档总图片超过 50MB**：
   - **处理策略**：
     - 处理前 20 张图片（按顺序，优先处理）
     - 后续图片显示占位符和提示：`"图片过多（总大小超过 50MB），部分图片未加载。请减少图片数量或压缩图片。"`
     - 记录警告日志：`"文档图片总大小超过限制: {}MB > 50MB，已处理前 20 张图片"`
   - **用户提示**：
     - 在编辑器顶部显示警告横幅
     - 提示用户减少图片数量或压缩图片
     - 提供"继续处理剩余图片"选项（可选，但可能影响性能）

### 14.3 保存时的处理

#### 保存流程（重要）

1. **编辑器中的图片数据**
   - TipTap 编辑器保存的 HTML 中包含图片的 `src` 属性
   - 如果图片是 base64 data URL，需要转换为相对路径
   - 如果图片已经是相对路径（`assets/xxx.png`），保持不变

2. **HTML → DOCX 转换前的图片处理**
   - 扫描 HTML 中的所有 `<img>` 标签
   - 对于 base64 data URL：
     - 解码 base64 数据
     - 保存到 `assets/` 目录（如果不存在）
     - 替换 HTML 中的 `src` 为相对路径（`assets/xxx.png`）
   - 对于相对路径：
     - 验证文件是否存在
     - 如果不存在，尝试从 base64 恢复或显示占位符

3. **Pandoc 转换**
   - Pandoc 会将相对路径的图片嵌入到 DOCX 文件中
   - 使用 `--extract-media` 的逆过程（嵌入媒体）

4. **原始文件保留策略**
   - **插入图片时**：原始文件保存在 `assets/` 目录
   - **编辑器显示**：使用 base64 data URL（快速显示）
   - **保存 DOCX**：使用 `assets/` 中的原始文件（保证质量）
   - **不要保存 base64**：base64 数据不保存到 DOCX 文件中

#### 兼容性考虑

- **已存在的相对路径图片**：直接使用，无需转换
- **新插入的图片**：同时保存原始文件和生成 base64
- **从 DOCX 转换的图片**：Pandoc 提取后，处理为 base64 用于显示，保留原始文件用于保存

### 14.4 性能考虑

#### 压缩时间
- **1MB 图片**：< 500ms
- **5MB 图片**：< 2秒
- **10MB 图片**：< 5秒

#### 内存占用
- **单个图片 base64**：原始大小的 1.33 倍（base64 编码开销）
- **压缩后 base64**：通常减少 50-70%
- **建议限制**：单个文档总图片 base64 不超过 50MB

### 14.5 错误处理策略

#### 图片处理失败

1. **读取失败**
   - 返回明确的错误信息：`"无法读取图片文件: {错误详情}"`
   - 记录日志（文件路径、错误类型）
   - 提示用户检查文件权限和文件完整性

2. **压缩失败**
   - **重试策略**：最多重试 3 次
   - **降级策略**：
     - 第 1 次：降低质量 10%（85% → 75%）
     - 第 2 次：降低质量 10%（75% → 65%）
     - 第 3 次：降低质量 10%（65% → 55%）+ 缩小尺寸（如果仍超过限制）
   - **最终失败**：返回错误，提示用户使用较小的图片或手动压缩

3. **格式不支持**
   - 尝试转换为 WebP（如果支持）
   - 如果 WebP 不可用，尝试转换为 PNG
   - 如果仍失败，返回错误：`"不支持的图片格式: {格式}"`

4. **内存不足**
   - 检测到内存不足时，跳过压缩，直接使用原始图片 base64（如果小于 5MB）
   - 如果原始图片过大，返回错误，提示用户减少图片数量

#### DOCX 转换中的图片处理
- **单个图片失败**：记录错误，继续处理其他图片
- **所有图片失败**：返回警告，但继续返回 HTML（图片显示占位符）

## 十五、依赖检查

### 15.1 Rust 依赖

#### 当前依赖
- ✅ `image = "0.24"` - 已包含

#### 必须启用的 features

- ✅ **WebP 支持（推荐方案）**：使用 `webp` crate 进行有损编码
  ```toml
  webp = "0.3"  # 有损 WebP 编码，压缩比更好
  image = { version = "0.24", features = ["webp"] }  # 可选：用于无损编码降级
  ```

- ✅ **HTML 解析**：使用 `scraper` 库替代正则表达式，更可靠
  ```toml
  scraper = "0.18"
  ```

**WebP 编码方案说明**：
- **推荐**：使用 `webp` crate（有损编码，压缩比更好）
- **降级**：如果 `webp` crate 不可用，使用 `image` crate 的 `webp` feature（无损编码）
- **最终降级**：如果 WebP 完全不可用，使用 JPEG 压缩（质量 85%）

#### 可选依赖（性能优化）
- `oxipng` - PNG 优化（可选，如果 PNG 优化效果不佳）
- `mozjpeg` - JPEG 优化（可选，如果 JPEG 压缩效果不佳）

### 15.2 前端依赖

#### 当前依赖
- ✅ `@tiptap/extension-image` - 已包含
- ✅ TipTap 支持 base64（需要配置）

#### 无需额外依赖
- base64 编码使用浏览器原生支持
- 无需额外的图片处理库

## 十六、实现优先级

### 16.1 P0（必须实现）

1. **修改 `insert_image` 返回 base64**
   - 解决编辑器图片显示问题
   - 影响：编辑器插入图片功能

2. **修改 TipTap Image 扩展配置**
   - 允许 base64
   - 影响：编辑器图片显示

3. **DOCX 转换图片处理**
   - 处理 Pandoc 提取的图片
   - 影响：DOCX 草稿打开不崩溃

### 16.2 P1（重要优化）

1. **图片压缩功能**
   - 减少内存占用
   - 提升性能

2. **错误处理**
   - 提升稳定性
   - 改善用户体验

### 16.3 P2（可选优化）

1. **压缩缓存**
   - 提升重复打开性能
   - 减少 CPU 占用

2. **异步处理优化**
   - 提升大图片处理体验
   - 显示进度

## 十七、测试用例

### 17.1 插入图片测试

#### 测试用例 1：小图片插入
- **输入**：100KB PNG 图片
- **预期**：直接 base64，正常显示
- **验证点**：图片清晰，加载快速

#### 测试用例 2：中等图片插入
- **输入**：3MB JPEG 图片
- **预期**：压缩到 1MB 左右，质量 85%
- **验证点**：图片质量可接受，文件大小减少

#### 测试用例 3：大图片插入
- **输入**：8MB PNG 图片（2000x3000）
- **预期**：压缩到 1-2MB，尺寸限制 2000px，质量 80%
- **验证点**：图片清晰度可接受，文件大小显著减少

### 17.2 DOCX 转换测试

#### 测试用例 4：无图片文档
- **输入**：纯文本 DOCX
- **预期**：正常转换，无错误
- **验证点**：HTML 正常显示

#### 测试用例 5：少量图片文档
- **输入**：包含 3-5 张图片的 DOCX
- **预期**：所有图片正常显示
- **验证点**：图片清晰，不崩溃

#### 测试用例 6：大量图片文档
- **输入**：包含 20+ 张图片的 DOCX
- **预期**：所有图片正常显示，不崩溃
- **验证点**：内存占用合理，加载时间可接受

#### 测试用例 7：超大图片文档
- **输入**：包含 10MB+ 图片的 DOCX
- **预期**：图片压缩后显示，不崩溃
- **验证点**：压缩质量可接受，处理时间合理

### 17.3 边界情况测试

#### 测试用例 8：损坏的图片文件
- **输入**：损坏的图片文件
- **预期**：返回错误，不崩溃
- **验证点**：错误信息明确

#### 测试用例 9：不支持的图片格式
- **输入**：TIFF、RAW 等不支持的格式
- **预期**：尝试转换，失败则返回错误
- **验证点**：错误处理正确

#### 测试用例 10：图片路径不存在
- **输入**：DOCX 中引用的图片文件不存在
- **预期**：显示占位符或跳过，不崩溃
- **验证点**：应用继续运行

## 十八、监控和日志

### 18.1 关键指标

#### 性能指标
- 图片压缩时间
- 图片处理成功率
- 内存占用峰值
- HTML 生成时间

#### 质量指标
- 压缩后文件大小
- 压缩质量参数
- 图片格式转换成功率

### 18.2 日志记录

#### 后端日志
- 图片处理开始/结束
- 压缩参数和结果
- 错误信息
- 性能数据

#### 前端日志
- 图片插入成功/失败
- base64 数据长度
- 图片加载时间

## 十九、后续优化方向

### 19.1 短期优化（1-2 周）

1. **压缩算法优化**
   - 尝试不同的压缩参数
   - 根据图片内容选择最佳压缩方式

2. **缓存机制**
   - 实现压缩结果缓存
   - 减少重复压缩

### 19.2 中期优化（1-2 月）

1. **渐进式加载**
   - 大图片先显示缩略图
   - 点击后加载完整图片

2. **图片编辑功能**
   - 裁剪、旋转
   - 亮度、对比度调整

### 19.3 长期优化（3-6 月）

1. **图片管理**
   - 图片库管理
   - 重复图片检测
   - 图片搜索

2. **AI 图片处理**
   - 自动优化
   - 智能裁剪
   - 内容识别

## 二十、总结

### 20.1 核心方案

1. **统一使用 base64 data URL**
   - 解决浏览器无法访问本地文件的问题
   - 简化前端处理逻辑

2. **智能压缩策略**
   - 小图片不压缩，保持质量
   - 大图片压缩，平衡质量和大小

3. **完整的错误处理**
   - 单个图片失败不影响整体
   - 提供明确的错误信息

### 20.2 预期效果

- ✅ **编辑器图片正常显示**：插入图片后立即显示
- ✅ **DOCX 草稿不崩溃**：带图片的文档正常打开
- ✅ **内存占用合理**：压缩后图片大小可控
- ✅ **用户体验提升**：图片功能完全可用

### 20.3 实施建议

1. **分阶段实施**：先实现基础功能，再优化
2. **充分测试**：覆盖各种图片大小和格式
3. **监控性能**：关注压缩时间和内存占用
4. **收集反馈**：根据用户反馈调整压缩参数

---

## 二十一、技术验证清单

### 21.1 实现前验证

- [ ] **WebP 支持验证**
  - 确认 `webp = "0.3"` 可以正常编译和使用
  - 测试 WebP 编码功能：`webp::Encoder::from_rgba(&rgba, width, height).encode(quality)`
  - 如果 `webp` crate 不可用，测试降级方案：`image` crate 的 `webp` feature
  - 如果 WebP 完全不可用，准备最终降级方案（JPEG 压缩）

- [ ] **HTML 解析验证**
  - 确认 `scraper = "0.18"` 可以正常使用
  - 测试 HTML 解析功能：`Html::parse_document(html)`
  - 验证可以正确提取 `<img>` 标签

- [ ] **TipTap base64 支持验证**
  - 确认 `allowBase64: true` 配置生效
  - 测试插入 base64 data URL 图片
  - 验证图片可以正常显示

### 21.2 实现后验证

- [ ] **功能验证**
  - 插入小图片（< 1MB）：验证正常显示
  - 插入大图片（> 1MB）：验证压缩后显示
  - DOCX 转换：验证图片正常处理

- [ ] **性能验证**
  - 压缩时间：5MB 图片 < 2秒
  - 内存占用：20 张图片 < 100MB
  - 并发处理：3 张图片同时处理不阻塞

- [ ] **错误处理验证**
  - 损坏图片：返回明确错误
  - 不支持格式：尝试转换或返回错误
  - 内存不足：降级处理或返回错误

---

**文档版本**：v2.0  
**最后更新**：2025-01-XX  
**维护者**：Binder 开发团队

**主要更新（v2.0）**：
- ✅ 明确 WebP 支持（推荐使用 `webp` crate 进行有损编码，降级方案已明确）
- ✅ 明确 PNG 压缩策略（转换为 WebP，而非 PNG 优化）
- ✅ 明确 `insert_image` 返回格式（双路径策略：`{ dataUrl, relativePath }`）
- ✅ 明确保存 DOCX 时的图片处理流程（从 base64 解码并保存到 assets/）
- ✅ 补充完整的代码示例函数实现（包括 `encode_to_webp`、`process_single_image`、`detect_mime_type_by_extension`）
- ✅ 改进 Pandoc 图片路径解析（使用 `scraper` 库替代正则表达式）
- ✅ 明确错误处理策略（重试 3 次，每次降低质量 10%，最终失败返回错误）
- ✅ 明确内存限制处理策略（单个图片 2MB，文档总图片 50MB，超限处理策略）
- ✅ 明确异步处理实现细节（并发控制、进度回调）
- ✅ 明确压缩阈值调优说明（初始值，需根据测试结果调优）
- ✅ 明确 MIME 类型检测方式（文件扩展名 + WebP 文件头检测）