# 字符位置文档编辑方案

## 方案概述

使用字符位置实现 AI 文档编辑功能，不考虑用户体验展示，专注于结果准确性。

## 核心设计

### 1. 字符位置定位

**工作原理**：
- 前端将纯文本内容传递给 AI（移除 HTML 标签）
- AI 识别用户意图，计算目标内容的字符位置范围
- AI 在工具调用中指定 `start_char` 和 `end_char`
- 前端直接将字符位置转换为 ProseMirror 文档位置并应用修改

**工具调用格式**：
```json
{
  "name": "edit_current_editor_document",
  "arguments": {
    "content": "完整的新文档内容",
    "start_char": 3872,  // 要修改的起始字符位置
    "end_char": 4496     // 要修改的结束字符位置
  }
}
```

## 大文档处理策略

### 问题分析

**大文档的挑战**：
1. **Token 消耗**：完整文档传递给 AI 会消耗大量 token
2. **上下文限制**：AI 模型有上下文长度限制
3. **计算负担**：AI 需要处理大量内容才能计算字符位置
4. **准确性下降**：内容越多，AI 计算字符位置的准确性可能下降

### 记忆库分块方案

#### 方案设计

**核心思路**：
- 大文档（如 > 10,000 字符）自动分块存储到记忆库
- 每个区块包含：起始字符位置、结束字符位置、内容摘要、关键词
- AI 先读取记忆库，根据用户意图找到目标区块
- 在目标区块内进行精准匹配和修改

#### 工作流程

```
1. 检测文档大小
   ↓
2. 如果 > 阈值，分块存储到记忆库
   ↓
3. AI 接收用户意图
   ↓
4. AI 读取记忆库，找到相关区块
   ↓
5. AI 在目标区块内计算字符位置
   ↓
6. 应用修改
```

#### 分块策略

**分块原则**：
1. **语义完整性**：尽量在段落边界分块
2. **大小均衡**：每个区块 2000-5000 字符（可配置）
3. **重叠区域**：区块之间保留 200-500 字符重叠，避免边界问题
4. **元数据**：每个区块包含起始位置、结束位置、摘要、关键词

**区块结构**：
```rust
pub struct DocumentChunk {
    pub chunk_id: String,
    pub file_path: String,
    pub start_char: usize,      // 起始字符位置
    pub end_char: usize,          // 结束字符位置
    pub content: String,          // 区块内容
    pub summary: String,          // 内容摘要
    pub keywords: Vec<String>,    // 关键词
    pub created_at: DateTime,
    pub updated_at: DateTime,
}
```

#### 区块定位策略

**AI 如何找到目标区块**：

1. **关键词匹配**：
   - AI 从用户意图中提取关键词
   - 在记忆库中搜索包含这些关键词的区块

2. **语义搜索**：
   - 使用向量嵌入进行语义搜索
   - 找到与用户意图最相关的区块

3. **位置提示**：
   - 如果用户提到"开头"、"中间"、"结尾"，可以快速定位

#### 精准匹配流程

**在目标区块内匹配**：

1. **获取区块内容**：
   - 从记忆库读取目标区块的完整内容
   - 获取区块的起始字符位置（用于全局定位）

2. **计算相对位置**：
   - 在区块内计算目标内容的相对字符位置
   - 转换为全局字符位置：`global_start = chunk_start + relative_start`

3. **应用修改**：
   - 使用全局字符位置进行修改
   - 更新记忆库中相关区块的内容

## 方案合理性分析

### ✅ 优点

1. **Token 节省**：
   - 不需要将整个文档传递给 AI
   - 只传递相关区块，大幅减少 token 消耗

2. **准确性提高**：
   - 在较小的区块内计算字符位置，更容易准确
   - 减少 AI 的计算负担

3. **可扩展性**：
   - 支持超大文档（百万字符级别）
   - 不受 AI 上下文长度限制

4. **性能优化**：
   - 只处理相关区块，响应更快
   - 记忆库可以缓存，减少重复计算

### ⚠️ 潜在问题

1. **分块边界问题**：
   - **问题**：如果修改跨越多个区块怎么办？
   - **解决**：
     - 使用重叠区域，确保边界内容不丢失
     - 如果修改跨越区块，合并相关区块进行处理
     - 在工具调用中支持多区块修改

2. **区块定位准确性**：
   - **问题**：AI 如何准确找到目标区块？
   - **解决**：
     - 使用关键词和语义搜索结合
     - 提供区块摘要和关键词，帮助 AI 定位
     - 如果定位失败，回退到全文搜索

3. **记忆库更新**：
   - **问题**：修改后如何更新记忆库？
   - **解决**：
     - 修改后立即更新相关区块
     - 如果修改导致区块大小变化，重新分块
     - 维护区块之间的位置关系

4. **首次分块成本**：
   - **问题**：首次打开大文档需要分块，可能耗时
   - **解决**：
     - 异步分块，不阻塞用户操作
     - 缓存分块结果，避免重复分块
     - 增量更新，只处理变化的部分

5. **字符位置一致性**：
   - **问题**：分块后，全局字符位置如何保持一致？
   - **解决**：
     - 每个区块记录全局起始位置
     - 区块内相对位置 + 区块起始位置 = 全局位置
     - 修改时使用全局位置，确保准确性

## 实施建议

### 阶段一：基础字符位置方案（MVP）

1. **实现字符位置定位**：
   - 前端传递纯文本内容
   - AI 计算并返回字符位置
   - 前端直接使用字符位置匹配

2. **处理小文档**（< 10,000 字符）：
   - 直接传递完整内容
   - 不涉及分块

### 阶段二：记忆库分块方案（增强）

1. **实现分块逻辑**：
   - 检测文档大小
   - 自动分块并存储到记忆库
   - 维护区块元数据

2. **实现区块定位**：
   - AI 读取记忆库
   - 根据用户意图找到目标区块
   - 在区块内计算字符位置

3. **处理跨区块修改**：
   - 检测修改是否跨越区块
   - 合并相关区块进行处理
   - 更新所有相关区块

### 阶段三：优化和容错（高级）

1. **优化区块定位**：
   - 使用向量嵌入进行语义搜索
   - 提高定位准确性

2. **容错机制**：
   - 如果区块定位失败，回退到全文搜索
   - 如果字符位置无效，使用文本匹配

3. **性能优化**：
   - 缓存区块内容
   - 增量更新区块
   - 异步处理大文档

## 结论

### 方案合理性评估

**✅ 方案合理，但需要注意以下问题**：

1. **分块策略**：
   - 必须保证语义完整性（在段落边界分块）
   - 使用重叠区域避免边界问题
   - 维护全局字符位置的一致性

2. **区块定位**：
   - 关键词匹配 + 语义搜索结合
   - 提供足够的元数据帮助 AI 定位
   - 有回退机制（全文搜索）

3. **跨区块处理**：
   - 支持合并多个区块进行处理
   - 修改后正确更新所有相关区块

4. **性能考虑**：
   - 异步分块，不阻塞用户
   - 缓存区块内容
   - 增量更新

### 推荐实施路径

1. **先实现基础字符位置方案**（验证可行性）
2. **再添加记忆库分块支持**（处理大文档）
3. **最后优化和容错**（提高稳定性和性能）

