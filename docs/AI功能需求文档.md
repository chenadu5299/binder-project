# Binder AI 功能需求文档

## 文档信息

- **文档版本**：v1.1
- **创建日期**：2025年
- **最后更新**：2025年（已确认所有待确认问题）
- **文档性质**：**需求锚定文档**（固定不变，技术方案变更不影响此文档）
- **维护原则**：只记录"做什么"和"为什么"，不记录"怎么做"
- **适用范围**：Binder 应用的所有 AI 功能需求

---

## 一、AI 功能架构概述

### 1.1 三层架构设计

Binder 的 AI 功能采用**三层独立架构**，每层有明确的职责和边界，确保功能互不干扰、逻辑清晰、体验流畅。

```
┌─────────────────────────────────────────────────────────┐
│  层次一：自动补全（自动续写）                              │
│  - 无 UI 窗口，幽灵文字显示                                │
│  - 自动触发（光标静止）                                    │
│  - 类似代码补全体验                                        │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  层次二：Inline Assist（Cmd+K 快捷键）                    │
│  - 独立输入框（非聊天窗口）                                 │
│  - 快捷键调出                                              │
│  - 反馈直接修改文本区域                                     │
│  - 无对话历史                                               │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  层次三：右侧聊天窗口                                       │
│  - 完整聊天界面                                             │
│  - 标签栏、记忆库、模型选择                                 │
│  - 对话历史、工具调用                                       │
│  - 可拖拽、可关闭                                           │
└─────────────────────────────────────────────────────────┘
```

### 1.2 架构设计原则

1. **独立性原则**：每层功能独立实现，不相互依赖
2. **清晰性原则**：每层有明确的职责和边界
3. **共享性原则**：共享上下文数据和配置，但不共享实现逻辑
4. **性能原则**：根据层次选择合适的模型和响应方式

---

## 二、层次一：自动补全（自动续写）

### 2.1 功能定位

**核心特性**：
- ✅ **无 UI 窗口**：不占用任何面板空间
- ✅ **自动触发**：用户无需主动调用
- ✅ **幽灵文字**：在光标后方显示半透明的续写内容
- ✅ **非侵入式**：不打断用户写作流程

**类比**：
- 类似 VS Code 的代码补全
- 类似 GitHub Copilot 的代码建议
- 类似 Gmail 的智能撰写

### 2.2 触发机制

**触发条件**：
- 光标在文档中**静止不动**（无输入、无移动）
- 静止时间达到阈值：**7 秒**（可配置，范围 5-15 秒）
- 光标位置有足够的上下文（至少 100 字符）
- 光标位置不是文档末尾（末尾不续写）
- 用户未输入新内容
- 用户未移动光标

**触发逻辑**：
- 监听光标位置变化和输入事件
- 光标静止后开始计时
- 达到阈值后调用 AI 生成续写
- 显示幽灵文字

### 2.3 UI 实现

**幽灵文字显示**：
- 位置：光标正后方
- 样式：半透明灰色文字（opacity: 0.4）
- 字体：与编辑器字体相同
- 长度：建议 20-50 字符（不超过一行）

**交互方式**：
- **Tab 键**：接受补全，插入幽灵文字
- **继续输入**：自动清除幽灵文字
- **Esc 键**：手动清除幽灵文字
- **光标移动**：自动清除幽灵文字

### 2.4 后端实现

**Rust 后端接口**：
- 命令：`ai_autocomplete`
- 参数：`context`（上下文）、`position`（位置）、`max_length`（最大长度）
- 返回：续写内容（可选）

**性能要求**：
- 响应时间：< 2 秒（从触发到显示续写内容）
- 不阻塞编辑器操作
- 使用快速模型（GPT-3.5、Claude Haiku 等）
- 限制生成长度（20-50 字符）
- 防抖机制（7 秒触发一次）

### 2.5 边界和限制

**不共享的内容**：
- ❌ 不共享聊天历史
- ❌ 不共享对话上下文
- ❌ 不显示在聊天窗口中

**共享的内容**：
- ✅ 当前文档内容（作为上下文）
- ✅ 系统提示词（"你是一个写作助手"）
- ✅ AI 模型配置（但优先使用快速模型）

---

## 三、层次二：Inline Assist（Cmd+K 快捷键）

### 3.1 功能定位

**核心特性**：
- ✅ **独立输入框**：不是聊天窗口，是浮动的输入框
- ✅ **快捷键调出**：只能通过 Cmd+K（或 Ctrl+K）激活
- ✅ **直接修改文本**：反馈直接应用到选中的文本区域
- ✅ **无对话历史**：每次调用都是独立的，不保存历史

**类比**：
- 类似 VS Code 的 Quick Fix（Cmd+.）
- 类似 Cursor 的 Cmd+K 功能
- 类似 Notion 的 / 命令

### 3.2 触发机制

**触发条件**：
- 用户**选中文本**（可选，也可以不选）
- 按下 **Cmd+K**（macOS）或 **Ctrl+K**（Windows/Linux）
- 在光标位置或选中文本位置显示输入框

**触发逻辑**：
- 监听 Cmd+K 快捷键
- 获取选中的文本（如果有）
- 显示输入框
- 用户输入指令后执行

### 3.3 UI 实现

**输入框组件**：
- 位置：在选中文本下方或光标位置附近
- 样式：浮动输入框，带边框和阴影
- 内容：单行输入框 + 执行按钮

**Diff 视图（可选）**：
- 如果是指令修改文本，可以显示 Diff 视图
- 红删绿增，对比修改前后
- 用户确认后应用

**交互操作**：
- **Enter 键**：执行指令
- **Esc 键**：取消操作
- **接受修改**：用户确认后应用 AI 建议
- **拒绝修改**：用户取消，不应用建议

### 3.4 后端实现

**Rust 后端接口**：
- 命令：`ai_inline_assist`
- 参数：`instruction`（指令）、`selected_text`（选中文本）、`context`（上下文）
- 返回：修改后的文本

**性能要求**：
- 响应时间：< 5 秒（从提交到显示结果）
- 支持流式显示（逐步显示 AI 生成内容）

### 3.5 边界和限制

**不共享的内容**：
- ❌ 不共享聊天历史
- ❌ 不显示在聊天窗口中
- ❌ 不保存对话记录

**共享的内容**：
- ✅ 当前文档内容（作为上下文）
- ✅ 选中文本（作为输入）
- ✅ 系统提示词
- ✅ AI 模型配置

**与层次一的区别**：
- 层次一：自动触发，续写
- 层次二：手动触发（快捷键），执行指令

**与层次三的区别**：
- 层次二：单次操作，无历史
- 层次三：对话式，有历史

---

## 四、层次三：右侧聊天窗口

### 4.1 功能定位

**核心特性**：
- ✅ **完整聊天界面**：有消息列表、输入框、历史记录
- ✅ **对话式交互**：可以多轮对话，保持上下文
- ✅ **工具调用**：可以操作文档、文件等
- ✅ **标签栏**：支持多个聊天会话
- ✅ **记忆库集成**：可以查看记忆项
- ✅ **模型选择**：可以切换不同的 AI 模型

**类比**：
- 类似 ChatGPT 的聊天界面
- 类似 Cursor 的 AI 聊天面板
- 类似 GitHub Copilot Chat

### 4.2 聊天模式

**Agent 模式**：
- AI 可以调用工具执行操作（文件操作、搜索等）
- 适用于需要 AI 执行实际操作的场景（如创建文件、修改文档、搜索内容等）
- 工具调用过程对用户可见，需要用户确认后执行
- 支持文档修改的可视化展示（红绿标注：删除用红色，添加用绿色）
- 支持多层确认机制：
  - 段落级别确认：每个修改段落有独立的确认按钮
  - 文档级别确认：每个被修改的文档有确认按钮
  - 全部确认：一次性确认所有修改

**Chat 模式**：
- AI 仅进行对话，不调用工具
- 适用于纯对话场景（如咨询问题、获取建议、内容讨论等）
- 不执行任何文件系统操作

**模式切换规则**：
- 创建新对话时可以选择模式（默认 Agent 模式）
- 聊天开始后（已有消息）不能切换模式（保持对话一致性）
- 每个标签页独立设置模式

### 4.3 引用系统功能

**支持引用类型**：
- **文本引用**：复制文档内容，自动识别来源文件和行号
- **文件引用**：拖拽文件到聊天窗口，或使用 `@文件名` 语法
- **文件夹引用**：拖拽文件夹到聊天窗口
- **图片引用**：拖拽图片到聊天窗口
- **表格引用**：选中表格并引用
- **记忆库引用**：使用 `@记忆库名称` 语法
- **聊天记录引用**：引用其他聊天标签页的聊天内容（支持跨标签页引用）
- **链接引用**：自动识别用户输入或复制的 URL
- **知识库引用**：引用知识库内容

**引用功能**：
- 在聊天输入中插入引用标签
- 引用管理器可视化
- 引用分组显示
- 删除引用
- 引用内容完整传递给 AI（不是路径，是完整内容）

**聊天内容引用（重点功能）**：

1. **跨标签页引用**：
   - Agent 模式和 Chat 模式都可以引用其他聊天标签页的内容
   - 支持引用单个消息或多个消息（消息范围）
   - 引用时显示来源标签页标题和消息范围
   - 引用内容完整传递给 AI，作为对话上下文

2. **引用方式**（简化方案）：
   - **复制粘贴引用**：在当前聊天中复制聊天内容，粘贴到其他聊天输入框时，自动识别为引用标签
   - **拖拽引用**：选中消息内容，拖拽到目标聊天输入框
   - **引用管理器**：在引用管理器中浏览所有聊天标签页，选择要引用的消息
   - **注意**：不再使用右键菜单和快捷键引用（避免操作复杂）

3. **引用显示**：
   - 引用标签显示：`💬 聊天记录: [标签页名称] (消息 1-3)`
   - 点击引用标签可查看完整引用内容
   - 引用内容在发送给 AI 时自动格式化

4. **互相引用场景**：
   - **Chat → Agent**：在 Chat 模式中讨论的内容，可以引用到 Agent 模式中执行操作
   - **Agent → Chat**：在 Agent 模式中执行的结果，可以引用到 Chat 模式中继续讨论
   - **Chat → Chat**：不同 Chat 标签页之间互相引用，便于对比和参考
   - **Agent → Agent**：不同 Agent 标签页之间互相引用，便于复用操作结果

5. **引用内容格式化**：
   - 引用时自动包含：标签页标题、消息角色（用户/AI）、消息内容、时间戳
   - **时间戳格式**：`[2025-01-15 14:30] (5 分钟前)`（同时显示绝对时间和相对时间）
   - 如果时间超过 24 小时，只显示绝对时间
   - 格式示例：
     ```
     [聊天记录引用: 需求讨论 (消息 1-3)] [2025-01-15 14:30] (5 分钟前)
     用户: 我需要实现一个登录功能
     AI: 好的，我来帮你设计登录功能的实现方案...
     用户: 需要支持手机号登录
     ```

### 4.4 工具调用功能（仅 Agent 模式）

**文件操作工具**：
- `read_file`：读取文件内容
- `create_file`：创建文件
- `update_file`：更新文件
- `delete_file`：删除文件
- `list_files`：列出目录
- `search_files`：搜索文件
- `move_file`：移动文件
- `rename_file`：重命名
- `create_folder`：创建文件夹

**编辑器操作工具**：
- `edit_current_editor_document`：编辑当前打开的文档（需用户确认）
- 工具调用结果自动应用到编辑器（通过事件通知）

**工具调用特性**：
- 自动执行文件操作（无需确认）
- 编辑器操作需用户确认
- 实时显示工具调用状态（pending/executing/completed/failed）
- JSON 参数修复机制

### 4.4.1 快捷应用到文档功能（Chat 模式重点功能）

**功能定位**：
- Chat 模式中，AI 回答的内容可能包含可以直接应用到文档的内容
- 提供快捷方式，让用户快速将聊天内容应用到当前文档
- 特别适用于：代码片段、文本内容、格式建议等

**快捷处理方式**：

1. **一键应用到文档按钮**：
   - 在 AI 消息下方显示"应用到文档"按钮（仅 Chat 模式）
   - 点击后弹出应用选项：
     - **插入到光标位置**：将内容插入到编辑器光标位置（需要编辑器已打开文档）
     - **替换选中文本**：如果有选中文本，替换为聊天内容（需要编辑器已打开文档）
     - **追加到文档末尾**：将内容追加到文档末尾（需要编辑器已打开文档）
     - **应用到工作区文档**：如果工作区中存在同名文档，直接应用到该文档；如果不存在，创建新文档（不可重复创建）

2. **智能内容识别**：
   - **代码块识别**：使用 Markdown 代码块语法（```语言\n代码\n```）
   - **文本段落识别**：按空行分割，每个段落作为一个可选项
   - **列表识别**：识别 Markdown 列表语法（-、*、1. 等）
   - **展示方式**：在应用预览中，用复选框标记每个可应用的段落，用户可以选择
   - 用户可以选择应用全部内容或部分内容

3. **应用预览**：
   - 应用前显示预览（Diff 视图）
   - 用户可以确认或取消
   - 支持部分应用（选择要应用的段落）
   - **部分应用选择方式**：
     - 预览界面：显示所有可应用段落，用复选框选择
     - 消息中：支持选中文本后右键"应用选中内容"

4. **快捷键支持**：
   - `Cmd/Ctrl + Shift + A`：快速应用当前消息到文档
   - `Cmd/Ctrl + Shift + I`：快速插入到光标位置
   - `Cmd/Ctrl + Shift + T`：快速替换选中文本（修改快捷键，避免与引用冲突）

5. **右键菜单选项**：
   - 在消息上右键，显示"应用到文档"选项
   - 子菜单：
     - 插入到光标位置
     - 替换选中文本
     - 追加到文档末尾
     - 创建新文件

6. **拖拽应用**：
   - 选中聊天消息内容，直接拖拽到编辑器
   - 自动插入到拖拽位置

7. **批量应用**：
   - 支持选择多个消息，批量应用到文档
   - 支持按顺序应用或合并应用
   - **合并应用规则**：
     - 默认方式：保持原有格式，按顺序拼接
     - 提供选项：用户可以选择是否合并为一个段落（用空行分隔）

**应用场景示例**：

1. **代码生成场景**：
   - 用户在 Chat 模式中询问："帮我写一个登录函数"
   - AI 回答包含代码块
   - 用户点击"应用到文档"，代码自动插入到编辑器

2. **文本润色场景**：
   - 用户在 Chat 模式中询问："帮我润色这段文字"
   - AI 回答润色后的文本
   - 用户点击"应用到文档"，替换原文本

3. **格式建议场景**：
   - 用户在 Chat 模式中询问："这段内容应该用什么格式？"
   - AI 回答格式建议和示例
   - 用户点击"应用到文档"，应用格式建议

4. **内容补充场景**：
   - 用户在 Chat 模式中询问："帮我补充这段内容"
   - AI 回答补充内容
   - 用户点击"应用到文档"，追加到文档末尾

**编辑器未打开文档时的处理**：
- 编辑器未打开文档时，"应用到文档"按钮仍然显示
- **应用逻辑**：
  - 如果工作区中存在同名文档，直接应用到该文档（不可重复创建）
  - 如果工作区中不存在同名文档，创建新文档
  - 其他选项（插入、替换、追加）需要编辑器已打开文档才能使用

**编辑器未打开文档时的处理**：
- 编辑器未打开文档时，"应用到文档"按钮仍然显示
- **应用逻辑**：
  - 如果工作区中存在同名文档，直接应用到该文档
  - 如果工作区中不存在同名文档，创建新文档
  - 不可重复创建文档（如果文档已存在，直接应用，不创建新文档）

### 4.5 文档修改可视化功能（仅 Agent 模式）

**可视化展示**：
- 支持文档修改的可视化展示（红绿标注：删除用红色，添加用绿色）
- 支持行级别对比、段落级别对比、文档级别对比
- **在编辑区实现 diff 效果**（重要：Diff 视图应在编辑器中显示，而不是聊天窗口）

**多层确认机制**：
- **段落级别确认**：每个修改段落有独立的确认按钮
- **文档级别确认**：每个被修改的文档有确认按钮
- **全部确认**：一次性确认所有修改
- 支持跳过功能（跳过段落、跳过文档）

### 4.6 多层提示词架构

**提示词层次**：

1. **基础系统提示词**（第一层）：
   - 角色定义："你是一个专业的编程助手和文档编辑助手"
   - 基本行为规范

2. **上下文提示词**（第二层）：
   - 当前打开的文档：文件路径、文档内容预览（智能选择 1000 字符）
   - **文档内容预览选择规则**：
     - 优先选择：光标位置附近的内容（前后各 400 字符）
     - 如果光标位置内容不足，补充文档开头内容
     - 如果文档有标题结构，优先包含当前段落所在章节的内容
   - 当前选中的文本：选中内容
   - 工作区路径：工作区根目录
   - **当前编辑器状态**：包括以下信息
     - 是否可编辑（只读/可编辑）
     - 文件类型（.md、.t-docx、.html 等）
     - 文件大小（如果 > 1MB，提示"大文件"）
     - 是否已保存（如果有未保存更改，提示"有未保存更改"）

3. **引用提示词**（第三层）：
   - 用户引用的内容列表
   - 每个引用的类型、来源、完整内容
   - 明确说明："这些内容已经完整包含在消息中，无需再读取文件"

4. **工具调用提示词**（第四层，仅 Agent 模式）：
   - 工具调用规范：JSON 格式要求
   - 工具使用说明：每个工具的功能和参数
   - 工具调用最佳实践

**提示词构建逻辑**：
- 根据聊天模式（Agent/Chat）动态构建
- 根据是否有引用内容动态添加引用提示词
- 根据当前文档状态动态添加上下文提示词

### 4.7 聊天记录管理

**聊天记录绑定**：
- 聊天记录绑定到工作区（每个工作区独立的聊天记录）
- 支持保存聊天记录到工作区
- 支持加载工作区的聊天记录
- 支持临时聊天（未绑定工作区的聊天，退出时提示保存）
- 支持聊天合并（打开工作区时，可选择合并临时聊天到工作区）

### 4.8 记忆库功能

**记忆库标签**：
- 在标签栏中添加记忆库标签（图标：🧠）
- 点击切换到记忆库面板
- 显示记忆项列表和详情

**记忆库功能**：
- 支持长文档场景的上下文记忆
- 支持记忆库标签（用户可标记重要上下文）
- 支持记忆库检索（AI 可检索相关记忆）

### 4.9 后端实现

**Rust 后端接口**：
- 命令：`ai_chat_stream`
- 参数：
  - `tab_id`（标签页 ID）
  - `messages`（消息列表）
  - `model_config`（模型配置）
  - `enable_tools`（是否启用工具调用）
  - `context`（上下文信息：当前文档、选中文本、工作区路径）
- 返回：流式响应（通过事件 `ai-chat-stream` 发送）

**流式响应处理**：
- 前端和后端双重去重
- 累积文本跟踪
- 空 chunk 过滤
- 工具调用实时处理

### 4.10 性能要求

**响应时间**：
- 首次响应：< 3 秒
- 流式显示延迟：< 100ms
- 工具调用响应：< 2 秒

**资源占用**：
- 内存占用：< 100MB（聊天历史）
- CPU 占用：< 50%（AI 处理）

### 4.11 边界和限制

**共享的内容**：
- ✅ 当前文档内容（作为上下文）
- ✅ 选中文本（可以引用）
- ✅ 系统提示词
- ✅ AI 模型配置
- ✅ 记忆库数据

**不共享的内容**：
- ❌ 不共享自动补全的触发逻辑
- ❌ 不共享 Inline Assist 的输入框

**与层次一、二的区别**：
- 层次一、二：单次操作，无历史
- 层次三：对话式，有完整历史记录

---

**注意**：智能关联修改功能（原层次三）已放弃，不再开发。

---

## 五、三层架构的共享内容

### 6.1 共享的上下文数据

虽然四种功能独立实现，但可以共享以下内容：

1. **当前文档内容**：
   - 自动补全：作为续写上下文
   - Inline Assist：作为指令执行的上下文
   - 聊天窗口：作为对话的上下文

2. **选中文本**：
   - Inline Assist：作为要处理的文本
   - 聊天窗口：可以作为引用内容

3. **系统提示词**：
   - 所有层次都使用相同的系统提示词基础
   - 但可以根据层次调整（自动补全更简洁，聊天更详细）

4. **AI 模型配置**：
   - 所有层次都可以使用相同的模型配置
   - 但自动补全优先使用快速模型

5. **工作区信息**：
   - 聊天窗口：用于工具调用

### 6.2 共享的服务接口

**Rust 后端统一接口**：
- `AIService`：统一的 AI 服务管理
- `APIKeyManager`：统一的 API Key 管理
- `ModelManager`：统一的模型管理（可选，未来实现）

### 6.3 不共享的内容

**严格隔离**：
- ❌ 自动补全的触发逻辑不共享
- ❌ Inline Assist 的输入框不共享
- ❌ 聊天窗口的 UI 组件不共享
- ❌ 聊天历史不共享给其他层次

---

## 六、AI 模型管理

### 7.1 模型提供商支持

**支持的提供商**：
- **OpenAI**：GPT-4、GPT-4 Turbo、GPT-3.5 Turbo 等
- **DeepSeek**：DeepSeek Chat、DeepSeek Coder 等
- **Anthropic**：Claude 3.7 Sonnet、Claude Opus 4 等（未来支持）
- **Google**：Gemini 2.5 Pro 等（未来支持）
- **本地模型**：Ollama、vLLM、LM Studio（未来支持）

**模型选择策略**：
- 自动补全：优先使用快速模型（GPT-3.5、Claude Haiku 等）
- Inline Assist：使用标准模型（GPT-4、Claude Sonnet 等）
- 聊天窗口：用户可选择模型（默认 GPT-4 或 DeepSeek Chat）

### 7.2 模型配置

**配置选项**：
- API Key 配置（用户可配置各提供商的 API Key）
- 模型选择（用户可为不同功能选择不同模型）
- 请求超时配置（默认 60 秒，用户可配置）
- 温度参数配置（默认 0.7，用户可配置）
- 最大 Token 配置（默认 4096，用户可配置）

**API Key 安全存储**：
- 加密存储，不记录日志
- 支持密钥链存储（macOS Keychain、Windows Credential Manager）
- 支持环境变量配置（开发环境）

### 7.3 AI 请求管理

**请求队列**：
- 支持请求队列（管理多个 AI 请求）
- 支持请求优先级：
  - 自动补全：低优先级
  - Inline Assist：高优先级
  - 聊天：标准优先级
- 支持请求取消（用户可取消正在进行的请求）
- **请求重试机制**：
  - 支持请求重试（失败时自动重试，最多 3 次，指数退避）
  - **需要重试的错误**：网络错误、超时错误、5xx 服务器错误
  - **不需要重试的错误**：4xx 客户端错误（如：API Key 无效）、用户取消
  - **重试提示**：静默重试，不提示用户（避免打扰）
  - **重试失败**：显示错误提示，提供"手动重试"按钮

---

## 七、性能需求

### 8.1 响应性能

**自动补全**：
- 响应时间：< 2 秒（从触发到显示续写内容）
- 不阻塞编辑器操作

**Inline Assist**：
- 响应时间：< 5 秒（从提交到显示结果）
- 支持流式显示（逐步显示 AI 生成内容）

**聊天窗口**：
- 首次响应：< 3 秒
- 流式显示延迟：< 100ms
- 工具调用响应：< 2 秒

### 8.2 资源占用

**内存占用**：
- 基础应用内存占用：< 100MB
- 每个功能独立计算，但共享一些基础资源（如 AI 服务）
- 自动补全：< 10MB
- Inline Assist：< 20MB
- 聊天窗口：< 100MB（聊天历史）
- **总内存占用上限**：< 500MB（所有功能同时使用）
- 如果超过上限，使用 LRU 缓存策略释放不常用的资源

**CPU 占用**：
- 空闲时 CPU 占用：< 5%
- AI 处理时 CPU 占用：< 50%

### 8.3 并发处理

**并发能力**：
- 支持多个 AI 请求并发处理（请求队列管理）
- 支持不同层次的 AI 功能同时使用（不相互阻塞）
- 支持文件操作和 AI 处理并发

**并发控制**：
- AI 请求队列管理（按优先级处理）
- **功能优先级顺序**（从高到低）：
  1. Inline Assist（用户主动触发）
  2. 聊天窗口（用户发送消息）
  3. 自动补全（自动触发，最低优先级）
- **互斥规则**：
  - 自动补全可以被其他所有功能中断
  - 聊天窗口独立运行，不与其他功能冲突
- 自动补全请求可被其他高优先级请求中断

**用户快速连续操作时的处理**：
- **快速输入**：自动补全自动取消，重新计时
- **切换标签页**：正在进行的 AI 请求继续执行，但结果不显示（静默完成）
- **关闭标签页**：正在进行的 AI 请求取消，显示提示"请求已取消"

---

## 八、用户体验需求

### 9.1 界面设计原则

**设计原则**：
- 简洁清晰：界面简洁，信息清晰
- 一致性：界面元素和交互保持一致
- 反馈及时：操作有及时反馈
- 错误友好：错误信息清晰，提供解决建议

### 9.2 交互设计原则

**交互原则**：
- 符合用户习惯：操作符合常见软件的使用习惯
- 操作流畅：操作响应及时，无卡顿感
- 操作可逆：支持撤销操作，减少误操作风险
- 操作确认：危险操作需要用户确认（如批量修改）

### 9.3 反馈机制

**操作反馈**：
- 所有操作都有明确的反馈（成功、失败、进行中）
- 长时间操作显示进度提示
- 操作完成时显示成功提示（Toast 通知）

**状态反馈**：
- AI 处理状态清晰显示（处理中、完成、错误）
- 工具调用状态清晰显示（pending/executing/completed/failed）

### 9.4 帮助和引导

**帮助信息**：
- 提供操作提示和帮助信息
- 提供快捷键列表（用户可查看）
- 提供常见问题解答（FAQ）

**新手引导**（可选）：
- 首次使用时提供功能引导
- 关键功能提供使用提示

---

## 九、需求优先级

### 10.1 优先级分类

**P0（必须实现）**：
- 层次一：自动补全（自动续写）
- 层次二：Inline Assist（Cmd+K 快捷键）
- 层次三：右侧聊天窗口（基础功能）
- AI 模型管理（API Key 配置、模型选择）
- 引用系统（文本引用、文件引用、聊天记录引用）
- 工具调用（文件操作、编辑器操作）
- 文档修改可视化（Diff 视图、多层确认）
- **聊天内容引用**（跨标签页引用，Agent 和 Chat 模式互相引用）
- **快捷应用到文档**（Chat 模式，一键应用聊天内容到文档）

**P1（重要功能）**：
- 引用系统（完整功能：文件夹、图片、链接等）
- 记忆库功能
- 聊天记录管理
- 多层提示词架构
- 快捷应用到文档（完整功能：拖拽、批量应用等）

**P2（增强功能）**：
- AI 图片生成
- 本地模型支持
- 高级搜索选项（正则表达式）
- 聊天内容智能识别（自动识别可应用的内容）

### 10.2 MVP 1.0 范围

**MVP 1.0 包含**：
- 所有 P0 功能（包括聊天内容引用和快捷应用到文档）
- 部分 P1 功能：
  - 引用系统（文本引用、文件引用、文件夹引用、聊天记录引用）
  - 文档修改可视化（Diff 视图、多层确认）
  - 多层提示词架构（基础版本）
  - 快捷应用到文档（基础功能：一键应用、插入/替换）

**MVP 1.0 不包含**：
- 记忆库功能（移至后续版本）
- AI 图片生成（P2 功能）
- 本地模型支持（P2 功能）
- 快捷应用到文档（高级功能：拖拽、批量应用、智能识别）

**成本控制说明**：
- MVP 1.0 阶段以实现功能为主，不限制用户调用次数
- 成本控制应在用户管理系统层面统一处理（如：Token 限额、使用量统计、订阅管理等）
- 功能层面不实现成本控制逻辑

---

## 十、需求变更管理

### 11.1 变更原则

**变更原则**：
- 需求文档作为锚定文档，变更需要谨慎
- 只记录"做什么"和"为什么"，不记录"怎么做"
- 技术方案变更不影响需求文档
- 功能需求变更需要经过评审

### 11.2 变更流程

**变更流程**：
1. 提出变更需求（说明变更原因和影响）
2. 需求评审（评估变更的必要性和影响）
3. 更新需求文档（记录变更内容和原因）
4. 通知相关团队（通知开发、测试、设计等团队）

### 11.3 版本管理

**版本管理**：
- 需求文档版本号：v1.0, v1.1, v2.0 等
- 重大变更升级主版本号（v1.0 → v2.0）
- 功能增加升级次版本号（v1.0 → v1.1）
- 错误修正升级修订版本号（v1.0.0 → v1.0.1）

---

## 十一、术语表

### 12.1 功能术语

**自动补全（Auto-Complete）**：
- AI 功能三层架构的第一层
- 光标静止后自动显示续写建议

**Inline Assist**：
- AI 功能三层架构的第二层
- 快捷键触发，在光标位置弹出输入框进行 AI 辅助

**聊天窗口（Chat Window）**：
- AI 功能三层架构的第三层
- 独立的聊天界面，支持多标签页和工具调用

**Agent 模式（Agent Mode）**：
- 聊天窗口的一种工作模式
- AI 可以调用工具执行操作（文件操作、搜索等）
- 适用于需要 AI 执行实际操作的场景

**Chat 模式（Chat Mode）**：
- 聊天窗口的一种工作模式
- AI 仅进行对话，不调用工具
- 适用于纯对话场景

**引用系统（Reference System）**：
- 聊天窗口中引用多种资源的功能
- 支持文本引用、文件引用、记忆库引用、链接引用等

**文档修改可视化（Document Modification Visualization）**：
- AI 修改文档时的可视化展示
- 使用红绿标注显示修改内容（删除用红色，添加用绿色）

**多层确认机制（Multi-Level Confirmation）**：
- 文档修改的确认机制
- 支持段落级别、文档级别、全部确认三个层级

**多层提示词架构（Multi-Layer Prompt Architecture）**：
- AI 提示词的分层设计
- 包括基础系统提示词、上下文提示词、引用提示词、工具调用提示词

### 12.2 技术术语（仅用于理解需求）

**API Key**：
- 访问 AI 服务的密钥
- 需要用户配置，加密存储

**流式响应（Streaming Response）**：
- AI 响应逐步返回，而不是一次性返回
- 提供更好的用户体验

**工具调用（Tool Calling）**：
- AI 调用外部工具执行操作
- 如文件操作、搜索等

---

## 十二、附录

### 13.1 相关文档

**产品文档**：
- `Binder产品需求文档.md`：产品整体需求文档
- `AI功能三层架构设计.md`：AI 功能架构设计文档（技术实现细节）

**开发文档**：
- 各功能模块的开发计划文档
- API 文档
- 架构文档

### 13.2 需求来源

**需求来源**：
- 产品定位和核心价值主张
- 目标用户的使用场景
- 竞品分析和市场调研（Cursor、GitHub Copilot、VS Code 等）
- 技术可行性分析
- 用户反馈（未来）

### 13.3 需求文档维护

**维护责任**：
- 产品经理负责需求文档的维护和更新
- 开发团队、测试团队、设计团队参与需求评审

**更新频率**：
- 重大需求变更时更新
- 版本发布前检查需求覆盖度
- 定期回顾和优化需求

---

## 文档结束

**文档版本**：v1.2

**创建日期**：2025年

**最后更新**：2025年（移除智能关联修改功能）

**维护者**：Binder 产品团队

**文档性质**：需求锚定文档（固定不变，技术方案变更不影响此文档）

**更新说明**：
- v1.2：移除智能关联修改功能（原层次三），改为三层架构
  - 移除智能关联修改相关需求
  - 将原"层次四"（右侧聊天窗口）调整为"层次三"
  - 更新架构描述和术语表
- v1.1：根据待确认问题清单，明确了所有模糊不清的功能需求
  - 快捷应用到文档：明确了智能识别规则、部分应用方式、合并规则、边界情况
  - 聊天内容引用：简化为复制粘贴方案
  - 多层提示词架构：明确了文档预览选择规则、编辑器状态信息
  - 性能要求：明确了大小工作区性能要求、内存占用计算方式
  - 边界情况：明确了功能优先级、快速操作处理、快捷键冲突处理、错误重试机制

---

**重要说明**：

1. **本文档是需求锚定文档**，只记录"做什么"和"为什么"，不记录"怎么做"
2. **技术方案变更不影响此文档**，技术实现细节请参考技术方案文档
3. **需求变更需要经过评审**，重大变更需要更新文档版本号
4. **所有功能需求都应该可验证**，有明确的验证标准
5. **需求优先级明确**，P0 需求必须全部实现，P1/P2 需求根据版本规划实现

