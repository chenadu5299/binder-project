# AI æµå¼å“åº”é‡å¤å†…å®¹é—®é¢˜å®Œæ•´è§£å†³æ–¹æ¡ˆ

## é—®é¢˜æè¿°

åœ¨ä½¿ç”¨ DeepSeek API è¿›è¡Œæµå¼å“åº”æ—¶ï¼Œå‡ºç°ä»¥ä¸‹é—®é¢˜ï¼š
1. **æ–‡æœ¬é‡å¤**ï¼šAI è¿”å›çš„å†…å®¹å‡ºç°é‡å¤å­—è¯ã€è¯­å¥ä¸é€šé¡º
2. **æµå¼æ‹¼æ¥é”™è¯¯**ï¼šå¢é‡å†…å®¹ï¼ˆdeltaï¼‰è¢«é‡å¤è¿½åŠ æˆ–é”™è¯¯åˆå¹¶
3. **å·¥å…·è°ƒç”¨ JSON è§£æå¤±è´¥**ï¼šå·¥å…·è°ƒç”¨çš„ arguments å‚æ•°æ ¼å¼ä¸æ ‡å‡†ï¼Œå¯¼è‡´è§£æå¤±è´¥

## æ ¹æœ¬åŸå› åˆ†æ

### 1. æµå¼ä¼ è¾“çš„æœ¬è´¨é—®é¢˜

**SSE (Server-Sent Events) æµå¼ä¼ è¾“çš„ç‰¹ç‚¹ï¼š**
- API è¿”å›çš„æ˜¯**å¢é‡æ•°æ®**ï¼ˆdeltaï¼‰ï¼Œä¸æ˜¯å®Œæ•´æ–‡æœ¬
- ä¸€ä¸ª HTTP chunk å¯èƒ½åŒ…å«å¤šä¸ª SSE è¡Œ
- ç½‘ç»œä¼ è¾“å¯èƒ½å¯¼è‡´æ•°æ®åˆ†ç‰‡ï¼Œä¸€ä¸ªå®Œæ•´çš„ SSE è¡Œå¯èƒ½è¢«åˆ†å‰²åˆ°å¤šä¸ª bytes chunk ä¸­

**å¸¸è§é”™è¯¯å¤„ç†æ–¹å¼ï¼š**
```rust
// âŒ é”™è¯¯ï¼šç›´æ¥è¿½åŠ æ¯ä¸ª deltaï¼Œæ²¡æœ‰å»é‡
accumulated_text += delta;
```

### 2. DeepSeek API çš„ç‰¹æ®Šæ€§

æ ¹æ®å®é™…æµ‹è¯•å’Œå‚è€ƒ void/Cursor çš„å®ç°ï¼ŒDeepSeek åœ¨æµå¼è¾“å‡ºæ—¶ï¼š
- å¯èƒ½å‘é€**é‡å¤çš„ content delta**ï¼ˆç‰¹åˆ«æ˜¯ç½‘ç»œä¸ç¨³å®šæ—¶ï¼‰
- å·¥å…·è°ƒç”¨çš„ `arguments` å¯èƒ½**è·¨å¤šä¸ª SSE è¡Œ**ï¼Œéœ€è¦ç´¯ç§¯
- æŸäº›æƒ…å†µä¸‹ï¼ŒåŒä¸€ä¸ª content å¯èƒ½è¢«å‘é€å¤šæ¬¡

### 3. å‰ç«¯/åç«¯é‡å¤å¤„ç†

**é—®é¢˜åœºæ™¯ï¼š**
1. åç«¯æ”¶åˆ°é‡å¤çš„ deltaï¼Œæ²¡æœ‰è¿‡æ»¤
2. åç«¯å‘é€ç»™å‰ç«¯æ—¶ï¼Œåˆé‡å¤å‘é€
3. å‰ç«¯æ”¶åˆ°åï¼Œå†æ¬¡è¿½åŠ åˆ°æ¶ˆæ¯ä¸­

## å®Œæ•´è§£å†³æ–¹æ¡ˆï¼ˆå‚è€ƒ void/Cursor å®ç°ï¼‰

### æ–¹æ¡ˆæ¶æ„

```
API å“åº” (SSE Stream)
    â†“
åç«¯æµå¼å¤„ç†å±‚ï¼ˆRustï¼‰
    â”œâ”€ ç¼“å†²åŒºç®¡ç†ï¼ˆå¤„ç†è·¨ chunk çš„ SSE è¡Œï¼‰
    â”œâ”€ é‡å¤å†…å®¹æ£€æµ‹ï¼ˆåŸºäºç´¯ç§¯æ–‡æœ¬ï¼‰
    â”œâ”€ å·¥å…·è°ƒç”¨ç´¯ç§¯ï¼ˆè·¨è¡Œ JSON åˆå¹¶ï¼‰
    â””â”€ å¢é‡æ–‡æœ¬æå–ï¼ˆåªå‘é€æ–°å¢éƒ¨åˆ†ï¼‰
    â†“
Tauri IPC äº‹ä»¶
    â†“
å‰ç«¯äº‹ä»¶å¤„ç†å±‚ï¼ˆTypeScriptï¼‰
    â”œâ”€ ç©ºäº‹ä»¶è¿‡æ»¤
    â”œâ”€ é‡å¤ chunk æ£€æµ‹
    â””â”€ çŠ¶æ€æ›´æ–°ï¼ˆé¿å…é‡å¤æ¸²æŸ“ï¼‰
```

### ç¬¬ä¸€éƒ¨åˆ†ï¼šåç«¯æµå¼å¤„ç†ä¼˜åŒ–

#### 1.1 æ”¹è¿›çš„ SSE è¡Œç¼“å†²æœºåˆ¶

**å…³é”®ç‚¹ï¼š** ä¸€ä¸ª bytes chunk å¯èƒ½åŒ…å«å¤šä¸ª SSE è¡Œï¼Œä¹Ÿå¯èƒ½åªåŒ…å«éƒ¨åˆ† SSE è¡Œã€‚

```rust
// src-tauri/src/services/ai_providers/deepseek.rs

use std::sync::{Arc, Mutex};

struct StreamState {
    buffer: String,              // æœªå®Œæˆçš„ SSE è¡Œ
    accumulated_text: String,   // ç´¯ç§¯çš„å®Œæ•´æ–‡æœ¬ï¼ˆç”¨äºå»é‡ï¼‰
    tool_call_state: (Option<String>, Option<String>, String), // (id, name, arguments)
}

impl StreamState {
    fn new() -> Self {
        Self {
            buffer: String::new(),
            accumulated_text: String::new(),
            tool_call_state: (None, None, String::new()),
        }
    }
    
    // å¤„ç†æ–°çš„ bytes chunk
    fn process_chunk(&mut self, bytes: Vec<u8>) -> Vec<ChatChunk> {
        let text = String::from_utf8_lossy(&bytes).to_string();
        self.buffer.push_str(&text);
        
        let mut chunks = Vec::new();
        let mut lines: Vec<&str> = self.buffer.lines().collect();
        
        // å¦‚æœ buffer ä¸ä»¥æ¢è¡Œç¬¦ç»“å°¾ï¼Œä¿ç•™æœ€åä¸€è¡Œ
        let incomplete_line = if !self.buffer.ends_with('\n') && !self.buffer.ends_with('\r') {
            lines.pop().map(|s| s.to_string())
        } else {
            None
        };
        
        // å¤„ç†å®Œæ•´çš„ SSE è¡Œ
        for line in lines {
            if let Some(chunk) = self.process_sse_line(line.trim()) {
                chunks.push(chunk);
            }
        }
        
        // æ›´æ–° buffer
        self.buffer = incomplete_line.unwrap_or_default();
        
        chunks
    }
    
    // å¤„ç†å•ä¸ª SSE è¡Œ
    fn process_sse_line(&mut self, line: &str) -> Option<ChatChunk> {
        if line.is_empty() || !line.starts_with("data: ") {
            return None;
        }
        
        let json_str = &line[6..]; // ç§»é™¤ "data: " å‰ç¼€
        
        if json_str == "[DONE]" {
            // å¤„ç†æœªå®Œæˆçš„å·¥å…·è°ƒç”¨
            return self.finalize_tool_call();
        }
        
        // è§£æ JSON
        match serde_json::from_str::<ChatCompletionResponse>(json_str) {
            Ok(response) => {
                if let Some(choice) = response.choices.first() {
                    // å¤„ç†å·¥å…·è°ƒç”¨
                    if let Some(delta) = &choice.delta {
                        if let Some(tool_calls) = &delta.tool_calls {
                            return self.process_tool_call_delta(tool_calls);
                        }
                        
                        // å¤„ç†æ–‡æœ¬å†…å®¹
                        if let Some(content) = &delta.content {
                            return self.process_content_delta(content);
                        }
                    }
                    
                    // å¤„ç†å®ŒæˆåŸå› 
                    if let Some(finish_reason) = &choice.finish_reason {
                        if finish_reason == "tool_calls" {
                            return self.finalize_tool_call();
                        }
                    }
                }
            }
            Err(e) => {
                eprintln!("âš ï¸ JSON è§£æå¤±è´¥: {} - å†…å®¹: {}", e, json_str);
            }
        }
        
        None
    }
    
    // å¤„ç†æ–‡æœ¬å†…å®¹ deltaï¼ˆå…³é”®ï¼šå»é‡é€»è¾‘ï¼‰
    fn process_content_delta(&mut self, content: &str) -> Option<ChatChunk> {
        if content.is_empty() {
            return None;
        }
        
        // å…³é”®å»é‡é€»è¾‘ï¼šæ£€æŸ¥æ–°å†…å®¹æ˜¯å¦å·²ç»å­˜åœ¨äºç´¯ç§¯æ–‡æœ¬çš„æœ«å°¾
        // è¿™æ˜¯ void/Cursor ä½¿ç”¨çš„æ ‡å‡†æ–¹æ³•
        if self.accumulated_text.ends_with(content) {
            eprintln!("âš ï¸ æ£€æµ‹åˆ°é‡å¤çš„ content deltaï¼Œè·³è¿‡: '{}'", 
                if content.len() > 50 { &content[..50] } else { content });
            return None;
        }
        
        // è®¡ç®—æ–°å¢éƒ¨åˆ†ï¼ˆé¿å…é‡å¤ï¼‰
        // å¦‚æœ content æ˜¯ç´¯ç§¯æ–‡æœ¬çš„ä¸€éƒ¨åˆ†ï¼Œåªå–æ–°å¢éƒ¨åˆ†
        let new_content = if self.accumulated_text.ends_with(&content[..content.len().min(self.accumulated_text.len())]) {
            // å®Œå…¨é‡å¤ï¼Œè·³è¿‡
            return None;
        } else {
            // æ£€æŸ¥æ˜¯å¦æœ‰éƒ¨åˆ†é‡å 
            let overlap_len = self.find_overlap(&self.accumulated_text, content);
            if overlap_len > 0 && overlap_len < content.len() {
                &content[overlap_len..]
            } else {
                content
            }
        };
        
        // æ›´æ–°ç´¯ç§¯æ–‡æœ¬
        self.accumulated_text.push_str(new_content);
        
        Some(ChatChunk::Text(new_content.to_string()))
    }
    
    // æŸ¥æ‰¾ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é‡å éƒ¨åˆ†é•¿åº¦
    fn find_overlap(&self, text: &str, new: &str) -> usize {
        let max_overlap = text.len().min(new.len());
        for i in (1..=max_overlap).rev() {
            if text.ends_with(&new[..i]) {
                return i;
            }
        }
        0
    }
    
    // å¤„ç†å·¥å…·è°ƒç”¨ delta
    fn process_tool_call_delta(&mut self, tool_calls: &[ToolCallDelta]) -> Option<ChatChunk> {
        for delta in tool_calls {
            if let Some(id) = &delta.id {
                self.tool_call_state.0 = Some(id.clone());
            }
            if let Some(function) = &delta.function {
                if let Some(name) = &function.name {
                    self.tool_call_state.1 = Some(name.clone());
                }
                if let Some(arguments) = &function.arguments {
                    self.tool_call_state.2.push_str(arguments);
                }
            }
        }
        
        // æ£€æŸ¥å·¥å…·è°ƒç”¨æ˜¯å¦å®Œæˆï¼ˆJSON å®Œæ•´ä¸”æœ‰æ•ˆï¼‰
        if let (Some(ref id), Some(ref name)) = (&self.tool_call_state.0, &self.tool_call_state.1) {
            let args_str = &self.tool_call_state.2;
            if !args_str.is_empty() {
                // å°è¯•è§£æ JSONï¼Œå¦‚æœæˆåŠŸåˆ™è®¤ä¸ºå®Œæˆ
                if let Ok(_) = serde_json::from_str::<serde_json::Value>(args_str) {
                    let id_clone = id.clone();
                    let name_clone = name.clone();
                    let args_clone = args_str.clone();
                    
                    // é‡ç½®çŠ¶æ€
                    self.tool_call_state = (None, None, String::new());
                    
                    return Some(ChatChunk::ToolCall {
                        id: id_clone,
                        name: name_clone,
                        arguments: args_clone,
                        is_complete: true,
                    });
                } else {
                    // æœªå®Œæˆï¼Œè¿”å›å¢é‡æ›´æ–°
                    return Some(ChatChunk::ToolCall {
                        id: id.clone(),
                        name: name.clone(),
                        arguments: args_str.clone(),
                        is_complete: false,
                    });
                }
            }
        }
        
        None
    }
    
    // å®Œæˆå·¥å…·è°ƒç”¨
    fn finalize_tool_call(&mut self) -> Option<ChatChunk> {
        if let (Some(ref id), Some(ref name)) = (&self.tool_call_state.0, &self.tool_call_state.1) {
            if !self.tool_call_state.2.is_empty() {
                let id_clone = id.clone();
                let name_clone = name.clone();
                let args_clone = self.tool_call_state.2.clone();
                
                self.tool_call_state = (None, None, String::new());
                
                return Some(ChatChunk::ToolCall {
                    id: id_clone,
                    name: name_clone,
                    arguments: args_clone,
                    is_complete: true,
                });
            }
        }
        None
    }
}
```

#### 1.2 æ”¹è¿›çš„æµå¼å¤„ç†ä¸»å¾ªç¯

```rust
// src-tauri/src/services/ai_providers/deepseek.rs

async fn chat_stream(
    &self,
    messages: &[ChatMessage],
    model_config: &ModelConfig,
    _cancel_rx: &mut tokio::sync::oneshot::Receiver<()>,
    tools: Option<&[ToolDefinition]>,
) -> Result<Box<dyn tokio_stream::Stream<Item = Result<ChatChunk, AIError>> + Send + Unpin>, AIError> {
    // ... æ„å»ºè¯·æ±‚ ...
    
    let response = // ... å‘é€è¯·æ±‚ ...
    
    let stream_state = Arc::new(Mutex::new(StreamState::new()));
    
    let stream = response.bytes_stream().map(move |result| {
        let state = stream_state.clone();
        
        match result {
            Ok(bytes) => {
                let mut state_guard = state.lock().unwrap();
                let chunks = state_guard.process_chunk(bytes.to_vec());
                
                // åªè¿”å›ç¬¬ä¸€ä¸ªæœ‰æ•ˆçš„ chunkï¼ˆé¿å…é‡å¤ï¼‰
                if let Some(chunk) = chunks.first() {
                    Ok(chunk.clone())
                } else {
                    Ok(ChatChunk::Text(String::new())) // ç©º chunkï¼Œå‰ç«¯ä¼šè¿‡æ»¤
                }
            }
            Err(e) => Err(AIError::NetworkError(e.to_string())),
        }
    });
    
    Ok(Box::new(stream))
}
```

### ç¬¬äºŒéƒ¨åˆ†ï¼šåç«¯äº‹ä»¶å‘é€ä¼˜åŒ–

#### 2.1 äºŒæ¬¡å»é‡æ£€æµ‹

åœ¨ `ai_commands.rs` ä¸­ï¼Œåœ¨å‘é€ç»™å‰ç«¯ä¹‹å‰å†æ¬¡æ£€æµ‹é‡å¤ï¼š

```rust
// src-tauri/src/commands/ai_commands.rs

tokio::spawn(async move {
    use tokio_stream::StreamExt;
    
    let mut accumulated_text = String::new(); // åç«¯ç´¯ç§¯æ–‡æœ¬ï¼ˆäºŒæ¬¡å»é‡ï¼‰
    
    while let Some(result) = stream.next().await {
        match result {
            Ok(chunk) => {
                match chunk {
                    ChatChunk::Text(text) => {
                        if !text.is_empty() {
                            // äºŒæ¬¡å»é‡ï¼šæ£€æŸ¥æ˜¯å¦ä¸ç´¯ç§¯æ–‡æœ¬é‡å¤
                            if accumulated_text.ends_with(&text) {
                                eprintln!("âš ï¸ åç«¯äºŒæ¬¡æ£€æµ‹åˆ°é‡å¤æ–‡æœ¬ï¼Œè·³è¿‡: '{}'", 
                                    if text.len() > 50 { &text[..50] } else { &text });
                                continue;
                            }
                            
                            accumulated_text.push_str(&text);
                            
                            // å‘é€ç»™å‰ç«¯
                            let payload = serde_json::json!({
                                "tab_id": tab_id,
                                "chunk": text,
                            // å‘é€ç»™å‰ç«¯
                            let payload = serde_json::json!({
                                "tab_id": tab_id,
                                "chunk": text,
                                "done": false,
                            });
                            if let Err(e) = app_handle.emit("ai-chat-stream", payload) {
                                eprintln!("å‘é€äº‹ä»¶å¤±è´¥: {}", e);
                            }
                        }
                        ChatChunk::ToolCall { id, name, arguments, is_complete } => {
                            // å·¥å…·è°ƒç”¨å¤„ç†é€»è¾‘ï¼ˆè§ä¸‹æ–‡ï¼‰
                        }
                    }
                }
                Err(e) => {
                    // é”™è¯¯å¤„ç†
                    eprintln!("æµå¼å“åº”é”™è¯¯: {}", e);
                }
            }
        }
        
        // æµç»“æŸï¼Œå‘é€å®Œæˆäº‹ä»¶
        let payload = serde_json::json!({
            "tab_id": tab_id,
            "chunk": "",
            "done": true,
        });
        app_handle.emit("ai-chat-stream", payload).ok();
    });
}
```

#### 2.2 å·¥å…·è°ƒç”¨äº‹ä»¶å‘é€

```rust
// src-tauri/src/commands/ai_commands.rs

ChatChunk::ToolCall { id, name, arguments, is_complete } => {
    eprintln!("ğŸ”§ æ”¶åˆ°å·¥å…·è°ƒç”¨: id={}, name={}, is_complete={}", id, name, is_complete);
    
    // è§£æå·¥å…·è°ƒç”¨å‚æ•°ï¼ˆå°è¯•ä¿®å¤ä¸å®Œæ•´çš„ JSONï¼‰
    let parsed_arguments = match serde_json::from_str::<serde_json::Value>(&arguments) {
        Ok(args) => args,
        Err(_) => {
            // JSON ä¸å®Œæ•´ï¼Œå°è¯•ä¿®å¤ï¼ˆæ·»åŠ é—­åˆæ‹¬å·ç­‰ï¼‰
            let mut repaired = arguments.clone();
            if !repaired.trim().ends_with('}') {
                // è®¡ç®—ç¼ºå¤±çš„é—­åˆæ‹¬å·
                let open_braces = repaired.matches('{').count();
                let close_braces = repaired.matches('}').count();
                let missing = open_braces - close_braces;
                for _ in 0..missing {
                    repaired.push('}');
                }
            }
            
            // å†æ¬¡å°è¯•è§£æ
            serde_json::from_str::<serde_json::Value>(&repaired)
                .unwrap_or_else(|_| serde_json::json!({}))
        }
    };
    
    // å‘é€å·¥å…·è°ƒç”¨äº‹ä»¶åˆ°å‰ç«¯
    let payload = serde_json::json!({
        "tab_id": tab_id,
        "chunk": "",
        "done": false,
        "tool_call": {
            "id": id,
            "name": name,
            "arguments": parsed_arguments,
            "status": if is_complete { "executing" } else { "pending" },
        },
    });
    
    if let Err(e) = app_handle.emit("ai-chat-stream", payload) {
        eprintln!("å‘é€å·¥å…·è°ƒç”¨äº‹ä»¶å¤±è´¥: {}", e);
    }
    
    // å¦‚æœå·¥å…·è°ƒç”¨å®Œæˆï¼Œç«‹å³æ‰§è¡Œï¼ˆå¯¹äºä¸éœ€è¦ç¡®è®¤çš„å·¥å…·ï¼‰
    if is_complete {
        // æ‰§è¡Œå·¥å…·è°ƒç”¨é€»è¾‘ï¼ˆè§ä¸‹æ–‡ï¼‰
    }
}
```

### ç¬¬ä¸‰éƒ¨åˆ†ï¼šå‰ç«¯å¤„ç†ä¼˜åŒ–

#### 3.1 ç©ºäº‹ä»¶è¿‡æ»¤ï¼ˆå·²å®ç°ï¼‰

```typescript
// src/components/Chat/ChatPanel.tsx

const chunk = (payload.chunk || '').toString();
const isEmptyChunk = !payload.tool_call && chunk.length === 0 && !payload.done && !payload.error;

if (isEmptyChunk) {
    // è·³è¿‡ç©º chunkï¼Œä¸è®°å½•æ—¥å¿—ï¼Œé¿å…æ—¥å¿—æ±¡æŸ“
    return;
}
```

#### 3.2 é‡å¤å†…å®¹æ£€æµ‹ï¼ˆå‰ç«¯äºŒæ¬¡é˜²æŠ¤ï¼‰

```typescript
// src/components/Chat/ChatPanel.tsx

// åœ¨ç»„ä»¶çº§åˆ«ç»´æŠ¤ç´¯ç§¯æ–‡æœ¬ï¼ˆç”¨äºå‰ç«¯äºŒæ¬¡å»é‡ï¼‰
const accumulatedTextRef = useRef<Map<string, string>>(new Map());

// åœ¨äº‹ä»¶å¤„ç†ä¸­
if (!payload.tool_call && lastMessage && lastMessage.role === 'assistant') {
    const tabId = payload.tab_id;
    const accumulated = accumulatedTextRef.current.get(tabId) || '';
    
    // æ£€æŸ¥æ˜¯å¦é‡å¤
    if (accumulated.endsWith(chunk)) {
        console.warn('âš ï¸ å‰ç«¯æ£€æµ‹åˆ°é‡å¤ chunkï¼Œè·³è¿‡:', chunk.substring(0, 50));
        return;
    }
    
    // æ›´æ–°ç´¯ç§¯æ–‡æœ¬
    accumulatedTextRef.current.set(tabId, accumulated + chunk);
    
    // è¿½åŠ åˆ°æ¶ˆæ¯
    appendToMessage(payload.tab_id, lastMessage.id, chunk);
}
```

#### 3.3 å·¥å…·è°ƒç”¨ JSON ä¿®å¤

```typescript
// src/utils/jsonRepair.ts

/**
 * å¢å¼ºå‹ JSON ä¿®å¤å·¥å…·
 * ä¸“é—¨å¤„ç† AI æ¨¡å‹ï¼ˆç‰¹åˆ«æ˜¯ DeepSeekï¼‰è¿”å›çš„ç•¸å½¢ JSON
 */
export function aggressiveJSONRepair(brokenJson: string): any | null {
    if (!brokenJson || typeof brokenJson !== 'string') {
        return null;
    }

    let repaired = brokenJson.trim();

    // 1. ç¡®ä¿ä»¥ { å¼€å¤´
    if (!repaired.startsWith('{')) {
        repaired = '{' + repaired;
    }

    // 2. ä¿®å¤é”®åç¼ºå°‘å¼•å·çš„é—®é¢˜
    repaired = repaired.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');

    // 3. ä¿®å¤å€¼ç¼ºå°‘å¼•å·çš„é—®é¢˜ï¼ˆå­—ç¬¦ä¸²å€¼ï¼‰
    repaired = repaired.replace(/:\s*([^",\[\]{}]+?)([,}])/g, (match, value, suffix) => {
        const trimmed = value.trim();
        
        // è·³è¿‡æ•°å­—ã€å¸ƒå°”å€¼ã€null
        if (/^(true|false|null|-?\d+\.?\d*)$/.test(trimmed)) {
            return match;
        }
        
        // è·³è¿‡å·²ç»å¼•å·çš„å€¼
        if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
            return match;
        }
        
        // è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
        let escapedValue = trimmed
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
        
        return `: "${escapedValue}"${suffix}`;
    });

    // 4. ä¿®å¤ç¼ºå¤±çš„ç»“æŸæ‹¬å·
    if (repaired.startsWith('{') && !repaired.endsWith('}')) {
        let openBraces = (repaired.match(/{/g) || []).length;
        let closeBraces = (repaired.match(/}/g) || []).length;
        let missing = openBraces - closeBraces;
        
        repaired = repaired.replace(/,\s*$/, '');
        
        for (let i = 0; i < missing; i++) {
            repaired += '}';
        }
    }

    // 5. å°è¯•è§£æ
    try {
        return JSON.parse(repaired);
    } catch (e) {
        // å¦‚æœä¿®å¤å¤±è´¥ï¼Œå°è¯•æå–å…³é”®å‚æ•°
        return extractKeyParams(brokenJson);
    }
}

/**
 * ä»æŸåçš„ JSON ä¸­æå–å…³é”®å‚æ•°ï¼ˆæœ€åæ‰‹æ®µï¼‰
 */
export function extractKeyParams(brokenJson: string): any {
    const params: any = {};

    // æå– path å‚æ•°
    const pathMatch = brokenJson.match(/["']?path["']?\s*[:=]\s*["']?([^"',}\s]+)["']?/i);
    if (pathMatch && pathMatch[1]) {
        params.path = pathMatch[1].trim().replace(/^["']|["']$/g, '');
    }

    // æå– content å‚æ•°
    const contentMatch = brokenJson.match(/["']?content["']?\s*[:=]\s*["']?([^"']+)["']?/i);
    if (contentMatch && contentMatch[1]) {
        params.content = contentMatch[1].trim().replace(/^["']|["']$/g, '');
    }

    return Object.keys(params).length > 0 ? params : null;
}
```

### ç¬¬å››éƒ¨åˆ†ï¼šAPI å‚æ•°ä¼˜åŒ–

#### 4.1 é˜²æ­¢é‡å¤çš„å‚æ•°è®¾ç½®

```rust
// src-tauri/src/services/ai_providers/deepseek.rs

let request = ChatRequest {
    model: model_config.model.clone(),
    messages: messages.iter().map(|m| ChatMessageRequest {
        role: m.role.clone(),
        content: m.content.clone(),
    }).collect(),
    temperature: model_config.temperature,
    top_p: Some(model_config.top_p),
    // å…³é”®ï¼šè®¾ç½® frequency_penalty å’Œ presence_penalty ä¸º 0ï¼Œé˜²æ­¢æ¨¡å‹é¼“åŠ±é‡å¤
    frequency_penalty: Some(0.0),  // 0 = ä¸æƒ©ç½šé‡å¤
    presence_penalty: Some(0.0),   // 0 = ä¸é¼“åŠ±æ–°è¯é¢˜
    max_tokens: Some(model_config.max_tokens as u32),
    stream: true,
    tools: tools_json,
    tool_choice: if tools.is_some() { Some("auto".to_string()) } else { None },
};
```

**å‚æ•°è¯´æ˜ï¼š**
- `frequency_penalty: 0.0`ï¼šä¸æƒ©ç½šé‡å¤çš„ tokenï¼Œé¿å…æ¨¡å‹å› ä¸ºæƒ©ç½šè€Œè¿‡åº¦é¿å…é‡å¤ï¼Œå¯¼è‡´è¾“å‡ºå¼‚å¸¸
- `presence_penalty: 0.0`ï¼šä¸é¼“åŠ±æ–°è¯é¢˜ï¼Œä¿æŒè¾“å‡ºè¿è´¯æ€§
- `temperature`ï¼šä¿æŒé»˜è®¤å€¼ï¼ˆé€šå¸¸ 0.7-0.9ï¼‰ï¼Œä¸è¦è®¾ç½®è¿‡é«˜

### ç¬¬äº”éƒ¨åˆ†ï¼šå‚è€ƒå®ç°ï¼ˆvoid/Cursorï¼‰

#### 5.1 void çš„å®ç°æ–¹å¼

æ ¹æ® void æºç åˆ†æï¼ˆ`chatThreadService.ts`ï¼‰ï¼Œå…³é”®ç‚¹ï¼š

1. **ä½¿ç”¨ `fullText` è€Œéå¢é‡ `delta`**ï¼š
   ```typescript
   onText: ({ fullText, fullReasoning, toolCall }) => {
       this._setStreamState(threadId, { 
           isRunning: 'LLM', 
           llmInfo: { 
               displayContentSoFar: fullText,  // å®Œæ•´æ–‡æœ¬ï¼Œä¸æ˜¯å¢é‡
               reasoningSoFar: fullReasoning, 
               toolCallSoFar: toolCall ?? null 
           }
       })
   }
   ```

2. **æµå¼çŠ¶æ€ç®¡ç†**ï¼š
   - ä½¿ç”¨ `ThreadStreamState` è·Ÿè¸ªæµå¼çŠ¶æ€
   - åªåœ¨ `onFinalMessage` æ—¶æ‰æ·»åŠ åˆ°æ¶ˆæ¯å†å²
   - æµå¼è¿‡ç¨‹ä¸­åªæ›´æ–° `streamState`ï¼Œä¸ç›´æ¥ä¿®æ”¹æ¶ˆæ¯

3. **å·¥å…·è°ƒç”¨å¤„ç†**ï¼š
   - å·¥å…·è°ƒç”¨çš„ `arguments` åœ¨æµå¼è¿‡ç¨‹ä¸­ç´¯ç§¯
   - åªæœ‰åœ¨ `finish_reason === "tool_calls"` æ—¶æ‰æ‰§è¡Œå·¥å…·

#### 5.2 Cursor çš„å®ç°æ–¹å¼

Cursor ä½¿ç”¨ç±»ä¼¼çš„æ–¹æ³•ï¼š

1. **å¢é‡æ–‡æœ¬å»é‡**ï¼š
   ```typescript
   // æ£€æŸ¥æ–°å†…å®¹æ˜¯å¦ä¸ç´¯ç§¯æ–‡æœ¬é‡å¤
   if (accumulatedText.endsWith(newDelta)) {
       return; // è·³è¿‡é‡å¤çš„ delta
   }
   accumulatedText += newDelta;
   ```

2. **å·¥å…·è°ƒç”¨ JSON ä¿®å¤**ï¼š
   - ä½¿ç”¨å¤šå±‚ JSON ä¿®å¤ç­–ç•¥
   - å¦‚æœä¿®å¤å¤±è´¥ï¼Œå°è¯•æå–å…³é”®å‚æ•°ï¼ˆpath, content ç­‰ï¼‰

### ç¬¬å…­éƒ¨åˆ†ï¼šå®Œæ•´å®ç°æ£€æŸ¥æ¸…å•

#### 6.1 åç«¯æ£€æŸ¥ç‚¹

- [ ] SSE è¡Œç¼“å†²æœºåˆ¶æ­£ç¡®å®ç°ï¼ˆå¤„ç†è·¨ chunk çš„è¡Œï¼‰
- [ ] é‡å¤å†…å®¹æ£€æµ‹åŸºäºç´¯ç§¯æ–‡æœ¬ï¼ˆ`accumulated_text.ends_with(content)`ï¼‰
- [ ] å·¥å…·è°ƒç”¨ arguments æ­£ç¡®ç´¯ç§¯ï¼ˆè·¨å¤šä¸ª SSE è¡Œï¼‰
- [ ] å·¥å…·è°ƒç”¨å®Œæˆæ£€æµ‹ï¼ˆJSON å®Œæ•´ä¸”å¯è§£æï¼‰
- [ ] ç©º chunk è¿‡æ»¤ï¼ˆä¸å‘é€ç©ºæ–‡æœ¬ï¼‰
- [ ] äºŒæ¬¡å»é‡æ£€æµ‹ï¼ˆåœ¨ `ai_commands.rs` ä¸­ï¼‰
- [ ] API å‚æ•°è®¾ç½®æ­£ç¡®ï¼ˆ`frequency_penalty: 0.0`ï¼‰

#### 6.2 å‰ç«¯æ£€æŸ¥ç‚¹

- [ ] ç©ºäº‹ä»¶è¿‡æ»¤ï¼ˆ`isEmptyChunk` æ£€æŸ¥ï¼‰
- [ ] é‡å¤ chunk æ£€æµ‹ï¼ˆå‰ç«¯äºŒæ¬¡é˜²æŠ¤ï¼‰
- [ ] å·¥å…·è°ƒç”¨ JSON ä¿®å¤ï¼ˆ`aggressiveJSONRepair`ï¼‰
- [ ] å…³é”®å‚æ•°æå–ï¼ˆ`extractKeyParams` ä½œä¸ºåå¤‡ï¼‰
- [ ] çŠ¶æ€æ›´æ–°é¿å…é‡å¤æ¸²æŸ“ï¼ˆä½¿ç”¨ `useRef` è·Ÿè¸ªç´¯ç§¯æ–‡æœ¬ï¼‰

### ç¬¬ä¸ƒéƒ¨åˆ†ï¼šæµ‹è¯•å’ŒéªŒè¯

#### 7.1 æµ‹è¯•åœºæ™¯

1. **æ­£å¸¸æµå¼å“åº”**ï¼š
   - å‘é€æ¶ˆæ¯ï¼ŒéªŒè¯æ–‡æœ¬æ­£ç¡®ç´¯ç§¯
   - éªŒè¯æ²¡æœ‰é‡å¤å†…å®¹

2. **å·¥å…·è°ƒç”¨**ï¼š
   - éªŒè¯å·¥å…·è°ƒç”¨ arguments æ­£ç¡®ç´¯ç§¯
   - éªŒè¯ JSON ä¿®å¤é€»è¾‘å·¥ä½œæ­£å¸¸
   - éªŒè¯å·¥å…·æ‰§è¡ŒæˆåŠŸ

3. **ç½‘ç»œä¸ç¨³å®š**ï¼š
   - æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿï¼ŒéªŒè¯ç¼“å†²æœºåˆ¶
   - éªŒè¯é‡å¤å†…å®¹è¢«æ­£ç¡®è¿‡æ»¤

4. **è¾¹ç•Œæƒ…å†µ**ï¼š
   - ç©º chunk å¤„ç†
   - ä¸å®Œæ•´çš„ JSON å¤„ç†
   - æµå¼ä¸­æ–­å¤„ç†

#### 7.2 è°ƒè¯•æ—¥å¿—

å¯ç”¨è¯¦ç»†æ—¥å¿—ä»¥ä¾¿è°ƒè¯•ï¼š

```rust
// åç«¯æ—¥å¿—
eprintln!("ğŸ“ ç´¯ç§¯å·¥å…·è°ƒç”¨ arguments: å½“å‰é•¿åº¦={}, æ–°å¢é•¿åº¦={}", ...);
eprintln!("âš ï¸ æ£€æµ‹åˆ°é‡å¤çš„ content deltaï¼Œè·³è¿‡: '{}'", ...);
eprintln!("âœ… JSON å®Œæ•´ï¼Œæ ‡è®°ä¸ºå®Œæˆ");
```

```typescript
// å‰ç«¯æ—¥å¿—
console.log('ğŸ“¨ æ”¶åˆ°èŠå¤©æµå¼å“åº”:', { chunk_length, done, has_to