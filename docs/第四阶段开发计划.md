# Binder（合页）第四阶段开发计划

## 文档信息

- **阶段名称**：文件管理完善
- **开发周期**：4 周（Week 17-20）
- **开发目标**：完善文件管理系统，实现文件监听优化、工作区增强、SQLite 全文索引完善、AI 智能分类整理
- **版本**：v4.0（基于前三阶段经验优化版）
- **创建日期**：2025年
- **最后更新**：2025年
- **更新说明**：基于前三个阶段的实际开发进度，重点关注功能完善、性能优化和稳定性提升

## 总体目标

完善文件管理系统，实现高效的文件操作、毫秒级全文搜索、智能文件分类，为 Binder 提供强大的文件管理能力。

**核心原则**（基于前三阶段经验）：
- ✅ **稳定性优先**：所有功能都要有完整的错误处理和边界情况处理
- ✅ **性能优化**：SQLite 索引、文件监听都要优化性能，避免阻塞
- ✅ **用户体验**：流畅的文件操作、清晰的反馈、优雅的错误提示
- ✅ **功能完善**：在前三阶段基础上完善细节，补全缺失功能
- ✅ **测试覆盖**：关键功能要有集成测试

---

## 前三阶段进度总结

### ✅ 已完成的基础功能

1. **文件监听**：`file_watcher.rs` 已实现基础功能
2. **工作区管理**：`workspace.rs` 已实现基础功能
3. **SQLite 全文索引**：`search_service.rs` 后端已实现，`SearchPanel.tsx` 前端已实现
4. **记忆库功能**：`memory_service.rs` 后端已实现，`MemoryTab.tsx` 前端已实现
5. **文件树基础**：文件树显示和基本操作已完成

### ⚠️ 需要完善的功能

1. **文件监听优化**：
   - 事件去重和防抖机制需要完善
   - 增量更新文件树需要实现
   - 外部修改检测需要完善

2. **工作区增强**：
   - 最近工作区列表需要完善
   - 工作区切换需要优化
   - 工作区信息显示需要优化

3. **SQLite 索引完善**：
   - 增量索引更新需要实现
   - 自动索引构建需要优化
   - 索引性能需要优化

4. **文件操作增强**：
   - 文件拖拽导入需要实现
   - 右键菜单需要实现
   - 文件重命名、删除需要完善

5. **AI 智能分类整理**：
   - 文件内容分析需要实现
   - 智能分类算法需要实现
   - 批量整理功能需要实现

---

## Week 17：文件监听优化和工作区增强

### 目标

优化文件监听机制，完善工作区管理功能，提升用户体验。

### 17.1 文件监听优化（Day 1-3）

#### 17.1.1 事件去重和防抖机制

**任务**：完善文件监听的事件处理，实现去重和防抖

**具体步骤**：

1. **实现事件去重**
   ```rust
   // src-tauri/src/services/file_watcher.rs
   pub struct FileWatcherService {
       watcher: Option<RecommendedWatcher>,
       workspace_path: Option<PathBuf>,
       event_queue: VecDeque<FileChangeEvent>,
       last_events: HashMap<PathBuf, Instant>, // 相同路径的最后事件时间
       debounce_timer: Option<tokio::time::Instant>,
   }
   
   impl FileWatcherService {
       // 事件去重：相同路径的连续事件只保留最后一个
       fn deduplicate_events(&mut self, events: Vec<FileChangeEvent>) -> Vec<FileChangeEvent> {
           let mut unique_events = HashMap::new();
           
           for event in events {
               // 相同路径的事件，保留最新的
               unique_events.insert(event.path.clone(), event);
           }
           
           unique_events.into_values().collect()
       }
       
       // 防抖处理：500ms 内的多个事件合并为一个
       fn debounce_events(&mut self) -> Vec<FileChangeEvent> {
           // 等待 500ms，收集所有事件
           // 然后统一处理
       }
   }
   ```

2. **实现事件过滤**
   ```rust
   impl FileWatcherService {
       // 过滤临时文件、隐藏文件、系统文件
       fn should_process_event(&self, path: &Path) -> bool {
           let path_str = path.to_string_lossy();
           
           // 忽略临时文件
           if path_str.contains(".tmp") || path_str.contains(".swp") {
               return false;
           }
           
           // 忽略隐藏文件（.开头的，除了 .binder）
           if path.file_name()
               .and_then(|n| n.to_str())
               .map(|n| n.starts_with(".") && n != ".binder")
               .unwrap_or(false) {
               return false;
           }
           
           // 忽略系统文件（如 .DS_Store）
           if path.file_name()
               .and_then(|n| n.to_str())
               .map(|n| n == ".DS_Store" || n == "Thumbs.db")
               .unwrap_or(false) {
               return false;
           }
           
           true
       }
   }
   ```

3. **实现增量更新**
   ```rust
   impl FileWatcherService {
       // 增量更新文件树节点
       async fn update_file_tree_incremental(
           &self,
           events: Vec<FileChangeEvent>,
           app_handle: tauri::AppHandle,
       ) -> Result<()> {
           for event in events {
               match event.kind {
                   FileChangeKind::Create => {
                       // 发送创建事件到前端
                       app_handle.emit("file-tree-node-created", event)?;
                   }
                   FileChangeKind::Modify => {
                       // 发送修改事件到前端
                       app_handle.emit("file-tree-node-modified", event)?;
                   }
                   FileChangeKind::Remove => {
                       // 发送删除事件到前端
                       app_handle.emit("file-tree-node-removed", event)?;
                   }
               }
           }
           Ok(())
       }
   }
   ```

**前端实现**：

1. **监听文件树变化事件**
   ```typescript
   // src/components/FileTree/FileTree.tsx
   useEffect(() => {
     const setupListeners = async () => {
       const unlistenCreated = await listen('file-tree-node-created', (event: any) => {
         // 增量添加节点到文件树
         const { path, name, isDirectory } = event.payload;
         // 更新文件树状态
       });
       
       const unlistenModified = await listen('file-tree-node-modified', (event: any) => {
         // 更新节点状态
       });
       
       const unlistenRemoved = await listen('file-tree-node-removed', (event: any) => {
         // 从文件树中移除节点
       });
       
       return () => {
         unlistenCreated();
         unlistenModified();
         unlistenRemoved();
       };
     };
     
     setupListeners().then(unlisten => {
       // 保存清理函数
     });
   }, []);
   ```

**交付物**：
- 完善的事件去重机制
- 500ms 防抖处理
- 事件过滤规则
- 增量文件树更新

#### 17.1.2 外部修改检测

**任务**：检测文件的外部修改，提示用户处理

**具体步骤**：

1. **后端实现外部修改检测**
   ```rust
   // src-tauri/src/services/file_system.rs
   pub struct FileMetadata {
       pub path: PathBuf,
       pub modified_time: SystemTime,
       pub size: u64,
   }
   
   impl FileSystemService {
       // 检查文件是否被外部修改
       pub fn check_external_modification(
           &self,
           path: &Path,
           last_modified: SystemTime,
       ) -> Result<bool> {
           let metadata = std::fs::metadata(path)?;
           let current_modified = metadata.modified()?;
           
           Ok(current_modified > last_modified)
       }
   }
   ```

2. **前端实现外部修改提示**
   ```typescript
   // src/stores/editorStore.ts
   // 定期检查打开文件的修改时间
   useEffect(() => {
     const interval = setInterval(async () => {
       const tabs = useEditorStore.getState().tabs;
       
       for (const tab of tabs) {
         if (!tab.isDirty) {
           // 检查文件是否被外部修改
           const isModified = await invoke<boolean>('check_external_modification', {
             path: tab.filePath,
             lastModified: tab.lastModifiedTime,
           });
           
           if (isModified) {
             // 显示提示对话框
             showExternalModificationDialog(tab);
           }
         }
       }
     }, 5000); // 每 5 秒检查一次
     
     return () => clearInterval(interval);
   }, []);
   ```

3. **实现外部修改对话框**
   ```typescript
   // src/components/Editor/ExternalModificationDialog.tsx
   const ExternalModificationDialog: React.FC<{
     filePath: string;
     onContinueOverwrite: () => void;
     onLoadChanges: () => void;
     onCompare: () => void;
   }> = ({ filePath, onContinueOverwrite, onLoadChanges, onCompare }) => {
     return (
       <Modal>
         <h3>文件已被外部修改</h3>
         <p>文件 "{filePath}" 已被外部程序修改。请选择操作：</p>
         <div>
           <button onClick={onContinueOverwrite}>继续覆盖</button>
           <button onClick={onLoadChanges}>加载更改</button>
           <button onClick={onCompare}>比较差异</button>
         </div>
       </Modal>
     );
   };
   ```

**交付物**：
- 外部修改检测机制
- 用户提示对话框
- 继续覆盖/加载更改/比较差异功能

### 17.2 工作区增强（Day 4-5）

#### 17.2.1 最近工作区列表完善

**任务**：完善最近工作区列表的加载和显示

**具体步骤**：

1. **后端完善工作区服务**
   ```rust
   // src-tauri/src/services/workspace.rs
   impl WorkspaceService {
       // 获取最近工作区列表（按时间排序）
       pub fn get_recent_workspaces(&self) -> Result<Vec<Workspace>, String> {
           let workspaces = self.load_workspaces()?;
           
           // 按打开时间排序（最新的在前）
           let mut sorted = workspaces;
           sorted.sort_by(|a, b| b.opened_at.cmp(&a.opened_at));
           
           // 只返回前 10 个
           sorted.truncate(10);
           
           Ok(sorted)
       }
       
       // 更新工作区打开时间
       pub fn update_workspace_opened_time(&mut self, path: &str) -> Result<(), String> {
           let mut workspaces = self.load_workspaces()?;
           
           if let Some(workspace) = workspaces.iter_mut().find(|w| w.path == path) {
               workspace.opened_at = Utc::now();
               self.save_workspaces(&workspaces)?;
           }
           
           Ok(())
       }
   }
   ```

2. **前端完善欢迎对话框**
   ```typescript
   // src/components/Layout/WelcomeDialog.tsx
   useEffect(() => {
     const loadRecentWorkspaces = async () => {
       try {
         const workspaces = await invoke<Workspace[]>('get_recent_workspaces');
         setRecentWorkspaces(workspaces);
       } catch (error) {
         console.error('加载最近工作区失败:', error);
       }
     };
     
     loadRecentWorkspaces();
   }, []);
   ```

**交付物**：
- 最近工作区列表正确加载和显示
- 工作区按时间排序
- 工作区打开时间自动更新

#### 17.2.2 工作区切换优化

**任务**：优化工作区切换体验

**具体步骤**：

1. **实现工作区切换逻辑**
   ```rust
   // src-tauri/src/commands/file_commands.rs
   #[tauri::command]
   pub async fn switch_workspace(
       path: String,
       workspace_service: State<'_, WorkspaceServiceState>,
       file_watcher: State<'_, FileWatcherState>,
   ) -> Result<Workspace, String> {
       // 1. 停止当前工作区的监听
       // 2. 打开新工作区
       // 3. 开始监听新工作区
       // 4. 更新最近工作区列表
       
       let workspace = workspace_service.open_workspace(&path)?;
       
       // 更新文件监听
       let mut watcher = file_watcher.lock().unwrap();
       watcher.watch_workspace(PathBuf::from(&path))?;
       
       Ok(workspace)
   }
   ```

2. **前端实现工作区切换**
   ```typescript
   // src/stores/fileStore.ts
   const switchWorkspace = async (path: string) => {
     try {
       // 检查是否有未保存的文件
       const hasUnsaved = useEditorStore.getState().tabs.some(t => t.isDirty);
       
       if (hasUnsaved) {
         const confirmed = await confirmUnsavedChanges();
         if (!confirmed) return;
       }
       
       // 切换工作区
       const workspace = await invoke<Workspace>('switch_workspace', { path });
       
       // 更新状态
       set({ currentWorkspace: workspace.path, fileTree: null });
       
       // 重新构建文件树
       await buildFileTree(workspace.path);
     } catch (error) {
       console.error('切换工作区失败:', error);
     }
   };
   ```

**交付物**：
- 工作区切换功能
- 未保存文件检查
- 文件监听自动切换

### 17.3 测试和验证（Day 6-7）

**任务**：测试文件监听和工作区功能

**测试项**：
1. 文件创建、修改、删除事件是否正确触发
2. 事件去重和防抖是否正常工作
3. 外部修改检测是否准确
4. 工作区切换是否流畅
5. 最近工作区列表是否正确显示

**交付物**：
- 测试报告
- Bug 修复记录
- 功能文档

---

## Week 18：文件操作增强

### 目标

实现完整的文件操作功能，包括拖拽导入、右键菜单、文件重命名等。

### 18.1 文件拖拽导入（Day 1-2）

#### 18.1.1 实现拖拽处理

**任务**：实现文件拖拽到文件树的功能

**具体步骤**：

1. **前端实现拖拽区域**
   ```typescript
   // src/components/FileTree/FileTree.tsx
   const FileTree: React.FC = () => {
     const handleDragOver = (e: React.DragEvent) => {
       e.preventDefault();
       e.stopPropagation();
       setIsDragOver(true);
     };
     
     const handleDrop = async (e: React.DragEvent) => {
       e.preventDefault();
       e.stopPropagation();
       setIsDragOver(false);
       
       const files = Array.from(e.dataTransfer.files);
       
       for (const file of files) {
         await handleFileDrop(file);
       }
     };
     
     const handleFileDrop = async (file: File) => {
       // 调用后端接口，移动文件到工作区
       await invoke('move_file_to_workspace', {
         sourcePath: file.path,
         workspacePath: currentWorkspace,
       });
     };
     
     return (
       <div
         onDragOver={handleDragOver}
         onDrop={handleDrop}
         className={isDragOver ? 'border-2 border-blue-500' : ''}
       >
         {/* 文件树内容 */}
       </div>
     );
   };
   ```

2. **后端实现文件移动**
   ```rust
   // src-tauri/src/commands/file_commands.rs
   #[tauri::command]
   pub async fn move_file_to_workspace(
       source_path: String,
       workspace_path: String,
   ) -> Result<(), String> {
       let source = PathBuf::from(&source_path);
       let dest_dir = PathBuf::from(&workspace_path);
       
       // 检查源文件是否存在
       if !source.exists() {
           return Err("源文件不存在".to_string());
       }
       
       // 检查是否在同一分区
       let same_partition = is_same_partition(&source, &dest_dir)?;
       
       if same_partition {
           // 直接移动
           let dest = dest_dir.join(source.file_name().unwrap());
           std::fs::rename(&source, &dest)
               .map_err(|e| format!("移动文件失败: {}", e))?;
       } else {
           // 跨分区，需要复制后删除
           let dest = dest_dir.join(source.file_name().unwrap());
           std::fs::copy(&source, &dest)
               .map_err(|e| format!("复制文件失败: {}", e))?;
           std::fs::remove_file(&source)
               .map_err(|e| format!("删除源文件失败: {}", e))?;
       }
       
       Ok(())
   }
   
   fn is_same_partition(path1: &Path, path2: &Path) -> Result<bool> {
       // 获取文件系统设备 ID
       // 比较是否相同
       Ok(true) // 简化实现
   }
   ```

**交付物**：
- 文件拖拽功能
- 跨分区文件处理
- 拖拽视觉反馈

### 18.2 右键菜单（Day 3-4）

#### 18.2.1 实现右键菜单

**任务**：实现文件树的右键菜单

**具体步骤**：

1. **创建右键菜单组件**
   ```typescript
   // src/components/FileTree/FileTreeContextMenu.tsx
   const FileTreeContextMenu: React.FC<{
     x: number;
     y: number;
     filePath: string;
     isDirectory: boolean;
     onClose: () => void;
   }> = ({ x, y, filePath, isDirectory, onClose }) => {
     const handleRename = () => {
       // 打开重命名对话框
       onClose();
     };
     
     const handleDelete = async () => {
       if (confirm('确定要删除吗？')) {
         await invoke('delete_file', { path: filePath });
         onClose();
       }
     };
     
     return (
       <div
         className="fixed bg-white dark:bg-gray-800 border border-gray-300 rounded-lg shadow-lg py-1 z-50"
         style={{ left: x, top: y }}
       >
         {!isDirectory && (
           <>
             <button onClick={handleRename} className="w-full text-left px-4 py-2 hover:bg-gray-100">
               重命名
             </button>
             <button onClick={handleDelete} className="w-full text-left px-4 py-2 hover:bg-gray-100 text-red-600">
               删除
             </button>
           </>
         )}
         {isDirectory && (
           <>
             <button onClick={handleRename} className="w-full text-left px-4 py-2 hover:bg-gray-100">
               重命名
             </button>
             <button onClick={handleDelete} className="w-full text-left px-4 py-2 hover:bg-gray-100 text-red-600">
               删除
             </button>
           </>
         )}
       </div>
     );
   };
   ```

2. **集成到文件树**
   ```typescript
   // src/components/FileTree/FileTreeNode.tsx
   const FileTreeNode: React.FC<{ node: FileTreeNode }> = ({ node }) => {
     const [contextMenu, setContextMenu] = useState<{ x: number; y: number } | null>(null);
     
     const handleContextMenu = (e: React.MouseEvent) => {
       e.preventDefault();
       setContextMenu({ x: e.clientX, y: e.clientY });
     };
     
     return (
       <div onContextMenu={handleContextMenu}>
         {/* 文件节点内容 */}
         {contextMenu && (
           <FileTreeContextMenu
             x={contextMenu.x}
             y={contextMenu.y}
             filePath={node.path}
             isDirectory={node.isDirectory}
             onClose={() => setContextMenu(null)}
           />
         )}
       </div>
     );
   };
   ```

**交付物**：
- 右键菜单组件
- 重命名功能
- 删除功能

### 18.3 文件操作完善（Day 5-6）

#### 18.3.1 文件重命名

**任务**：实现文件重命名功能

**具体步骤**：

1. **后端实现重命名**
   ```rust
   // src-tauri/src/commands/file_commands.rs
   #[tauri::command]
   pub async fn rename_file(
       old_path: String,
       new_name: String,
   ) -> Result<(), String> {
       let old_path_buf = PathBuf::from(&old_path);
       
       // 验证新名称
       if new_name.contains('/') || new_name.contains('\\') {
           return Err("文件名不能包含路径分隔符".to_string());
       }
       
       // 构建新路径
       let new_path = old_path_buf.parent()
           .unwrap()
           .join(&new_name);
       
       // 检查新路径是否已存在
       if new_path.exists() {
           return Err("文件已存在".to_string());
       }
       
       // 重命名
       std::fs::rename(&old_path_buf, &new_path)
           .map_err(|e| format!("重命名失败: {}", e))?;
       
       Ok(())
   }
   ```

2. **前端实现重命名对话框**
   ```typescript
   // src/components/FileTree/RenameDialog.tsx
   const RenameDialog: React.FC<{
     currentName: string;
     onConfirm: (newName: string) => void;
     onCancel: () => void;
   }> = ({ currentName, onConfirm, onCancel }) => {
     const [newName, setNewName] = useState(currentName);
     
     return (
       <Modal>
         <h3>重命名</h3>
         <input
           value={newName}
           onChange={(e) => setNewName(e.target.value)}
           onKeyDown={(e) => {
             if (e.key === 'Enter') {
               onConfirm(newName);
             } else if (e.key === 'Escape') {
               onCancel();
             }
           }}
         />
         <button onClick={() => onConfirm(newName)}>确认</button>
         <button onClick={onCancel}>取消</button>
       </Modal>
     );
   };
   ```

#### 18.3.2 文件删除确认

**任务**：实现安全的文件删除功能

**具体步骤**：

1. **后端实现删除**
   ```rust
   // src-tauri/src/commands/file_commands.rs
   #[tauri::command]
   pub async fn delete_file(path: String) -> Result<(), String> {
       let path_buf = PathBuf::from(&path);
       
       // 检查文件是否在工作区内（安全验证）
       // ...
       
       if path_buf.is_dir() {
           std::fs::remove_dir_all(&path_buf)
               .map_err(|e| format!("删除目录失败: {}", e))?;
       } else {
           std::fs::remove_file(&path_buf)
               .map_err(|e| format!("删除文件失败: {}", e))?;
       }
       
       Ok(())
   }
   ```

### 18.4 导入操作（Day 7）

#### 18.4.1 实现导入功能

**任务**：实现文件导入（复制文件）功能

**具体步骤**：

1. **后端实现导入**
   ```rust
   // src-tauri/src/commands/file_commands.rs
   #[tauri::command]
   pub async fn import_file(
       source_path: String,
       workspace_path: String,
   ) -> Result<(), String> {
       let source = PathBuf::from(&source_path);
       let dest_dir = PathBuf::from(&workspace_path);
       
       let dest = dest_dir.join(source.file_name().unwrap());
       
       // 如果目标文件已存在，添加数字后缀
       let mut final_dest = dest.clone();
       let mut counter = 1;
       while final_dest.exists() {
           let stem = dest.file_stem().unwrap().to_string_lossy();
           let ext = dest.extension()
               .and_then(|s| s.to_str())
               .map(|s| format!(".{}", s))
               .unwrap_or_default();
           final_dest = dest_dir.join(format!("{} ({}).{}", stem, counter, ext));
           counter += 1;
       }
       
       // 复制文件
       std::fs::copy(&source, &final_dest)
           .map_err(|e| format!("导入文件失败: {}", e))?;
       
       Ok(())
   }
   ```

2. **前端实现导入按钮**
   ```typescript
   // src/components/FileTree/FileTreePanel.tsx
   const handleImport = async () => {
     const files = await open({ multiple: true });
     
     for (const file of files) {
       await invoke('import_file', {
         sourcePath: file.path,
         workspacePath: currentWorkspace,
       });
     }
   };
   ```

**交付物**：
- 文件拖拽导入
- 右键菜单功能
- 文件重命名
- 文件删除（带确认）
- 文件导入（复制）

---

## Week 19：SQLite 全文索引完善

### 目标

完善 SQLite 全文索引功能，实现增量更新、自动索引构建和性能优化。

### 19.1 增量索引更新（Day 1-3）

#### 19.1.1 实现增量更新机制

**任务**：实现文件变化时自动更新索引

**具体步骤**：

1. **集成到文件监听**
   ```rust
   // src-tauri/src/services/file_watcher.rs
   impl FileWatcherService {
       // 在文件变化时触发索引更新
       async fn handle_file_change_for_index(
           &self,
           event: FileChangeEvent,
           search_service: Arc<Mutex<SearchService>>,
       ) -> Result<()> {
           match event.kind {
               FileChangeKind::Create | FileChangeKind::Modify => {
                   // 索引新文件或更新索引
                   if let Ok(content) = read_file_content(&event.path) {
                       let search = search_service.lock().unwrap();
                       search.index_document(
                           &event.path,
                           &extract_title(&content),
                           &content,
                           &detect_file_type(&event.path),
                       )?;
                   }
               }
               FileChangeKind::Remove => {
                   // 删除索引
                   let search = search_service.lock().unwrap();
                   search.remove_document(&event.path)?;
               }
           }
           Ok(())
       }
   }
   ```

2. **优化索引性能**
   ```rust
   // src-tauri/src/services/search_service.rs
   impl SearchService {
       // 批量索引更新（提高性能）
       pub fn batch_update_index(
           &self,
           updates: Vec<(String, String, String, String)>, // (path, title, content, file_type)
       ) -> Result<()> {
           let conn = self.db.lock().unwrap();
           let tx = conn.transaction()?;
           
           for (path, title, content, file_type) in updates {
               // 使用 UPSERT 避免重复
               tx.execute(
                   "INSERT INTO documents_fts (path, title, content) VALUES (?1, ?2, ?3)
                    ON CONFLICT(path) DO UPDATE SET title=?2, content=?3",
                   params![path, title, content],
               )?;
           }
           
           tx.commit()?;
           Ok(())
       }
   }
   ```

**交付物**：
- 文件变化自动触发索引更新
- 批量索引更新机制
- 索引更新性能优化

### 19.2 自动索引构建（Day 4-5）

#### 19.2.1 后台索引构建

**任务**：实现后台异步构建初始索引

**具体步骤**：

1. **实现异步索引构建**
   ```rust
   // src-tauri/src/services/search_service.rs
   impl SearchService {
       // 异步构建初始索引（不阻塞启动）
       pub async fn build_index_async(workspace_path: &Path) -> Result<()> {
           let search_service = SearchService::new(workspace_path)?;
           
           tokio::spawn(async move {
               let mut updates = Vec::new();
               let mut count = 0;
               
               // 遍历所有文件
               for entry in walkdir::WalkDir::new(workspace_path)
                   .follow_links(false)
                   .into_iter()
                   .filter_map(|e| e.ok()) {
                   
                   let path = entry.path();
                   if path.is_file() && should_index(path) {
                       if let Ok(content) = read_file_content(path) {
                           let title = extract_title(&content);
                           let file_type = detect_file_type(path);
                           updates.push((
                               path.to_string_lossy().to_string(),
                               title,
                               content,
                               file_type,
                           ));
                           count += 1;
                           
                           // 每 100 个文件提交一次（批量提交）
                           if count % 100 == 0 {
                               search_service.batch_update_index(updates.clone())?;
                               updates.clear();
                               // 发送进度事件
                               // app_handle.emit("index-progress", count)?;
                           }
                       }
                   }
               }
               
               // 提交剩余的文件
               if !updates.is_empty() {
                   search_service.batch_update_index(updates)?;
               }
               
               Ok::<(), Error>(())
           });
           
           Ok(())
       }
   }
   ```

2. **显示索引进度**
   ```typescript
   // src/components/Search/SearchPanel.tsx
   useEffect(() => {
     const setupListener = async () => {
       const unlisten = await listen('index-progress', (event: any) => {
         const { count } = event.payload;
         setIndexingProgress(count);
       });
       
       return unlisten;
     };
     
     setupListener();
   }, []);
   ```

**交付物**：
- 后台异步索引构建
- 批量索引提交
- 索引进度显示

### 19.3 搜索结果优化（Day 6-7）

#### 19.3.1 搜索结果片段高亮

**任务**：实现搜索结果片段高亮

**具体步骤**：

1. **后端实现片段提取和高亮**
   ```rust
   // src-tauri/src/services/search_service.rs
   impl SearchService {
       // 搜索并返回高亮片段
       pub fn search_with_snippets(
           &self,
           query: &str,
           limit: i32,
       ) -> Result<Vec<SearchResult>> {
           let conn = self.db.lock().unwrap();
           
           // 使用 FTS5 的 highlight 和 snippet 函数
           let mut stmt = conn.prepare(
               "SELECT 
                   path,
                   title,
                   snippet(documents_fts, 2, '<mark>', '</mark>', '...', 32) as snippet,
                   rank
               FROM documents_fts
               WHERE documents_fts MATCH ?1
               ORDER BY rank
               LIMIT ?2"
           )?;
           
           let results = stmt.query_map(params![query, limit], |row| {
               Ok(SearchResult {
                   path: row.get(0)?,
                   title: row.get(1)?,
                   snippet: row.get(2)?,
                   rank: row.get(3)?,
               })
           })?;
           
           results.collect()
       }
   }
   ```

2. **前端显示高亮片段**
   ```typescript
   // src/components/Search/SearchPanel.tsx
   // 搜索结果片段已经包含 <mark> 标签
   // 使用 dangerouslySetInnerHTML 显示（已实现）
   <div dangerouslySetInnerHTML={{ __html: result.snippet }} />
   ```

**交付物**：
- 搜索结果片段高亮
- 搜索结果排序优化
- 搜索性能优化

---

## Week 20：AI 智能分类整理

### 目标

实现 AI 智能分类整理功能，自动分析文件内容并分类整理。

### 20.1 文件内容分析（Day 1-2）

#### 20.1.1 实现文件内容提取

**任务**：提取文件内容用于 AI 分析

**具体步骤**：

1. **实现内容提取服务**
   ```rust
   // src-tauri/src/services/file_classifier.rs
   pub struct FileClassifierService {
       ai_service: Arc<AIService>,
   }
   
   impl FileClassifierService {
       // 提取文件内容（纯文本）
       fn extract_text_content(path: &Path) -> Result<String> {
           let ext = path.extension()
               .and_then(|s| s.to_str())
               .unwrap_or("");
           
           match ext {
               "txt" | "md" => {
                   std::fs::read_to_string(path)
                       .map_err(|e| format!("读取文件失败: {}", e))
               }
               "docx" => {
                   // 使用 Pandoc 提取文本
                   // ...
               }
               _ => {
                   // 尝试作为文本读取
                   std::fs::read_to_string(path)
                       .map_err(|e| format!("读取文件失败: {}", e))
               }
           }
       }
   }
   ```

2. **实现文件类型检测**
   ```rust
   impl FileClassifierService {
       // 检测文件类型（基于内容）
       fn detect_file_category(content: &str) -> FileCategory {
           // 简单的关键词匹配
           if content.contains("代码") || content.contains("function") {
               FileCategory::Code
           } else if content.contains("图片") || content.contains("设计") {
               FileCategory::Design
           } else {
               FileCategory::Document
           }
       }
   }
   ```

### 20.2 智能分类算法（Day 3-4）

#### 20.2.1 实现 AI 分类

**任务**：使用 AI 分析文件内容并分类

**具体步骤**：

1. **实现 AI 分类提示词**
   ```rust
   // src-tauri/src/services/file_classifier.rs
   impl FileClassifierService {
       // AI 分类文件
       async fn classify_file_with_ai(
           &self,
           path: &Path,
           content: &str,
           existing_folders: &[String],
       ) -> Result<FileClassification> {
           let prompt = format!(
               r#"分析以下文件内容，并建议将其分类到哪个文件夹。

文件路径：{}
文件内容（前 1000 字符）：{}

现有文件夹：{}

请返回 JSON 格式：
{{
    "category": "文件夹名称",
    "reason": "分类原因",
    "confidence": 0.9
}}"#,
               path.display(),
               &content.chars().take(1000).collect::<String>(),
               existing_folders.join(", ")
           );
           
           // 调用 AI 服务
           let response = self.ai_service.chat(&prompt).await?;
           
           // 解析 JSON 响应
           let classification: FileClassification = serde_json::from_str(&response)?;
           
           Ok(classification)
       }
   }
   ```

2. **实现批量分类**
   ```rust
   impl FileClassifierService {
       // 批量分类文件
       pub async fn classify_files(
           &self,
           files: Vec<PathBuf>,
           workspace_path: &Path,
       ) -> Result<Vec<FileClassification>> {
           // 获取现有文件夹列表
           let existing_folders = get_existing_folders(workspace_path)?;
           
           let mut classifications = Vec::new();
           
           for file in files {
               if let Ok(content) = Self::extract_text_content(&file) {
                   let classification = self.classify_file_with_ai(
                       &file,
                       &content,
                       &existing_folders,
                   ).await?;
                   
                   classifications.push(classification);
               }
           }
           
           Ok(classifications)
       }
   }
   ```

### 20.3 批量整理功能（Day 5-6）

#### 20.3.1 实现批量移动

**任务**：实现批量文件整理功能

**具体步骤**：

1. **创建整理命令**
   ```rust
   // src-tauri/src/commands/file_commands.rs
   #[tauri::command]
   pub async fn organize_files(
       file_paths: Vec<String>,
       workspace_path: String,
   ) -> Result<Vec<FileMoveResult>, String> {
       let classifier = FileClassifierService::new()?;
       let classifications = classifier.classify_files(
           file_paths.iter().map(PathBuf::from).collect(),
           &PathBuf::from(&workspace_path),
       ).await?;
       
       let mut results = Vec::new();
       
       for (file_path, classification) in file_paths.iter().zip(classifications.iter()) {
           let source = PathBuf::from(file_path);
           let category_dir = PathBuf::from(&workspace_path)
               .join(&classification.category);
           
           // 创建分类文件夹（如果不存在）
           std::fs::create_dir_all(&category_dir)?;
           
           let dest = category_dir.join(source.file_name().unwrap());
           
           // 移动文件
           match std::fs::rename(&source, &dest) {
               Ok(_) => results.push(FileMoveResult {
                   file_path: file_path.clone(),
                   success: true,
                   message: format!("已移动到 {}", classification.category),
               }),
               Err(e) => results.push(FileMoveResult {
                   file_path: file_path.clone(),
                   success: false,
                   message: format!("移动失败: {}", e),
               }),
           }
       }
       
       Ok(results)
   }
   ```

2. **前端实现整理界面**
   ```typescript
   // src/components/FileTree/OrganizeFilesDialog.tsx
   const OrganizeFilesDialog: React.FC<{
     files: string[];
     onOrganize: (results: FileMoveResult[]) => void;
     onCancel: () => void;
   }> = ({ files, onOrganize, onCancel }) => {
     const [isOrganizing, setIsOrganizing] = useState(false);
     const [preview, setPreview] = useState<FileClassification[]>([]);
     
     const handleOrganize = async () => {
       setIsOrganizing(true);
       
       try {
         const results = await invoke<FileMoveResult[]>('organize_files', {
           filePaths: files,
           workspacePath: currentWorkspace,
         });
         
         onOrganize(results);
       } finally {
         setIsOrganizing(false);
       }
     };
     
     return (
       <Modal>
         <h3>智能整理文件</h3>
         <p>将根据文件内容自动分类整理以下 {files.length} 个文件</p>
         {/* 预览分类结果 */}
         <button onClick={handleOrganize} disabled={isOrganizing}>
           {isOrganizing ? '整理中...' : '开始整理'}
         </button>
       </Modal>
     );
   };
   ```

### 20.4 测试和优化（Day 7）

**任务**：测试智能分类功能并优化

**测试项**：
1. 文件内容提取是否准确
2. AI 分类是否合理
3. 批量整理是否成功
4. 性能是否满足要求

**优化项**：
1. 分类提示词优化
2. 批量处理性能优化
3. 错误处理完善

**交付物**：
- 智能分类功能完整实现
- 批量整理功能
- 测试报告
- 优化记录

---

## 关键里程碑

| 里程碑 | 时间 | 交付物 |
|--------|------|--------|
| **M4.1：文件监听优化完成** | Week 17 Day 3 | 完善的事件去重、防抖、外部修改检测 |
| **M4.2：工作区增强完成** | Week 17 Day 7 | 最近工作区列表、工作区切换 |
| **M4.3：文件操作完善** | Week 18 Day 7 | 拖拽导入、右键菜单、重命名、删除、导入 |
| **M4.4：SQLite 索引完善** | Week 19 Day 7 | 增量更新、自动索引、搜索结果优化 |
| **M4.5：AI 智能分类完成** | Week 20 Day 7 | 文件内容分析、智能分类、批量整理 |

## 风险评估和应对

### 技术风险

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|----------|
| SQLite 索引性能 | 中 | 低 | 使用批量更新、异步索引构建 |
| 文件监听事件过多 | 中 | 中 | 事件去重和防抖，过滤不必要的事件 |
| AI 分类准确率 | 高 | 中 | 优化提示词，提供手动调整选项 |
| 跨分区文件移动 | 中 | 低 | 检测分区，跨分区时复制后删除 |

### 项目风险

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|----------|
| 开发进度延后 | 中 | 中 | 设置缓冲时间，优先核心功能 |
| 功能复杂度过高 | 高 | 低 | 简化实现，先做 MVP 版本 |

---

## 总结

第四阶段开发计划重点关注文件管理系统的完善，包括：

1. **文件监听优化**：事件去重、防抖、外部修改检测
2. **工作区增强**：最近工作区列表、工作区切换
3. **文件操作增强**：拖拽导入、右键菜单、重命名、删除、导入
4. **SQLite 索引完善**：增量更新、自动索引、搜索结果优化
5. **AI 智能分类**：文件内容分析、智能分类、批量整理

所有功能都基于前三阶段的实际开发进度，确保计划的可行性和稳定性。

**方案版本**：v4.0  
**创建日期**：2025年  
**最后更新**：2025年  
**方案状态**：✅ **可执行（基于前三阶段实际进度优化版）**


