# 层次三：右侧聊天窗口功能设计文档

## 文档信息

- **文档版本**：v1.0
- **创建日期**：2025年
- **文档性质**：功能设计文档
- **功能层次**：层次三

## 格式说明

**重要**：本文档中提到的文档格式说明：
- **原生 DOCX**：Word 原生的 .docx 文件，Binder 只能预览，不能编辑
- **t-docx**：Binder 可编辑的文档格式（TipTap 模拟的 DOCX），包括：
  - Binder 生成的文档
  - 从预览模式切换到编辑模式时创建的草稿文件（如 `document.draft.docx`）
  - 所有在 Binder 编辑器中可编辑的文档

本文档中所有涉及"可编辑"、"格式匹配"、"样式继承"等场景下的 DOCX，均指 **t-docx** 格式。

---

## 一、功能定位

### 1.1 核心特性

- **完整聊天界面**：有消息列表、输入框、历史记录
- **对话式交互**：可以多轮对话，保持上下文
- **工具调用**：可以操作文档、文件等（仅 Agent 模式）
- **标签栏**：支持多个聊天会话
- **记忆库集成**：可以查看记忆项
- **模型选择**：可以切换不同的 AI 模型

### 1.2 使用场景

- 复杂问题咨询
- 多步骤任务执行
- 文档分析和处理
- 代码生成和调试
- 内容讨论和协作

### 1.3 功能边界

- **不共享**：自动补全的触发逻辑、Inline Assist 的输入框
- **共享**：当前文档内容、选中文本、系统提示词、AI 模型配置、记忆库数据

---

## 二、聊天模式

### 2.1 Agent 模式

- **功能**：AI 可以调用工具执行操作（文件操作、搜索等）
- **适用场景**：需要 AI 执行实际操作的场景
- **工具调用**：文件操作、编辑器操作等
- **确认机制**：编辑器操作需用户确认

### 2.2 Chat 模式

- **功能**：AI 仅进行对话，不调用工具
- **适用场景**：纯对话场景（咨询问题、获取建议等）
- **快捷应用**：支持快捷应用到文档功能

### 2.3 模式切换规则

- 创建新对话时可以选择模式（默认 Agent 模式）
- 聊天开始后（已有消息）不能切换模式（保持对话一致性）
- 每个标签页独立设置模式

---

## 三、提示词设计

### 3.1 多层提示词架构

#### 3.1.1 基础系统提示词（第一层，优化后）

**Agent 模式系统提示词**（简化版）：
```
你是一个专业的编程助手和文档编辑助手。

你可以帮助用户：
- 回答编程和文档相关的问题
- 执行文件操作（读取、创建、更新、删除文件等）
- 执行编辑器操作（修改文档内容等）
- 搜索和浏览网络信息（如需要外部信息）

工作模式：
你可以访问以下工具：[工具列表]

执行策略：
- **简单任务**（读取1-2个文件、修改单个文档等）：直接调用相关工具执行
- **复杂任务**（需要读取3个以上文件、浏览网站、多步骤操作等）：
  1. 先在回复中说明你的执行计划（需要读取哪些文件、浏览哪些网站、执行哪些步骤）
  2. 等待用户确认后，再按计划逐步调用工具执行
  3. 执行过程中，简要说明当前步骤和进度

工具调用格式要求（CRITICAL）：
所有工具调用必须使用严格的 JSON 格式：
```json
{"tool":"tool_name","arguments":{"key":"value"}}
```

规则：
- 所有键名和字符串值必须用双引号包裹
- JSON 必须完整闭合
- 确保格式可以被 JSON.parse() 解析
```

**Chat 模式系统提示词**：
```
你是一个专业的编程助手和文档编辑助手。
你可以帮助用户：
- 回答编程和文档相关的问题
- 提供技术建议和最佳实践
- 分析和讨论代码和文档内容
- 提供格式化和样式建议

请以友好、专业的方式回答用户的问题。

注意：Chat 模式不支持工具调用，如需执行操作，请切换到 Agent 模式。
```

**简化说明**：
- **移除独立规划工具**：不再使用 `plan_workflow` 工具，改为让 AI 在回复中自然说明计划，前端解析展示
- **简化执行流程**：AI 自行判断任务复杂度，复杂任务先说明计划，简单任务直接执行
- **JSON 规范精简**：只保留核心规则，减少冗余说明

#### 3.1.2 上下文提示词（第二层，优化后）

- **当前打开的文档**：
  - 文件路径
  - 文档内容预览（智能选择 1000 字符）
  - **文档内容预览选择规则**（优化后，P1 优先级）：
    - 如果用户消息提到文档某部分（如"第三章"、"开头部分"），优先包含该部分
    - 如果用户询问整体问题（如"总结文档"、"文档主题"），包含文档开头 + 结构大纲
    - 如果用户追问具体细节，包含光标位置附近内容（前后各 400 字符）
    - 如果文档有标题结构，优先包含当前段落所在章节的内容
    - 如果光标位置内容不足，补充文档开头内容
- **当前选中的文本**：选中内容
- **工作区路径**：工作区根目录
- **当前编辑器状态**：
  - 是否可编辑（只读/可编辑）
  - 文件类型（.md、.t-docx、.html 等）
  - 文件大小（如果 > 1MB，提示"大文件"）
  - 是否已保存（如果有未保存更改，提示"有未保存更改"）
  - **文档格式和样式信息**（重要）：
    - 当前文档格式（.txt、.t-docx、.md、.html 等）
    - 当前光标位置的样式信息（如 t-docx 中的段落样式、文本样式）
    - 选中文本的样式信息（如有选中文本）
    - **格式匹配要求**（优化后，P0 优先级）：
      - 精简为："生成内容需匹配当前 [格式] 的样式规范，保持与文档一致的格式和风格。"
      - 详细规则放入设计文档，不在提示词中重复

#### 3.1.3 引用提示词（第三层，优化后）

**引用内容格式**（精简后，P0 优先级）：
```
[用户引用内容]

以下内容由用户主动引用，已完整传递，请直接使用：

1. 文本引用（来源：[文件路径] 第 [行号范围] 行）
[引用的文本内容]

2. 文件引用（来源：[文件路径]）
[文件的完整内容]

3. 文件夹引用（来源：[文件夹路径]）
[文件夹中所有文件的列表和内容]

4. 图片引用（来源：[图片路径]）
[图片描述或说明]

5. 记忆库引用（来源：记忆库 - [记忆库名称]）
[记忆项内容]

6. 聊天记录引用（来源：[标签页名称]，消息 1-3，[时间戳]）
[聊天记录内容，包含标签页标题、消息角色、消息内容、时间戳]

7. 链接引用（来源：[URL]）
[链接描述]

注意：这些内容无需通过 read_file 工具再次读取。
```

**优化说明**：
- **精简格式**：使用序号 + 类型 + 来源的格式，不再对每种类型单独说明
- **统一说明**：在末尾统一说明"无需通过 read_file 工具再次读取"，避免重复

#### 3.1.4 工具调用提示词（第四层，仅 Agent 模式，优化后）

- **工具列表和说明**：每个工具的功能和参数
- **工具调用格式**（优化后，P0 优先级）：
  ```json
  {
    "tool": "工具名称",
    "arguments": {
      "参数名": "参数值"
    }
  }
  ```
  
  注意：JSON 格式规范已在系统提示词中说明，此处不再重复。

- **工具调用策略**（简化后）：
  - **简单任务**：直接调用工具，无需提前说明计划
  - **复杂任务**：AI 在回复中说明计划，前端解析并展示给用户确认，确认后按计划执行
  - **工具调用链**：按顺序执行，每个工具调用完成后继续下一个

**简化说明**：
- **移除 `plan_workflow` 工具**：不再需要专门的规划工具，AI 在自然回复中说明计划即可
- **前端解析计划**：前端从 AI 回复中提取计划信息（文件列表、网站列表、步骤描述），展示给用户
- **降低复杂度**：减少工具类型，简化状态管理，提高稳定性

### 3.2 提示词构建逻辑（简化后）

- **根据聊天模式（Agent/Chat）动态构建**：
  - Agent 模式：包含工具调用规范、工具列表（移除独立的规划工具要求）
  - Chat 模式：不包含工具相关提示词
- **根据是否有引用内容动态添加引用提示词**：
  - 使用精简的引用格式（序号 + 类型 + 来源）
  - 统一在末尾说明"无需通过 read_file 工具再次读取"
- **根据当前文档状态动态添加上下文提示词**：
  - 智能选择文档内容预览（根据用户消息类型，通过提示词让 AI 自行判断）
  - 精简格式匹配要求（只说明格式类型，详细规则放入文档）
- **JSON 规范统一**：
  - 仅在 Agent 模式系统提示词中说明一次
  - 保持简洁，避免重复

### 3.3 内容限制（优化后）

- **上下文长度**：智能选择，控制在合理范围内
  - **动态调整**（P1 优先级）：根据对话长度和复杂度动态调整
  - **优先保留**：最近的对话和关键信息
  - **上下文压缩**（P2 优先级）：智能压缩上下文，保留关键信息
- **引用内容**：完整传递，不截断
- **工具定义**：仅在 Agent 模式时包含
- **对话连贯性**（P1 优先级）：
  - 保持对话主题一致性
  - 明确对话历史的处理方式
  - 支持对话摘要（P2 优先级）：长对话历史自动摘要
- **格式和样式匹配**（重要，优化后）：
  - **格式识别**：自动识别当前编辑文档的格式（.txt、.t-docx、.md、.html 等）
  - **样式匹配要求**（精简后，P0 优先级）：
    - 在提示词中精简为："生成内容需匹配当前 [格式] 的样式规范，保持与文档一致的格式和风格。"
    - **详细规则**（放入设计文档，不在提示词中重复）：
      - **TXT 格式**：生成纯文本内容，无格式标记
      - **t-docx 格式**：生成内容需匹配 t-docx 样式（标题、粗体、斜体、列表、段落对齐等），保持与当前文档一致的格式
      - **Markdown 格式**：生成内容可包含 Markdown 语法（标题、列表、代码块、链接等），保持与上下文风格一致
      - **HTML 格式**：生成内容可包含 HTML 标签和样式，保持与上下文风格一致
  - **样式继承规则**（P1 优先级）：
    - 继承段落的样式（字体、大小、颜色等）
    - 继承列表的样式（编号、符号）
    - 继承标题的样式（层级、格式）
    - 快捷应用到文档时，继承当前光标位置的样式
  - **提示词增强**：在上下文提示词中明确说明当前文档格式和样式要求（精简版）
  - **工具调用格式控制**：工具调用（如 `edit_current_editor_document`）生成的内容需匹配当前文档格式

---

## 四、工作逻辑结构

### 4.1 前端工作流程

```
用户打开聊天窗口
    ↓
创建/选择聊天标签页
    ↓
选择模式（Agent/Chat）
    ↓
用户输入消息（可添加引用）
    ↓
构建多层提示词
    ↓
调用后端 ai_chat_stream
    ↓
流式显示 AI 响应文本
    ↓
[复杂任务检测]（简化后）：
  - 前端解析 AI 回复，检测是否包含执行计划（文件列表、网站列表、步骤描述）
  - 如检测到计划，展示计划卡片给用户确认
  - 用户确认后，AI 继续执行工具调用
    ↓
[Agent 模式] 处理工具调用
    ↓
[工具调用] 执行工具 → 显示结果 → 继续对话
    ↓
[文档修改] 显示 Diff 视图 → 用户确认 → 应用到编辑器
    ↓
流式显示完成
```

### 4.2 后端工作流程

```
接收请求（tab_id, messages, model_config, enable_tools, context）
    ↓
选择 AI 提供商（优先 DeepSeek，其次 OpenAI）
    ↓
构建增强消息列表（添加 JSON 格式规范，仅 Agent 模式）
    ↓
构建多层提示词
    ↓
调用 AI 流式接口
    ↓
流式返回响应：
  - Text chunk → 发送给前端
  - Tool call chunk → 处理工具调用
    ↓
[工具调用处理]（简化后）：
解析工具调用参数（基础 JSON 修复，主要依赖提示词规范）
    ↓
发送工具调用状态给前端（pending → executing）
    ↓
执行工具调用：
  - 文件操作（read_file、create_file、update_file 等）
  - 网络操作（web_search、browse_website 等）
  - 编辑器操作（edit_current_editor_document 等）
    ↓
发送工具调用结果给前端（completed/failed）
    ↓
继续对话（将结果添加到消息中）
    ↓
流式返回最终响应文本
```

### 4.3 工作规划和执行展示（简化后）

#### 4.3.1 工作规划展示（简化实现）

**实现方式**（简化后）：
- **前端解析 AI 回复**：从 AI 的文本回复中提取计划信息
  - 检测关键词："需要读取以下文件"、"执行步骤"、"计划"等
  - 使用正则表达式或简单解析提取文件列表、网站列表、步骤描述
  - 如果 AI 回复中包含结构化计划信息，解析并展示
- **展示内容**（简化版）：
  - **计划卡片**：显示 AI 说明的执行计划（文件列表、网站列表、步骤描述）
  - **确认按钮**：用户点击"开始执行"后，AI 继续执行工具调用
  - **无需复杂状态管理**：计划信息临时展示，确认后清除，不持久化

**优势**：
- **降低复杂度**：不需要专门的 `plan_workflow` 工具，不需要复杂的状态管理
- **提高稳定性**：减少工具调用失败的风险，AI 自然回复更可靠
- **更灵活**：AI 可以根据实际情况调整计划说明的详细程度

#### 4.3.2 工具调用执行展示（简化后）

**展示内容**：
- **工具调用卡片**：
  - 显示工具名称和图标
  - 显示工具调用状态：pending → executing → completed/failed
  - 显示工具调用结果（成功/失败、结果摘要）
  - 支持展开/折叠查看详情
- **简化进度反馈**：
  - 显示当前正在执行的工具
  - 显示已完成/总工具调用数（如可统计）
  - 不强制要求预计剩余时间（难以准确估算）

**交互功能**：
- **工具调用展开/折叠**：查看工具调用详情
- **取消执行**：取消正在执行的工具调用（如支持）
- **重试失败工具**：重新执行失败的工具调用

#### 4.3.3 状态管理（简化后）

- **Store 状态**：`useChatStore` 管理聊天状态
- **状态字段**（简化后）：
  - `tabs`（标签页列表）
  - `activeTabId`（活动标签页）
  - `messages`（消息列表）
  - `toolCalls`（工具调用列表，按消息分组）
  - **移除**：`workPlan`、`executionSteps`（不再需要独立的状态管理）
- **状态更新**：响应流式事件和用户操作
- **会话持久化**（重要功能，保持不变）：
  - 会话序列化/反序列化（`ISerializableChatData`）
  - 会话存储到工作区（需求明确："聊天记录绑定到工作区"）
  - 支持会话加载和恢复
  - 避免数据丢失，提升用户体验
  - 限制最大持久化会话数（如 25 个），自动清理旧会话

---

## 五、引用系统

### 5.1 支持引用类型

- **文本引用**：复制文档内容，自动识别来源文件和行号
- **文件引用**：拖拽文件到聊天窗口，或使用 `@文件名` 语法
- **文件夹引用**：拖拽文件夹到聊天窗口
- **图片引用**：拖拽图片到聊天窗口
- **表格引用**：选中表格并引用
- **记忆库引用**：使用 `@记忆库名称` 语法
- **聊天记录引用**：引用其他聊天标签页的聊天内容（支持跨标签页引用）
- **链接引用**：自动识别用户输入或复制的 URL

### 5.2 引用功能

- **引用管理器**：可视化管理所有引用
- **引用标签显示**：在输入框中显示引用标签
- **引用内容传递**：完整内容传递给 AI（不是路径）
- **变量解析进度通知**（可选优化）：
  - 引用解析进度反馈（解析文件、提取内容等）
  - 长时间解析操作显示进度
  - 提升用户体验，减少等待焦虑
  - 注意：引用解析通常很快，此功能非核心，可在引用系统完善后考虑

### 5.3 聊天内容引用（重点功能）

- **跨标签页引用**：Agent 模式和 Chat 模式都可以引用其他聊天标签页的内容
- **引用方式**：复制粘贴引用、拖拽引用、引用管理器
- **引用显示**：显示来源标签页标题和消息范围
- **引用内容格式化**：包含标签页标题、消息角色、消息内容、时间戳

---

## 六、工具调用功能（仅 Agent 模式）

### 6.1 文件操作工具

- `read_file`：读取文件内容
- `create_file`：创建文件
- `update_file`：更新文件
- `delete_file`：删除文件
- `list_files`：列出目录
- `search_files`：搜索文件
- `move_file`：移动文件
- `rename_file`：重命名
- `create_folder`：创建文件夹

### 6.2 编辑器操作工具

- `edit_current_editor_document`：编辑当前打开的文档（需用户确认）

### 6.3 互联网信息获取工具（未来扩展）

- `web_search`：网络搜索工具（搜索互联网信息）
- `browse_website`：浏览网页工具（获取网页内容）
- `fetch_url`：获取 URL 内容工具（获取特定 URL 的内容）
- **使用场景**：查询最新信息、技术文档、实时数据等
- **注意事项**：需要用户授权，需要错误处理和内容验证

### 6.3 工具调用特性

- **自动执行**：文件操作自动执行（无需确认）
- **用户确认**：编辑器操作需用户确认
- **状态显示**：实时显示工具调用状态（pending/executing/completed/failed）
- **JSON 修复**（简化后）：
  - 主要依赖提示词规范，减少复杂的修复逻辑
  - 只处理最常见的错误（缺少引号、未闭合括号）
  - 修复失败时给出明确错误提示，不强制修复
- **工具调用取消机制**（简化后）：
  - 支持取消正在执行的工具调用（如后端支持）
  - 不强制要求复杂的取消状态管理
- **工具注册和发现机制**（保持）：
  - 统一的工具注册表，便于管理和扩展
  - 工具权限控制（哪些工具需要确认）
  - 便于未来添加新工具
- **权限控制**（简化后）：
  - 工具权限分级（只读、读写、危险）
  - 危险操作需要用户明确确认
  - 不强制要求权限审计日志（可后续扩展）

---

## 七、文档修改可视化功能（仅 Agent 模式）

### 7.1 可视化展示

- **Diff 视图**：红绿标注（删除用红色，添加用绿色）
- **对比级别**：行级别对比、段落级别对比、文档级别对比
- **显示位置**：在编辑区实现 diff 效果（重要：Diff 视图应在编辑器中显示）

### 7.2 多层确认机制

- **段落级别确认**：每个修改段落有独立的确认按钮
- **文档级别确认**：每个被修改的文档有确认按钮
- **全部确认**：一次性确认所有修改
- **跳过功能**：支持跳过段落、跳过文档
- **多种编辑策略**（可选优化）：
  - **实时编辑策略**（LiveStrategy）：实时应用修改，无需确认
  - **预览编辑策略**（PreviewStrategy）：显示预览，用户确认后应用（当前实现）
  - **渐进式编辑策略**：逐步应用修改，支持部分应用
  - 根据场景选择策略，提升用户体验
  - 注意：当前 Diff 视图已满足需求，多种策略可在未来根据用户反馈决定是否实现

---

## 八、快捷应用到文档功能（Chat 模式重点功能）

### 8.1 功能定位

- Chat 模式中，AI 回答的内容可能包含可以直接应用到文档的内容
- 提供快捷方式，让用户快速将聊天内容应用到当前文档

### 8.2 应用方式

- **插入到光标位置**：将内容插入到编辑器光标位置
- **替换选中文本**：如果有选中文本，替换为聊天内容
- **追加到文档末尾**：将内容追加到文档末尾
- **应用到工作区文档**：如果工作区中存在同名文档，直接应用；如果不存在，创建新文档

### 8.3 智能内容识别

- **代码块识别**：使用 Markdown 代码块语法
- **文本段落识别**：按空行分割，每个段落作为一个可选项
- **列表识别**：识别 Markdown 列表语法
- **部分应用**：用户可以选择应用全部内容或部分内容
- **格式和样式匹配**（重要）：
  - **格式识别**：识别 AI 生成内容的格式（Markdown、HTML、纯文本等）
  - **格式转换**：根据当前文档格式转换 AI 生成的内容
    - 如果当前文档是 t-docx，将 Markdown 或 HTML 转换为 t-docx 支持的样式
    - 如果当前文档是 TXT，去除所有格式标记，保留纯文本
    - 如果当前文档是 Markdown，保留或转换为 Markdown 语法
  - **样式继承**：应用内容时继承当前光标位置的样式（如 t-docx 中的段落样式）

### 8.4 应用预览

- **Diff 视图**：应用前显示预览（Diff 视图）
- **部分应用选择**：用复选框标记每个可应用的段落，用户可以选择

---

## 九、流式响应处理

### 9.1 流式响应机制

- **前端和后端双重去重**：避免重复内容
- **累积文本跟踪**：跟踪每个 tab 的累积文本
- **空 chunk 过滤**：跳过空事件
- **工具调用实时处理**：实时处理工具调用
- **智能 Chunk 分割**（优化）：
  - 按句子边界分割（句号、问号、感叹号等），避免在单词中间分割
  - 支持 offset 跟踪，避免重复解析
  - 提升流式显示的流畅度和可读性
  - 避免在单词中间断开，影响阅读体验

### 9.2 去重机制

- **后端去重**：累积文本跟踪，跳过重复 chunk
- **前端去重**：`accumulatedTextRef` 跟踪每个 tab 的累积文本
- **空 chunk 过滤**：跳过空事件，避免日志污染

---

## 十、性能要求

### 10.1 响应时间

- **首次响应**：< 3 秒
- **流式显示延迟**：< 100ms
- **工具调用响应**：< 2 秒
- **进度反馈**（用户体验优化）：
  - 详细的进度指示（百分比、阶段）
  - 工具调用进度显示（pending/executing/completed）
  - 长时间操作显示预计剩余时间
  - 可取消的操作提供取消按钮
  - 提升用户体验，减少等待焦虑

### 10.2 资源占用

- **内存占用**：< 100MB（聊天历史）
- **CPU 占用**：< 50%（AI 处理）

---

## 十一、错误处理

### 11.1 错误类型

- **网络错误**：连接失败、超时
- **API 错误**：API Key 无效、配额不足
- **工具调用错误**：工具执行失败、参数错误
- **JSON 解析错误**：工具调用参数格式错误
- **错误级别分类**：
  - **Error**：严重错误，影响功能使用（API Key 无效、网络连接失败、工具执行失败等）
  - **Warning**：警告信息，功能可用但可能有问题（配额不足、响应超时、工具调用部分失败等）
  - **Info**：提示信息，不影响功能（响应被过滤、部分内容未返回、工具调用被取消等）

### 11.2 处理策略

- **JSON 修复机制**：自动修复工具调用参数的 JSON 格式错误
- **错误提示优化**：友好的错误提示和解决建议
  - 不同错误级别采用不同的提示方式（Error 显示错误提示，Warning 显示警告，Info 显示提示）
  - 提供具体的错误原因和解决建议
  - 支持错误恢复操作（重试、跳过、取消等）
- **自动重试**：网络错误自动重试（最多 3 次，指数退避）
- **错误详情扩展**：
  - 检测响应是否不完整（`responseIsIncomplete`）
  - 检测响应是否被过滤（`responseIsFiltered`）
  - 检测配额是否超限（`isQuotaExceeded`）
  - 提供更详细的错误信息，帮助用户理解问题

---

## 十二、配置选项

### 12.1 可配置项

- **模型选择**：用户可为每个标签页选择不同模型
- **模式选择**：创建新对话时选择 Agent 或 Chat 模式
- **引用管理**：引用管理器的显示和操作

### 12.2 模型选择

- **支持的模型**：DeepSeek Chat、OpenAI GPT-4 等
- **选择策略**：用户可选择，每个标签页独立

---

## 十三、边界情况处理

### 13.1 特殊场景

- **编辑器未打开文档**：快捷应用到文档功能仍可用（创建新文档）
- **大工作区**：工具调用性能优化，避免超时
- **长对话历史**：性能优化，避免内存占用过高
- **多标签页**：每个标签页独立，互不干扰
- **工具调用失败**：显示错误信息，允许用户重试或跳过
- **流式响应中断**：网络中断时保存已接收内容，支持继续

### 13.2 冲突处理

- **多标签页同时请求**：每个标签页独立处理，不相互阻塞
- **工具调用冲突**：编辑器操作需用户确认，避免冲突
- **引用内容过大**：自动截断或提示用户

---

## 十四、技术实现细节

### 14.1 前端实现

- **组件**：`ChatPanel.tsx`（主聊天面板）
- **子组件**：
  - `ChatTabs.tsx`（标签栏）
  - `ChatMessageList.tsx`（消息列表）
  - `InlineChatInput.tsx`（输入框，支持引用）
  - `ReferenceManagerButton.tsx`（引用管理器）
  - `ReferenceTags.tsx`（引用标签显示）
  - `QuickApplyButton.tsx`（快捷应用到文档按钮）
  - `ToolCallCard.tsx`（工具调用卡片）
  - `DocumentDiffView.tsx`（文档修改 Diff 视图）
  - `ModelSelector.tsx`（模型选择）
  - `MemoryTab.tsx`（记忆库标签）
    - **工作规划和执行展示组件**（简化后）：
      - `WorkPlanCard.tsx`（工作规划卡片，简化版）
        - 从 AI 回复中解析并显示执行计划
        - 显示需要读取的文档列表（如 AI 提到）
        - 显示需要浏览的网站列表（如 AI 提到）
        - 显示执行步骤描述（如 AI 说明）
        - 支持用户确认后继续执行
        - **无需复杂的状态管理**：计划信息临时展示，确认后清除
      - `ToolCallCard.tsx`（工具调用卡片，已存在，优化）
        - 显示工具名称和图标
        - 显示工具调用状态（pending/executing/completed/failed）
        - 显示工具调用参数（可展开）
        - 显示工具调用结果
        - 支持展开/折叠查看详情
        - **移除**：复杂的步骤状态管理、进度条等

### 14.2 后端实现

- **命令**：`ai_chat_stream`
- **服务**：`AIService::chat_stream`
- **提供商**：`DeepSeekProvider`、`OpenAIProvider`
- **工具执行**：`ToolExecutor`（执行工具调用）

### 14.3 数据流

```
用户输入 → 构建提示词 → 后端 ai_chat_stream → AI 服务 → 流式返回 → 前端显示
    ↓
[Agent 模式] 工具调用 → 执行工具 → 返回结果 → 继续对话
    ↓
[文档修改] Diff 视图 → 用户确认 → 应用到编辑器
```

### 14.4 状态管理

- **Store**：`useChatStore`（Zustand）
- **状态字段**：
  - `tabs`：标签页列表
  - `activeTabId`：当前活动标签页 ID
  - `messages`：消息列表（按 tab_id 分组）
  - `references`：引用列表
  - `toolCalls`：工具调用列表（按消息分组）
  - **移除**：`workPlan`、`executionSteps`（不再需要独立的状态管理）
- **状态更新**：响应流式事件、用户操作、工具调用结果
- **工作规划处理**（简化后）：
  - 前端从 AI 回复中临时解析计划信息，展示给用户
  - 用户确认后，计划信息清除，AI 继续执行
  - 不持久化计划状态，降低复杂度

---

## 十五、测试要点

### 15.1 功能测试

- **聊天功能**：多轮对话、上下文保持、流式显示
- **工具调用**：文件操作、编辑器操作、确认机制
- **引用系统**：各种引用类型、跨标签页引用
- **快捷应用**：Chat 模式快捷应用到文档
- **模式切换**：Agent/Chat 模式切换规则
- **工作规划和执行**（简化后）：
  - 计划解析：测试前端能否正确从 AI 回复中解析计划信息
  - 计划展示：测试工作规划卡片是否正确显示
  - 工具调用链：测试多步骤工具调用是否正确执行
  - 取消执行：测试取消功能是否正常工作（如支持）
  - 重试失败工具：测试重试功能是否正常工作

### 15.2 性能测试

- **响应时间**：首次响应、流式显示延迟、工具调用响应
- **资源占用**：内存占用、CPU 占用
- **并发测试**：多标签页同时请求、工具调用并发

### 15.3 边界测试

- **大工作区**：工具调用性能
- **长对话历史**：内存占用和性能
- **网络中断**：流式响应中断处理
- **工具调用失败**：错误处理和重试机制

---

## 十六、后续优化方向（基于分析文档）

### 16.1 功能优化（按优先级）

#### 16.1.1 P0 优先级（高优先级，必须实现，已简化）

- ✅ **工作规划逻辑简化**：移除独立的 `plan_workflow` 工具，改为 AI 在回复中自然说明计划，前端解析展示
- ✅ **JSON 规范精简**：统一在系统提示词中说明，保持简洁
- ✅ **引用提示词精简**：合并"无需再读"说明，使用精简格式（序号 + 类型 + 来源）
- ✅ **格式匹配要求精简**：精简为"匹配当前 [格式] 的样式规范"，详细规则放入文档
- ✅ **状态管理简化**：移除 `workPlan`、`executionSteps` 等复杂状态，降低复杂度

#### 16.1.2 P1 优先级（中优先级，建议实现）

- ⚠️ **文档内容预览规则优化**：根据用户消息类型智能选择（提到某部分 → 包含该部分；整体问题 → 开头+大纲；具体细节 → 光标附近）
- ⚠️ **对话连贯性优化**：保持对话主题一致性，明确对话历史的处理方式
- ⚠️ **上下文管理优化**：动态调整上下文长度，优先保留最近的对话和关键信息
- ⚠️ **样式继承规则明确**：明确样式继承的具体规则（段落、列表、标题样式）
- ⚠️ **引用系统**：完善聊天内容引用功能（拖拽引用、引用管理器扩展）
- ⚠️ **快捷应用**：优化内容识别算法，支持更多格式
- ⚠️ **工具调用**：扩展工具类型，支持更多操作
- ⚠️ **文档修改可视化**：优化 Diff 视图，提升用户体验
- ⚠️ **工作规划和执行优化**（简化后）：
  - 优化计划解析算法：提升从 AI 回复中提取计划信息的准确性
  - 优化计划展示：提升计划卡片的可视化效果
  - 优化工具调用展示：提升工具调用卡片的信息展示

#### 16.1.3 P2 优先级（低优先级，可选实现）

- 📋 **对话摘要**：长对话历史自动摘要
- 📋 **上下文压缩**：智能压缩上下文，保留关键信息
- 📋 **个性化提示词**：根据用户偏好调整提示词
- 📋 **并行执行**：允许无依赖关系的步骤并行执行
- 📋 **步骤回滚**：支持回滚已执行的步骤

### 16.2 性能优化

- **流式响应**：优化去重机制，减少重复处理
- **工具调用**：优化 JSON 修复算法，提升成功率
- **大工作区**：优化文件搜索和操作性能
- **长对话历史**：实现消息分页或虚拟滚动
- **上下文管理**：优化上下文提取和处理性能（P1 优先级）

### 16.3 用户体验优化

- **错误提示**：更友好的错误提示和解决建议
- **加载状态**：优化加载状态显示
- **快捷键**：增加更多快捷键支持
- **界面优化**：优化 UI 布局和交互
- **工作规划展示**：优化工作规划的可视化效果（P1 优先级）
- **执行进度反馈**：详细的进度指示和预计剩余时间（P1 优先级）

### 16.4 实施建议

**第一阶段（P0，已简化）**：
- 简化工作规划逻辑（移除独立工具，改为 AI 自然说明 + 前端解析）
- 精简 JSON 规范（统一在系统提示词中，保持简洁）
- 精简引用提示词（使用精简格式）
- 精简格式匹配要求（详细规则放入文档）
- 简化状态管理（移除复杂的工作规划状态）

**第二阶段（P1）**：
- 优化记忆库检索算法，提高相关性
- 优化文档内容预览规则（通过提示词让 AI 根据用户消息类型智能选择）
- 优化对话连贯性（通过提示词让 AI 保持主题一致性）
- 优化上下文管理（动态调整长度，充分利用记忆库）
- 明确样式继承规则（从编辑器状态提取）
- 优化工作规划和执行展示

**第三阶段（P2）**：
- 实现对话摘要（保存到记忆库）
- 实现上下文压缩（利用记忆库存储关键信息）
- 实现个性化提示词（根据记忆库中的用户偏好调整）
- 支持并行执行和步骤回滚

---

## 十七、简化优化总结

### 17.1 主要简化点

#### 17.1.1 工作规划机制简化

**原设计**：
- 使用独立的 `plan_workflow` 工具
- 需要复杂的状态管理（`workPlan`、`executionSteps`）
- 需要专门的工具调用和确认流程

**简化后**：
- **移除 `plan_workflow` 工具**：不再需要专门的规划工具
- **AI 自然说明计划**：AI 在回复中自然说明执行计划（文件列表、网站列表、步骤描述）
- **前端解析展示**：前端从 AI 回复中提取计划信息，展示给用户确认
- **简化状态管理**：计划信息临时展示，确认后清除，不持久化

**优势**：
- ✅ **降低复杂度**：减少工具类型，简化状态管理
- ✅ **提高稳定性**：减少工具调用失败的风险，AI 自然回复更可靠
- ✅ **更灵活**：AI 可以根据实际情况调整计划说明的详细程度
- ✅ **更易维护**：减少代码量，降低 bug 风险

#### 17.1.2 提示词架构简化

**原设计**：
- 四层提示词架构（系统、上下文、引用、工具调用）
- 多处重复 JSON 规范说明
- 复杂的工作规划要求

**简化后**：
- **精简系统提示词**：移除独立的规划工具要求，改为自然说明策略
- **统一 JSON 规范**：只在系统提示词中说明一次，保持简洁
- **减少冗余**：合并重复内容，精简格式要求

**优势**：
- ✅ **减少 token 消耗**：更短的提示词，更快的响应
- ✅ **提高可读性**：AI 更容易理解核心要求
- ✅ **降低维护成本**：减少需要同步更新的地方

#### 17.1.3 JSON 修复机制简化

**原设计**：
- 复杂的 JSON 修复算法
- 多层修复尝试
- 可能引入新的错误

**简化后**：
- **主要依赖提示词规范**：通过提示词要求 AI 输出正确格式
- **只处理常见错误**：缺少引号、未闭合括号等
- **失败时明确提示**：修复失败时给出明确错误信息，不强制修复

**优势**：
- ✅ **减少代码复杂度**：简化修复逻辑
- ✅ **提高可靠性**：减少修复引入新错误的可能性
- ✅ **更易调试**：错误信息更清晰

#### 17.1.4 状态管理简化

**原设计**：
- `workPlan`：复杂的工作规划对象
- `executionSteps`：执行步骤状态列表
- 需要同步更新多个状态字段

**简化后**：
- **移除独立状态**：不再需要 `workPlan`、`executionSteps`
- **临时解析展示**：计划信息从 AI 回复中临时解析，展示后清除
- **只保留核心状态**：`messages`、`toolCalls` 等核心状态

**优势**：
- ✅ **降低状态管理复杂度**：减少状态字段，降低同步问题
- ✅ **提高性能**：减少状态更新开销
- ✅ **更易测试**：状态结构更简单，测试更容易

### 17.2 稳定性提升

1. **减少工具调用失败点**：
   - 移除 `plan_workflow` 工具，减少工具调用失败的可能性
   - AI 自然回复更可靠，不依赖工具调用的成功

2. **简化错误处理**：
   - JSON 修复逻辑简化，减少修复失败的风险
   - 错误信息更清晰，便于用户理解和处理

3. **降低状态同步问题**：
   - 减少状态字段，降低状态不一致的风险
   - 计划信息临时处理，不持久化，避免状态污染

### 17.3 鲁棒性提升

1. **更灵活的规划展示**：
   - AI 可以根据实际情况调整计划说明的详细程度
   - 即使 AI 没有严格按照格式说明计划，前端也能部分解析展示

2. **降级处理**：
   - 如果计划解析失败，用户仍可以继续对话，AI 会继续执行
   - 不强制要求完美的计划格式

3. **向后兼容**：
   - 简化后的设计不影响现有功能
   - 工具调用、文档修改等核心功能保持不变

### 17.4 实现建议

**开发优先级**：
1. **P0（必须）**：移除 `plan_workflow` 工具，更新提示词，简化状态管理
2. **P1（建议）**：实现前端计划解析和展示，优化工具调用展示
3. **P2（可选）**：优化计划解析算法，提升可视化效果

**注意事项**：
- 保持功能需求不变，只简化实现方式
- 确保向后兼容，不影响现有功能
- 充分测试，确保简化后的实现稳定可靠

---

**文档版本**：v1.1（简化优化版）  
**创建日期**：2025年  
**维护者**：Binder 开发团队