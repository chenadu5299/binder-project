# 提示词功能优化开发计划

## 文档信息

- **文档版本**：v1.0
- **创建日期**：2025年
- **文档性质**：开发计划文档
- **基于文档**：
  - 层次一-自动补全功能设计文档
  - 层次二-InlineAssist功能设计文档
  - 层次三：右侧聊天窗口功能设计文档
  - Binder AI 提示词完整文档
  - AI基础功能设计文档

---

## 一、开发目标

### 1.1 核心目标

1. **优化提示词构建逻辑**：根据设计文档实现增强的提示词构建
2. **集成记忆库支持**：充分利用记忆库提供术语、风格偏好、主题信息
3. **提示词驱动分析**：通过提示词让 AI 自行分析结构、语义、风格，减少技术实现复杂度
4. **编辑器状态利用**：从 TipTap 编辑器状态提取结构信息，无需独立解析

### 1.2 优化原则

1. **提示词驱动**：可以通过提示词让 AI 进行分析判断决策的部分交由 AI 处理
2. **充分利用记忆库**：从记忆库获取术语、风格偏好、主题信息，减少 AI 分析负担
3. **简化技术实现**：利用现有资源（编辑器状态、记忆库），避免复杂的技术实现

---

## 二、开发任务分解

### 2.1 层次一（自动补全）提示词优化

#### 任务 1.1：上下文提取增强（P0 优先级）

**目标**：实现下文提取，增强上下文信息

**前端改动**：
- **文件**：`src/hooks/useAutoComplete.ts`
- **改动内容**：
  1. 提取下文（光标后 100-200 字符）
     - 在 `trigger` 函数中，提取光标后内容
     - 优先在段落边界、句子边界截断
     - 检查是否有下文（光标不在文档末尾）
  2. 动态调整上文长度（300-500 字符）
     - 根据场景类型动态调整（简单/中等/复杂）
     - 优先在段落边界截断
  3. 传递上下文给后端
     - 修改 `ai_autocomplete` 调用，传递 `context_before` 和 `context_after`

**后端改动**：
- **文件**：`src-tauri/src/commands/ai_commands.rs`
- **改动内容**：
  1. 修改 `ai_autocomplete` 函数签名
     ```rust
     pub async fn ai_autocomplete(
         context_before: String,  // 上文
         context_after: Option<String>,  // 下文（可选）
         position: usize,
         max_length: usize,
         service: State<'_, AIServiceState>,
     ) -> Result<Option<String>, String>
     ```
  2. 传递参数给 provider
     - 修改 `AIService::autocomplete` 和 provider 接口

**测试要点**：
- 测试下文提取（光标不在文档末尾）
- 测试无下文场景（光标在文档末尾）
- 测试段落边界截断
- 测试动态长度调整

**预计工作量**：2 天

---

#### 任务 1.2：编辑器状态提取（P0 优先级）

**目标**：从 TipTap 编辑器状态提取结构信息

**前端改动**：
- **文件**：`src/hooks/useAutoComplete.ts`
- **改动内容**：
  1. 提取编辑器状态信息
     - 从 `editor.state` 提取当前节点类型（段落、标题、列表等）
     - 提取标题层级（h1, h2, h3 等）
     - 提取列表层级和类型（有序/无序）
     - 提取段落类型（普通段落、引用、代码块等）
  2. 构建编辑器状态对象
     ```typescript
     interface EditorState {
       nodeType: string;  // 当前节点类型
       headingLevel?: number;  // 标题层级（如有）
       listType?: 'ordered' | 'unordered';  // 列表类型（如有）
       listLevel?: number;  // 列表层级（如有）
       blockType?: string;  // 块类型（段落、引用、代码块等）
     }
     ```
  3. 传递编辑器状态给后端
     - 修改 `ai_autocomplete` 调用，传递 `editor_state`

**后端改动**：
- **文件**：`src-tauri/src/commands/ai_commands.rs`
- **改动内容**：
  1. 添加编辑器状态参数
     ```rust
     pub struct EditorState {
         pub node_type: String,
         pub heading_level: Option<u32>,
         pub list_type: Option<String>,
         pub list_level: Option<u32>,
         pub block_type: Option<String>,
     }
     ```
  2. 在提示词构建中使用编辑器状态
     - 构建结构信息提示词部分

**测试要点**：
- 测试不同节点类型的提取（段落、标题、列表、代码块）
- 测试标题层级提取
- 测试列表层级提取
- 测试边界情况（无结构信息）

**预计工作量**：3 天

---

#### 任务 1.3：记忆库集成（P1 优先级）

**目标**：从记忆库获取相关术语、风格偏好、主题信息

**前端改动**：
- **文件**：`src/hooks/useAutoComplete.ts`
- **改动内容**：
  1. 调用记忆库检索 API
     - 使用 `search_memories` 命令检索相关记忆
     - 检索关键词：文档路径、上下文关键词、主题等
     - 最多获取 3-5 条相关记忆
  2. 过滤和排序记忆项
     - 根据相关性排序
     - 过滤不相关的记忆
  3. 传递记忆库信息给后端
     - 修改 `ai_autocomplete` 调用，传递 `memory_items`

**后端改动**：
- **文件**：`src-tauri/src/commands/ai_commands.rs`
- **改动内容**：
  1. 添加记忆库参数
     ```rust
     pub struct MemoryItem {
         pub id: String,
         pub entity_name: String,
         pub content: String,
         pub entity_type: String,
     }
     ```
  2. 在提示词构建中使用记忆库信息
     - 构建记忆库信息提示词部分
     - 明确标注信息来源为"记忆库"

**测试要点**：
- 测试记忆库检索（有相关记忆）
- 测试无记忆库信息场景
- 测试记忆库信息在提示词中的格式
- 测试记忆库信息对续写质量的影响

**预计工作量**：3 天

---

#### 任务 1.4：提示词构建优化（P0 优先级）

**目标**：根据设计文档构建增强的提示词

**后端改动**：
- **文件**：`src-tauri/src/services/ai_providers/deepseek.rs` 和 `openai.rs`
- **改动内容**：
  1. 创建提示词构建函数
     ```rust
     fn build_autocomplete_prompt(
         context_before: &str,
         context_after: Option<&str>,
         editor_state: &EditorState,
         memory_items: &[MemoryItem],
         document_format: &str,
         max_length: usize,
     ) -> (String, String)  // (system_prompt, user_prompt)
     ```
  2. 构建系统提示词
     - 角色定义："你是一个专业的写作助手，帮助用户续写内容。"
     - 格式要求：根据文档格式动态生成
  3. 构建用户提示词
     - 上下文内容（上文、下文）
     - 结构信息（从编辑器状态提取）
     - 记忆库信息（术语、风格偏好、主题信息）
     - 续写要求（明确要求 AI 自行分析语义、风格、连贯性）
  4. 更新 `autocomplete` 方法
     - 使用新的提示词构建函数
     - 替换原有的简单字符串拼接

**提示词结构**：
```
[系统提示词]
你是一个专业的写作助手，帮助用户续写内容。

当前文档格式：[格式类型]
格式要求：[根据格式类型动态生成]

[用户提示词]
上文：[光标前 300-500 字符]
下文：[光标后 100-200 字符]（如有）

[结构信息]
当前位置：[章节/段落/列表位置]
文档结构：[简要结构信息]

[记忆库信息]（如有）
术语：[相关术语列表]
风格偏好：[风格偏好信息]
主题信息：[主题信息]

[续写要求]
基于以上上下文，续写接下来的内容（50-150 字，以完整句子或完整语义单元结尾）：
- 请自行分析文档的语义、风格、连贯性
- 保持与上文的语义连贯
- 如果下文有内容，确保续写与下文自然衔接
- 保持文档结构的完整性
- 保持主题和情感的一致性
- 保持人物性格和语言风格的一致性（文学创作）
- 保持术语和概念的一致性（参考记忆库中的术语）
- 匹配当前文档格式和样式
```

**测试要点**：
- 测试不同格式的提示词构建（TXT、t-docx、Markdown、HTML）
- 测试有无下文、有无记忆库信息的场景
- 测试提示词长度和格式
- 测试续写质量提升

**预计工作量**：4 天

---

### 2.2 层次二（Inline Assist）提示词优化

#### 任务 2.1：无选中文本支持（P0 优先级）

**目标**：支持无选中文本的场景

**前端改动**：
- **文件**：`src/hooks/useInlineAssist.ts`
- **改动内容**：
  1. 修改上下文提取逻辑
     - 检测是否有选中文本
     - 无选中文本时：提取光标前后各 500 字符
     - 有选中文本时：提取选中文本 + 前后各 500 字符
  2. 修改后端调用
     - `selected_text` 参数改为可选
     - 传递 `context_before` 和 `context_after`

**后端改动**：
- **文件**：`src-tauri/src/commands/ai_commands.rs`
- **改动内容**：
  1. 修改 `ai_inline_assist` 函数签名
     ```rust
     pub async fn ai_inline_assist(
         instruction: String,
         selected_text: Option<String>,  // 改为可选
         context_before: String,
         context_after: String,
         service: State<'_, AIServiceState>,
     ) -> Result<String, String>
     ```

**测试要点**：
- 测试有选中文本场景
- 测试无选中文本场景
- 测试上下文提取准确性

**预计工作量**：2 天

---

#### 任务 2.2：指令类型识别优化（P0 优先级）

**目标**：通过提示词让 AI 自行识别指令类型

**后端改动**：
- **文件**：`src-tauri/src/services/ai_providers/deepseek.rs` 和 `openai.rs`
- **改动内容**：
  1. 创建提示词构建函数
     ```rust
     fn build_inline_assist_prompt(
         instruction: &str,
         selected_text: Option<&str>,
         context_before: &str,
         context_after: &str,
         memory_items: &[MemoryItem],
         document_format: &str,
     ) -> (String, String)
     ```
  2. 构建系统提示词
     - 明确说明 AI 需要自行识别指令类型（修改/生成/分析/匹配）
     - 说明不同指令类型的处理方式
  3. 构建用户提示词
     - 指令分析部分：要求 AI 识别指令类型
     - 根据指令类型动态调整任务要求

**提示词结构**：
```
[系统提示词]
你是一个专业的文档编辑助手，可以根据用户指令执行多种操作：
- 文本修改：改写、润色、翻译、格式转换等
- 内容生成：续写、补充、生成摘要等
- 分析讨论：分析文本、讨论观点、解释概念等
- 匹配查找：查找相关内容、匹配概念、检查一致性等

请根据用户指令的类型，选择合适的方式处理。

[用户提示词]
当前文档格式：[格式类型]
当前位置格式：[段落/列表/表格/代码块等]

[上下文内容]
[根据是否有选中文本动态构建]

[用户指令]
[用户输入的指令]

[指令分析]
请识别指令类型：[修改/生成/分析/匹配]
请分析指令意图和处理方式。

[记忆库信息]（如有）
术语：[相关术语列表]
风格偏好：[风格偏好信息]

[任务要求]
根据识别的指令类型执行相应操作：
- 修改：修改文本，保持语义不变，匹配格式和样式
- 生成：生成内容，匹配上下文风格和格式
- 分析：分析文本，输出分析结果，保持客观专业
- 匹配：查找匹配内容，输出匹配结果

如果指令不明确（如"改好一点"、"优化一下"），请基于上下文推断合理意图并执行。
```

**测试要点**：
- 测试不同指令类型的识别准确性
- 测试模糊指令的处理
- 测试指令类型识别对结果质量的影响

**预计工作量**：3 天

---

#### 任务 2.3：记忆库集成（P1 优先级）

**目标**：从记忆库获取相关术语、风格偏好、主题信息

**实现方式**：与任务 1.3 类似，但针对 Inline Assist 场景；保持为**可选增强**，不作为层次二核心流程的前置依赖，避免增加故障点。

**前端改动**：
- **文件**：`src/hooks/useInlineAssist.ts`
- **改动内容**：
  1. 调用记忆库检索 API（采用与层次一相同的工具函数，避免重复实现）
     - 检索关键词：文档路径、指令关键词、上下文关键词
     - 最多获取 3-5 条相关记忆
  2. 传递记忆库信息给后端，失败时静默降级（不影响主流程）

**后端改动**：
- **文件**：`src-tauri/src/commands/ai_commands.rs`
- **改动内容**：
  1. 添加记忆库参数（可选）
  2. 在提示词构建中使用记忆库信息，但不改变主任务逻辑

**测试要点**：
- 测试记忆库信息对指令执行的影响
- 测试术语一致性
- 测试记忆库请求失败时的降级行为（不影响 Inline Assist 正常返回）

**预计工作量**：2 天

---

#### 任务 2.4：稳定性与鲁棒性增强（P0 优先级，新增）

**目标**：在不引入额外复杂度的前提下，保证层次二在各种异常场景下保持可预期、可恢复。

**实现原则**：
- 复用现有基础设施：请求队列、AIProvider、错误分类、日志体系尽量与层次一/三共用，不单独造轮子。
- 单轮调用模型：每次 Inline Assist 调用都是单次请求-响应，不维护会话状态，不引入工作流规划或工具调用。
- 失败可恢复：任何网络/模型错误只影响当前这次调用，不污染编辑器内容和后续调用。

**前端改动**：
- **文件**：`src/hooks/useInlineAssist.ts`
- **改动内容**：
  1. 引入与 `useAutoComplete` 一致的状态机和错误处理模式：`idle → running → success/error`，支持取消（Esc/关闭浮窗时通过 AbortController 取消请求）。
  2. 对 AI 请求增加超时控制（例如 10 秒），超时后给出友好提示，不挂死界面。
  3. 统一错误提示文案：区分网络错误、配额/鉴权错误、模型内部错误，避免把技术细节直接暴露给用户。
  4. 关键路径埋点：记录指令类型、是否有选中文本、请求耗时、是否超时/失败（不记录用户原文内容），便于后续排查和优化。

**后端改动**：
- **文件**：`src-tauri/src/commands/ai_commands.rs`, `src-tauri/src/services/ai_providers/deepseek.rs`, `openai.rs`
- **改动内容**：
  1. 为 Inline Assist 复用或对齐自动补全使用的 HTTP 客户端配置（连接超时、总超时），避免默认超时过长导致卡死。
  2. 明确 `ai_inline_assist` 的错误返回格式，区分可重试和不可重试错误，前端可据此决定是否提示用户重试。
  3. 在 provider 实现中不做额外的多轮对话组装，仅构造单次消息（系统提示 + 用户提示），简化实现和调试。

**测试要点**：
- 网络断开、DNS 失败、第三方 API 拒绝连接时，Inline Assist 是否能稳定给出错误提示且不影响编辑器正常使用。
- 模型返回空字符串、非常短内容或异常内容时，前端是否能正确处理（例如提示“本次结果无效，请重试”）。
- 连续快速触发多次 Cmd+K 时，请求队列与取消逻辑是否工作正常，不出现“幽灵中间态”。

**预计工作量**：3 天

---

### 2.3 层次三（聊天窗口）提示词优化

#### 任务 3.1：记忆库集成增强（P0 优先级）

**目标**：在上下文提示词中自动检索相关记忆项

**前端改动**：
- **文件**：`src/components/Chat/ChatPanel.tsx` 或相关组件
- **改动内容**：
  1. 在构建消息前检索记忆库
     - 根据对话主题、文档内容检索相关记忆
     - 最多获取 5-10 条相关记忆
  2. 将记忆库信息添加到上下文
     - 作为引用提示词的一部分
     - 明确标注信息来源为"记忆库"

**后端改动**：
- **文件**：`src-tauri/src/commands/ai_commands.rs`
- **改动内容**：
  1. 在 `ai_chat_stream` 中接收记忆库信息
     - 从消息中提取记忆库信息（如果前端已添加）
     - 或在后端检索记忆库（需要传递文档路径等上下文）
  2. 在提示词构建中使用记忆库信息
     - 在上下文提示词中添加记忆库信息部分

**测试要点**：
- 测试记忆库检索准确性
- 测试记忆库信息在对话中的使用
- 测试记忆库信息对回答质量的影响

**预计工作量**：3 天

---

#### 任务 3.2：文档内容预览智能选择优化（P1 优先级）

**目标**：通过提示词让 AI 根据用户消息类型智能选择内容

**前端改动**：
- **文件**：`src/components/Chat/ChatPanel.tsx`
- **改动内容**：
  1. 分析用户消息类型
     - 检测是否提到文档某部分（如"第三章"）
     - 检测是否是整体问题（如"总结文档"）
     - 检测是否是具体细节问题
  2. 根据消息类型选择内容
     - 提到某部分 → 包含该部分
     - 整体问题 → 包含文档开头 + 结构大纲
     - 具体细节 → 包含光标位置附近内容

**后端改动**：
- **文件**：`src-tauri/src/commands/ai_commands.rs`
- **改动内容**：
  1. 在提示词中明确要求 AI 根据用户消息类型智能选择内容
     - 在上下文提示词中添加选择规则说明

**测试要点**：
- 测试不同消息类型的内容选择
- 测试内容选择对回答质量的影响

**预计工作量**：2 天

---

#### 任务 3.3：工作规划判断优化（P0 优先级）

**目标**：通过提示词让 AI 自行判断是否需要规划

**后端改动**：
- **文件**：`src-tauri/src/commands/ai_commands.rs`
- **改动内容**：
  1. 优化系统提示词
     - 明确说明何时需要调用 `plan_workflow` 工具
     - 提供判断示例
  2. 在提示词中说明记忆库信息的使用
     - 从记忆库获取相关文档信息，辅助判断

**测试要点**：
- 测试 AI 判断是否需要规划的准确性
- 测试规划触发条件的准确性

**预计工作量**：2 天

---

## 三、技术实现细节

### 3.1 提示词构建模块设计

**建议创建**：`src-tauri/src/services/prompt_builder.rs`

**模块结构**：
```rust
pub struct PromptBuilder;

impl PromptBuilder {
    // 层次一提示词构建
    pub fn build_autocomplete_prompt(
        context_before: &str,
        context_after: Option<&str>,
        editor_state: &EditorState,
        memory_items: &[MemoryItem],
        document_format: &str,
        max_length: usize,
    ) -> (String, String);
    
        // 层次二提示词构建
    pub fn build_inline_assist_prompt(
        instruction: &str,
        selected_text: Option<&str>,
        context_before: &str,
        context_after: &str,
        memory_items: &[MemoryItem],
        document_format: &str,
    ) -> (String, String);
    
    // 层次三提示词构建（用于系统提示词增强）
    pub fn build_chat_system_prompt(
        enable_tools: bool,
        document_format: Option<&str>,
    ) -> String;
    
    // 层次三上下文提示词构建
    pub fn build_chat_context_prompt(
        document_content: Option<&str>,
        document_format: Option<&str>,
        editor_state: Option<&EditorState>,
        memory_items: &[MemoryItem],
        workspace_path: &str,
    ) -> String;
}
```

**数据结构**：
```rust
#[derive(Debug, Clone)]
pub struct EditorState {
    pub node_type: String,
    pub heading_level: Option<u32>,
    pub list_type: Option<String>,
    pub list_level: Option<u32>,
    pub block_type: Option<String>,
}

#[derive(Debug, Clone)]
pub struct MemoryItem {
    pub id: String,
    pub entity_name: String,
    pub content: String,
    pub entity_type: String,
}
```

**实现要点**：
1. 模块化设计：每个层次的提示词构建独立函数
2. 格式模板：使用模板字符串，支持动态替换
3. 条件构建：根据参数动态添加提示词部分
4. 长度控制：控制提示词总长度，避免超出模型限制

---

### 3.2 记忆库检索集成

**前端实现**：
- **文件**：`src/services/memoryService.ts`（如不存在则创建）
- **功能**：
  1. 检索相关记忆项
     ```typescript
     async function searchRelevantMemories(
       documentPath: string,
       keywords: string[],
       maxResults: number = 5
     ): Promise<MemoryItem[]>
     ```
  2. 根据上下文提取关键词
     - 从文档内容提取关键词
     - 从用户指令提取关键词
     - 从对话主题提取关键词

**后端实现**：
- **文件**：`src-tauri/src/commands/memory_commands.rs`
- **功能**：
  1. 增强 `search_memories` 命令
     - 支持多关键词搜索
     - 支持相关性排序
     - 支持按文档路径过滤

**检索策略**：
1. **关键词匹配**：根据文档路径、上下文关键词检索
2. **相关性评分**：根据匹配度排序
3. **数量限制**：最多返回 3-5 条（层次一/二）或 5-10 条（层次三）

---

### 3.3 编辑器状态提取

**前端实现**：
- **文件**：`src/utils/editorStateExtractor.ts`（新建）
- **功能**：
  ```typescript
  interface EditorState {
    nodeType: string;
    headingLevel?: number;
    listType?: 'ordered' | 'unordered';
    listLevel?: number;
    blockType?: string;
  }
  
  function extractEditorState(editor: Editor): EditorState {
    // 从 TipTap 编辑器状态提取结构信息
    const { state } = editor;
    const { selection, doc } = state;
    const { $from } = selection;
    
    // 提取当前节点类型
    const nodeType = $from.parent.type.name;
    
    // 提取标题层级
    let headingLevel: number | undefined;
    if (nodeType === 'heading') {
      headingLevel = $from.parent.attrs.level;
    }
    
    // 提取列表信息
    let listType: 'ordered' | 'unordered' | undefined;
    let listLevel: number | undefined;
    // ... 遍历节点树，查找列表节点
    
    // 提取块类型
    let blockType: string | undefined;
    // ... 判断是否是代码块、引用块等
    
    return {
      nodeType,
      headingLevel,
      listType,
      listLevel,
      blockType,
    };
  }
  ```

**实现要点**：
1. 使用 TipTap 的节点树遍历
2. 识别当前光标所在节点的类型和层级
3. 处理边界情况（无结构信息）

---

### 3.4 提示词模板管理

**建议创建**：`src-tauri/src/services/prompt_templates.rs`

**模板结构**：
```rust
pub struct PromptTemplates;

impl PromptTemplates {
    // 层次一系统提示词模板
    pub fn autocomplete_system() -> &'static str {
        r#"你是一个专业的写作助手，帮助用户续写内容。

当前文档格式：{format}
格式要求：{format_requirements}"#
    }
    
    // 层次一用户提示词模板
    pub fn autocomplete_user() -> &'static str {
        r#"上文：
{context_before}

{context_after_section}

{structure_section}

{memory_section}

续写要求：
基于以上上下文，续写接下来的内容（{min_length}-{max_length} 字，以完整句子或完整语义单元结尾）：
- 请自行分析文档的语义、风格、连贯性
- 保持与上文的语义连贯
{continuation_requirements}"#
    }
    
    // 层次二系统提示词模板
    pub fn inline_assist_system() -> &'static str {
        r#"你是一个专业的文档编辑助手，可以根据用户指令执行多种操作：
- 文本修改：改写、润色、翻译、格式转换等
- 内容生成：续写、补充、生成摘要等
- 分析讨论：分析文本、讨论观点、解释概念等
- 匹配查找：查找相关内容、匹配概念、检查一致性等

请根据用户指令的类型，选择合适的方式处理。"#
    }
    
    // 层次三系统提示词模板（Agent 模式）
    pub fn chat_agent_system() -> &'static str {
        r#"你是一个专业的编程助手和文档编辑助手。

你可以帮助用户：
- 回答编程和文档相关的问题
- 执行文件操作（读取、创建、更新、删除文件等）
- 执行编辑器操作（修改文档内容等）
- 搜索和浏览网络信息（如需要外部信息）

工作模式：
你可以访问以下工具：[工具列表]

执行流程：
1. 判断是否需要规划：
   - 如果任务需要读取多个文件（3个以上）或浏览网站，先调用 plan_workflow 工具生成规划
   - 对于简单任务（读取1-2个文件、修改文档等），直接调用相关工具
   - 规划生成后会展示给用户确认，确认后继续执行

2. 何时需要规划：
   - ✅ "帮我分析项目中所有配置文件的差异" → 需要规划
   - ❌ "读取 config.json 并解释其作用" → 直接执行
   - ✅ "根据 requirements.txt 创建项目文档" → 需要规划（涉及多步骤）

3. 工具调用格式要求（CRITICAL）：
   所有工具调用必须使用严格的 JSON 格式：
   ```json
   {{"tool":"tool_name","arguments":{{"key":"value"}}}}
   ```
   
   常见错误：
   - ❌ {{tool:read_file,arguments:{{path:test.md}}}}  // 缺少引号
   - ❌ {{"tool":"read_file","arguments":{{"path":test.md}}}}  // 值缺少引号
   - ✅ {{"tool":"read_file","arguments":{{"path":"test.md"}}}}
   
   规则：
   - 所有键名必须用双引号包裹
   - 所有字符串值必须用双引号包裹
   - JSON 必须完整闭合，以 }} 结尾
   - 确保 JSON 格式完全正确，可以被 JSON.parse() 解析"#
    }
}
```

**使用方式**：
1. 使用模板字符串替换占位符
2. 根据条件动态添加部分（如下文、记忆库、结构信息）
3. 保持模板的可维护性和可读性

---

## 四、开发优先级和时间安排

### 4.1 第一阶段（P0 优先级）- 核心功能（2 周）

**目标**：实现核心提示词优化功能

**任务列表**：
1. ✅ 任务 1.1：上下文提取增强（2 天）
2. ✅ 任务 1.2：编辑器状态提取（3 天）
3. ✅ 任务 1.4：层次一提示词构建优化（4 天）
4. ✅ 任务 2.1：无选中文本支持（2 天）
5. ✅ 任务 2.2：指令类型识别优化（3 天）
6. ✅ 任务 3.1：记忆库集成增强（3 天）
7. ✅ 任务 3.3：工作规划判断优化（2 天）

**总计**：19 天（约 2.5 周）

---

### 4.2 第二阶段（P1 优先级）- 增强功能（1.5 周）

**目标**：实现记忆库集成和智能选择优化

**任务列表**：
1. ✅ 任务 1.3：层次一记忆库集成（3 天）
2. ✅ 任务 2.3：层次二记忆库集成（2 天）
3. ✅ 任务 3.2：文档内容预览智能选择优化（2 天）

**总计**：7 天（约 1 周）

---

### 4.3 第三阶段（P2 优先级）- 优化和完善（1 周）

**目标**：性能优化、测试完善、文档更新

**任务列表**：
1. 性能优化
   - 提示词构建性能优化
   - 记忆库检索性能优化
   - 缓存机制实现
2. 测试完善
   - 单元测试
   - 集成测试
   - 用户体验测试
3. 文档更新
   - 更新技术文档
   - 更新用户文档

**总计**：5 天（约 1 周）

---

## 五、测试策略

### 5.1 单元测试

**测试范围**：
1. 提示词构建函数
   - 测试不同参数组合
   - 测试边界情况
   - 测试格式正确性
2. 编辑器状态提取
   - 测试不同节点类型
   - 测试边界情况
3. 记忆库检索
   - 测试检索准确性
   - 测试相关性排序

**测试文件**：
- `src-tauri/src/services/prompt_builder.rs` → `src-tauri/src/services/prompt_builder_test.rs`
- `src/utils/editorStateExtractor.ts` → `src/utils/editorStateExtractor.test.ts`

---

### 5.2 集成测试

**测试场景**：
1. 层次一完整流程测试
   - 触发 → 上下文提取 → 编辑器状态提取 → 记忆库检索 → 提示词构建 → AI 调用 → 结果展示
2. 层次二完整流程测试
   - 快捷键触发 → 指令输入 → 上下文提取 → 记忆库检索 → 提示词构建 → AI 调用 → 结果展示
3. 层次三完整流程测试
   - 消息发送 → 记忆库检索 → 提示词构建 → AI 流式响应 → 工具调用 → 结果展示

**测试要点**：
- 端到端功能测试
- 错误处理测试
- 性能测试

---

### 5.3 用户体验测试

**测试场景**：
1. 续写质量测试
   - 测试不同场景的续写质量（文学、办公、技术等）
   - 测试格式匹配准确性
   - 测试风格一致性
2. 指令识别测试
   - 测试不同指令类型的识别准确性
   - 测试模糊指令的处理
3. 记忆库影响测试
   - 测试记忆库信息对续写/修改质量的影响
   - 测试术语一致性

**测试方法**：
- A/B 测试：对比优化前后的效果
- 用户反馈收集
- 质量评分

---

## 六、风险和控制

### 6.1 技术风险

**风险 1：提示词长度超限**
- **风险描述**：增强后的提示词可能超出模型限制
- **控制措施**：
  - 实现提示词长度检查
  - 动态调整上下文长度
  - 压缩记忆库信息

**风险 2：编辑器状态提取不准确**
- **风险描述**：TipTap 节点树结构复杂，提取可能不准确
- **控制措施**：
  - 充分测试不同节点类型
  - 处理边界情况
  - 提供降级方案（无结构信息）

**风险 3：记忆库检索性能问题**
- **风险描述**：记忆库检索可能影响响应速度
- **控制措施**：
  - 异步检索，不阻塞主流程
  - 限制检索数量
  - 实现缓存机制

---

### 6.2 质量风险

**风险 1：提示词优化效果不明显**
- **风险描述**：优化后的提示词可能没有明显提升续写/修改质量
- **控制措施**：
  - A/B 测试验证效果
  - 持续优化提示词
  - 收集用户反馈

**风险 2：AI 理解偏差**
- **风险描述**：AI 可能无法准确理解增强的提示词
- **控制措施**：
  - 简化提示词结构
  - 提供清晰的示例
  - 持续测试和优化

---

## 七、验收标准

### 7.1 功能验收

1. ✅ **上下文提取增强**
   - 下文提取功能正常
   - 动态长度调整正常
   - 段落边界截断正常

2. ✅ **编辑器状态提取**
   - 不同节点类型提取正常
   - 结构信息传递正常

3. ✅ **记忆库集成**
   - 记忆库检索正常
   - 记忆库信息在提示词中正确传递
   - 术语一致性提升

4. ✅ **提示词构建优化**
   - 提示词结构符合设计文档
   - 不同格式的提示词构建正常
   - 提示词长度控制在合理范围

5. ✅ **指令类型识别**
   - AI 能准确识别指令类型
   - 模糊指令处理正常

---

### 7.2 质量验收

1. **续写质量提升**
   - 续写内容与上下文连贯性提升 20%+
   - 格式匹配准确性提升 15%+
   - 风格一致性提升 15%+

2. **响应时间**
   - 层次一响应时间 < 2 秒（不含网络延迟）
   - 层次二响应时间 < 5 秒（不含网络延迟）
   - 层次三首次响应时间 < 3 秒

3. **错误率**
   - 提示词构建错误率 < 1%
   - 编辑器状态提取错误率 < 5%
   - 记忆库检索错误率 < 2%

---

## 八、后续优化方向

### 8.1 提示词持续优化

1. **A/B 测试**
   - 测试不同提示词版本的效果
   - 根据测试结果优化提示词

2. **用户反馈收集**
   - 收集用户对续写/修改质量的反馈
   - 根据反馈调整提示词

3. **提示词版本管理**
   - 建立提示词版本管理系统
   - 支持回滚到之前的版本
   - 记录每次优化的效果

### 8.2 记忆库功能增强

1. **自动提取术语**
   - 从文档中自动提取术语并保存到记忆库
   - 在续写/修改时自动使用术语

2. **风格偏好学习**
   - 收集用户的续写/修改选择
   - 分析用户偏好并保存到记忆库
   - 根据偏好调整提示词

3. **跨文档记忆关联**
   - 建立文档间的记忆关联
   - 在相关文档间共享术语和风格偏好

### 8.3 编辑器状态提取优化

1. **更详细的结构信息**
   - 提取更详细的文档结构（章节关系、列表嵌套等）
   - 提取样式信息（字体、颜色、对齐等）

2. **结构信息缓存**
   - 缓存文档结构分析结果
   - 减少重复计算

### 8.4 提示词性能优化

1. **提示词压缩**
   - 智能压缩长上下文
   - 保留关键信息

2. **提示词模板化**
   - 建立提示词模板库
   - 支持快速切换不同模板

3. **批量处理优化**
   - 优化记忆库批量检索
   - 优化编辑器状态批量提取

---

## 九、开发时间表

### 9.1 第一阶段（P0 优先级）- 4 周

**目标**：完成核心功能优化

**任务清单**：
1. 层次一上下文提取增强（任务 1.1）- 2 天
2. 层次一编辑器状态提取（任务 1.2）- 3 天
3. 层次一提示词构建优化（任务 1.4）- 4 天
4. 层次二无选中文本支持（任务 2.1）- 2 天
5. 层次二指令类型识别优化（任务 2.2）- 3 天
6. 层次三记忆库集成增强（任务 3.1）- 3 天
7. 层次三工作规划判断优化（任务 3.3）- 2 天
8. 提示词构建模块开发（任务 4.1）- 5 天
9. 测试和修复（任务 5.1）- 6 天

**总计**：30 天（约 4.5 周）

### 9.2 第二阶段（P1 优先级）- 2 周

**目标**：完成记忆库集成和文档内容预览优化

**任务清单**：
1. 层次一记忆库集成（任务 1.3）- 3 天
2. 层次二记忆库集成（任务 2.3）- 2 天
3. 层次三文档内容预览智能选择优化（任务 3.2）- 2 天
4. 测试和优化（任务 5.2）- 3 天

**总计**：10 天（约 1.5 周）

### 9.3 第三阶段（优化和测试）- 1 周

**目标**：性能优化、全面测试、文档完善

**任务清单**：
1. 性能优化（任务 6.1）- 2 天
2. 全面测试（任务 5.3）- 2 天
3. 文档完善（任务 7.1）- 1 天

**总计**：5 天（约 1 周）

### 9.4 总体时间表

| 阶段 | 时间 | 主要任务 |
|------|------|----------|
| 第一阶段 | 4 周 | 核心功能优化（P0） |
| 第二阶段 | 2 周 | 记忆库集成和预览优化（P1） |
| 第三阶段 | 1 周 | 优化和测试 |
| **总计** | **7 周** | **完整优化** |

---

## 十、资源需求

### 10.1 人力资源

- **后端开发**：1 人，负责 Rust 后端开发（提示词构建、记忆库集成）
- **前端开发**：1 人，负责 TypeScript 前端开发（上下文提取、编辑器状态提取）
- **测试**：1 人，负责功能测试和质量验收
- **产品/设计**：0.5 人，负责需求确认和验收

### 10.2 技术资源

- **开发环境**：现有开发环境即可
- **测试环境**：需要配置测试用的 AI API Key
- **文档工具**：Markdown 编辑器

### 10.3 依赖项

- **记忆库服务**：已存在，需要确认 API 接口
- **TipTap 编辑器**：已存在，需要确认状态提取 API
- **AI 服务**：已存在，需要确认接口兼容性

---

## 十一、关键里程碑

### 里程碑 1：核心功能完成（第 4 周末）

**验收标准**：
- ✅ 层次一上下文提取增强完成
- ✅ 层次一编辑器状态提取完成
- ✅ 层次一提示词构建优化完成
- ✅ 层次二无选中文本支持完成
- ✅ 层次二指令类型识别优化完成
- ✅ 层次三记忆库集成增强完成
- ✅ 提示词构建模块开发完成

### 里程碑 2：记忆库集成完成（第 6 周末）

**验收标准**：
- ✅ 层次一记忆库集成完成
- ✅ 层次二记忆库集成完成
- ✅ 层次三文档内容预览优化完成
- ✅ 所有功能测试通过

### 里程碑 3：优化和测试完成（第 7 周末）

**验收标准**：
- ✅ 性能优化完成
- ✅ 全面测试通过
- ✅ 文档完善
- ✅ 质量验收通过

---

## 十二、总结

### 12.1 核心优化点

1. **提示词驱动**：通过增强的提示词让 AI 自行分析结构、语义、风格，减少技术实现复杂度
2. **记忆库充分利用**：从记忆库获取术语、风格偏好、主题信息，减少 AI 分析负担
3. **编辑器状态利用**：从 TipTap 编辑器状态提取结构信息，无需独立解析
4. **上下文增强**：增加下文提取，提升续写连贯性

### 12.2 预期效果

1. **续写质量提升**：
   - 续写内容与上下文连贯性提升 20%+
   - 格式匹配准确性提升 15%+
   - 风格一致性提升 15%+

2. **指令理解提升**：
   - 指令类型识别准确率 > 90%
   - 模糊指令处理准确率 > 80%

3. **术语一致性提升**：
   - 专业文档术语一致性提升 25%+

### 12.3 实施建议

1. **分阶段实施**：按照优先级分阶段实施，确保核心功能优先完成
2. **持续测试**：每个阶段完成后进行充分测试，及时发现问题
3. **用户反馈**：收集用户反馈，持续优化提示词
4. **文档同步**：及时更新设计文档和开发文档，保持一致性

---

**文档版本**：v1.0  
**创建日期**：2025年  
**维护者**：Binder 开发团队

