# 文档编辑功能优化方案

## 问题分析

### 当前问题

1. **点击放弃无法放弃**
   - 现象：点击放弃按钮后，diff 高亮和按钮仍然显示
   - 原因：
     - `clearTabDiff` 清除了数据，但插件没有立即响应
     - 按钮 widget 是在有 diff 数据时创建的，清除数据后按钮应该消失，但视图没有及时刷新
     - 需要强制触发插件重新计算装饰

2. **点击确认修改了整个文档的格式**
   - 现象：点击确认后，整个文档被替换，格式丢失
   - 原因：
     - 当前实现使用 `editor.commands.setContent(newContent)` 替换整个文档
     - `newContent` 可能是纯文本，而不是 HTML 格式
     - 应该根据 `diffs` 数组逐个应用修改，而不是替换整个文档

### 根本原因

1. **应用逻辑错误**：使用全量替换而不是增量应用
2. **视图刷新机制不完善**：清除 diff 后没有强制刷新视图
3. **按钮生命周期管理**：按钮 widget 的生命周期与 diff 数据不同步

## 优化方案

### 方案一：修复放弃功能（简单）

**目标**：确保点击放弃后，diff 高亮和按钮立即消失

**实现**：
1. 在 `onRejectDiff` 中，清除 diff 数据后，发送带有 `diffCleared` meta 的 transaction
2. 插件检测到 `diffCleared` meta 后，立即返回空装饰集合
3. 确保按钮 widget 也被移除

**代码修改**：
```typescript
// TipTapEditor.tsx
onRejectDiff: () => {
  const store = useEditorStore.getState();
  const currentTab = tabId 
    ? store.tabs.find(t => t.id === tabId)
    : store.tabs.find(t => t.id === store.activeTabId);
  
  if (currentTab && editor) {
    // 清除 diff 数据
    store.clearTabDiff(currentTab.id);
    
    // ⚠️ 关键：触发插件状态更新，强制刷新视图
    const { state, dispatch } = editor.view;
    const tr = state.tr.setMeta('diffCleared', true);
    dispatch(tr);
    
    console.log('❌ [编辑器] 已拒绝 diff，diff 高亮已清除，视图已刷新');
  }
}
```

```typescript
// DiffHighlightExtension.ts
apply(tr, set, _oldState, newState) {
  const isDiffCleared = tr.getMeta('diffCleared') === true;
  
  // ⚠️ 关键修复：如果 diff 被清除，立即返回空集合
  if (isDiffCleared) {
    console.log('[DiffHighlightExtension] diff 已清除，返回空集合');
    return DecorationSet.empty;
  }
  
  // ... 其他逻辑
}
```

### 方案二：修复应用功能（核心）

**目标**：根据 `diffs` 数组逐个应用修改，而不是替换整个文档

**实现策略**：
1. 从后往前应用 diff（避免位置偏移）
2. 对于每个 diff：
   - `Deletion`：删除 `original_code` 对应的内容
   - `Insertion`：插入 `new_code` 对应的内容
   - `Edit`：删除 `original_code`，然后插入 `new_code`
3. 使用 ProseMirror 的 transaction 和 replace 操作

**代码实现**：
```typescript
// TipTapEditor.tsx
onApplyDiff: () => {
  const store = useEditorStore.getState();
  const currentTab = tabId 
    ? store.tabs.find(t => t.id === tabId)
    : store.tabs.find(t => t.id === store.activeTabId);
  
  if (!currentTab || !editor || !currentTab.diffs || currentTab.diffs.length === 0) {
    console.warn('⚠️ [编辑器] 无法应用 diff：缺少必要数据');
    return;
  }
  
  const { diffs, oldContent } = currentTab;
  if (!oldContent) {
    console.warn('⚠️ [编辑器] 无法应用 diff：缺少 oldContent');
    return;
  }
  
  try {
    // ⚠️ 关键：从后往前应用 diff，避免位置偏移问题
    // 按 original_start_line 降序排序
    const sortedDiffs = [...diffs].sort((a, b) => {
      const aLine = a.diff_type === 'Deletion' ? a.original_start_line : a.start_line;
      const bLine = b.diff_type === 'Deletion' ? b.original_start_line : b.start_line;
      return bLine - aLine; // 降序
    });
    
    // 获取当前文档
    const { state, dispatch } = editor.view;
    let tr = state.tr;
    
    // 获取文档的纯文本（用于定位）
    const docText = editor.state.doc.textContent;
    const oldText = oldContent.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ');
    
    // 逐个应用 diff（从后往前）
    for (const diff of sortedDiffs) {
      if (diff.diff_type === 'Deletion' || diff.diff_type === 'Edit') {
        // 删除 original_code
        if (diff.original_code && diff.original_code.trim().length > 0) {
          const targetText = diff.original_code.trim();
          const textIndex = docText.indexOf(targetText);
          
          if (textIndex !== -1) {
            // 转换为 ProseMirror 位置
            const range = findTextRangeInDoc(editor.state.doc, textIndex, textIndex + targetText.length);
            if (range) {
              // 删除文本
              tr = tr.delete(range.start, range.end);
            }
          }
        }
      }
      
      if (diff.diff_type === 'Insertion' || diff.diff_type === 'Edit') {
        // 插入 new_code
        if (diff.new_code && diff.new_code.trim().length > 0) {
          const newCode = diff.new_code.trim();
          let insertPos: number | null = null;
          
          if (diff.diff_type === 'Edit' && diff.original_code) {
            // Edit 操作：在删除位置后插入
            const targetText = diff.original_code.trim();
            const textIndex = docText.indexOf(targetText);
            if (textIndex !== -1) {
              const range = findTextRangeInDoc(editor.state.doc, textIndex, textIndex + targetText.length);
              if (range) {
                insertPos = range.end; // 在删除位置后插入
              }
            }
          } else if (diff.diff_type === 'Insertion') {
            // Insertion 操作：根据行号计算插入位置
            const lines = docText.split('\n');
            let lineStartPos = 0;
            for (let i = 0; i < Math.min(diff.start_line - 1, lines.length); i++) {
              lineStartPos += lines[i].length + 1;
            }
            const range = findTextRangeInDoc(editor.state.doc, lineStartPos, lineStartPos);
            if (range) {
              insertPos = range.start;
            }
          }
          
          if (insertPos !== null) {
            // 插入文本（使用 insertContent 保持格式）
            const slice = editor.state.schema.text(newCode);
            tr = tr.insert(insertPos, slice);
          }
        }
      }
    }
    
    // 应用所有修改
    dispatch(tr);
    
    // 清除 diff 数据
    store.clearTabDiff(currentTab.id);
    
    // 触发视图刷新
    const refreshTr = editor.view.state.tr.setMeta('diffCleared', true);
    editor.view.dispatch(refreshTr);
    
    console.log('✅ [编辑器] 已应用 diff，编辑器内容已更新（增量应用）');
  } catch (error) {
    console.error('❌ [编辑器] 应用 diff 失败:', error);
    // 如果增量应用失败，回退到全量替换（作为备选方案）
    if (currentTab.newContent) {
      editor.commands.setContent(currentTab.newContent, false);
      store.clearTabDiff(currentTab.id);
      console.log('⚠️ [编辑器] 增量应用失败，已回退到全量替换');
    }
  }
}
```

**辅助函数**（需要在 TipTapEditor.tsx 中实现）：
```typescript
// 将文本位置转换为 ProseMirror 文档位置
function findTextRangeInDoc(doc: any, textStart: number, textEnd: number): { start: number; end: number } | null {
  let docStart = 1;
  let docEnd = 1;
  let currentTextPos = 0;
  let startFound = false;
  let endFound = false;
  
  doc.descendants((node: any, pos: number) => {
    if (startFound && endFound) return false;
    
    if (node.isText) {
      const nodeText = node.text;
      const nodeTextLength = nodeText.length;
      const nodeStart = pos + 1;
      const nodeEnd = nodeStart + nodeTextLength;
      
      // 查找起始位置
      if (!startFound && currentTextPos <= textStart && currentTextPos + nodeTextLength >= textStart) {
        const offset = textStart - currentTextPos;
        docStart = nodeStart + offset;
        startFound = true;
      }
      
      // 查找结束位置
      if (!endFound && currentTextPos <= textEnd && currentTextPos + nodeTextLength >= textEnd) {
        const offset = textEnd - currentTextPos;
        docEnd = nodeStart + offset;
        endFound = true;
      }
      
      currentTextPos += nodeTextLength;
    }
    
    return true;
  });
  
  if (startFound && endFound && docStart < docEnd) {
    return { start: docStart, end: docEnd };
  }
  return null;
}
```

### 方案三：简化实现（推荐）

**目标**：如果增量应用太复杂，先修复放弃功能，应用功能使用更安全的全量替换

**实现**：
1. 修复放弃功能（方案一）
2. 应用功能：确保 `newContent` 是 HTML 格式，或者将纯文本转换为 HTML

**代码修改**：
```typescript
// TipTapEditor.tsx
onApplyDiff: () => {
  const store = useEditorStore.getState();
  const currentTab = tabId 
    ? store.tabs.find(t => t.id === tabId)
    : store.tabs.find(t => t.id === store.activeTabId);
  
  if (!currentTab || !editor) {
    console.warn('⚠️ [编辑器] 无法应用 diff：缺少必要数据');
    return;
  }
  
  if (currentTab.newContent) {
    try {
      // ⚠️ 关键：检查 newContent 是否是 HTML 格式
      // 如果不是，转换为 HTML（保持段落和换行）
      let htmlContent = currentTab.newContent;
      if (!htmlContent.includes('<') || !htmlContent.includes('>')) {
        // 纯文本，转换为 HTML
        htmlContent = htmlContent
          .split('\n\n')
          .map(para => `<p>${para.replace(/\n/g, '<br>')}</p>`)
          .join('');
      }
      
      // 使用 setContent 替换整个文档
      editor.commands.setContent(htmlContent, false);
      
      // 清除 diff 数据
      store.clearTabDiff(currentTab.id);
      
      // 触发视图刷新
      const { state, dispatch } = editor.view;
      const tr = state.tr.setMeta('diffCleared', true);
      dispatch(tr);
      
      console.log('✅ [编辑器] 已应用 diff，编辑器内容已更新');
    } catch (error) {
      console.error('❌ [编辑器] 应用 diff 失败:', error);
    }
  } else {
    console.warn('⚠️ [编辑器] 无法应用 diff：缺少 newContent');
  }
}
```

## 推荐实施顺序

1. **第一步**：修复放弃功能（方案一）- 简单，立即见效
2. **第二步**：优化应用功能（方案三）- 确保格式不丢失
3. **第三步**（可选）：实现增量应用（方案二）- 更精确，但更复杂

## 测试要点

1. **放弃功能测试**：
   - 点击放弃按钮
   - 检查 diff 高亮是否立即消失
   - 检查按钮是否立即消失
   - 检查文档内容是否保持不变

2. **应用功能测试**：
   - 点击确认按钮
   - 检查文档内容是否正确更新
   - 检查格式是否保持（段落、换行等）
   - 检查 diff 高亮是否被清除

3. **边界情况测试**：
   - 多个 diff 的情况
   - 大文档的情况
   - 格式复杂的文档（列表、表格等）

## 注意事项

1. **格式保持**：确保应用 diff 时保持文档格式
2. **性能优化**：对于大文档，考虑分批应用 diff
3. **错误处理**：如果增量应用失败，应该有回退方案
4. **用户体验**：应用/放弃操作应该有明确的视觉反馈

