# Binder AI 功能完整开发方案

## 文档信息

- **文档版本**：v2.0
- **创建日期**：2025年
- **最后更新**：2025年
- **文档性质**：完整开发方案文档
- **基于文档**：
  - AI基础功能设计文档
  - 层次一-自动补全功能设计文档
  - 层次二-InlineAssist功能设计文档
  - 层次三-右侧聊天窗口功能设计文档

## 格式说明

**重要**：本文档中提到的文档格式说明：
- **原生 DOCX**：Word 原生的 .docx 文件，Binder 只能预览，不能编辑
- **t-docx**：Binder 可编辑的文档格式（TipTap 模拟的 DOCX），包括：
  - Binder 生成的文档
  - 从预览模式切换到编辑模式时创建的草稿文件（如 `document.draft.docx`）
  - 所有在 Binder 编辑器中可编辑的文档

本文档中所有涉及"可编辑"、"格式匹配"、"样式继承"等场景下的 DOCX，均指 **t-docx** 格式。

---

## 一、技术栈概览

### 1.1 前端技术栈

- **框架**：React + TypeScript
- **状态管理**：Zustand（轻量级状态管理）
- **编辑器**：TipTap（基于 ProseMirror）
- **UI 组件**：自定义组件库
- **样式**：CSS Modules / Tailwind CSS（根据项目实际情况）

### 1.2 后端技术栈

- **语言**：Rust
- **框架**：Tauri（桌面应用框架）
- **AI 服务**：
  - OpenAI API（GPT-4、GPT-3.5）
  - DeepSeek API
  - 可扩展支持 Anthropic、Google 等

### 1.3 数据存储

- **前端存储**：Zustand Store（内存）+ LocalStorage（持久化）
- **后端存储**：文件系统（工作区配置、会话数据）
- **加密存储**：系统密钥链（API Key）

---

## 二、架构设计

### 2.1 整体架构

**三层独立架构**：
- **层次一**：自动补全（静默执行，无 UI 窗口）
- **层次二**：Inline Assist（静默执行，浮动输入框）
- **层次三**：聊天窗口（完整展示，工作规划和执行可视化）

**共享机制**：
- AI 服务接口（统一调用）
- 上下文收集机制（隐式+显式）
- 提示词构建机制（多层架构）
- 格式和样式匹配机制

### 2.2 服务分层

```
前端层（React）
    ↓
状态管理层（Zustand Store）
    ↓
服务层（Tauri Commands）
    ↓
AI 服务层（AIService）
    ↓
工具服务层（ToolService）
    ↓
提供商层（OpenAIProvider、DeepSeekProvider）
```

---

## 三、核心功能开发方案

### 3.1 AI 工作规划和执行逻辑

#### 3.1.1 工作规划机制

**技术实现**：
- **规划生成**：在系统提示词中要求 AI 先分析任务，生成工作规划
- **规划工具**：新增 `plan_workflow` 工具，AI 调用此工具生成规划
- **规划数据结构**：
  - 文档列表（路径、名称、选择原因、相关性评分）
  - 网站列表（URL、浏览目的、是否需要授权）
  - 步骤列表（ID、描述、目标、依赖关系、工具列表）

**实现位置**：
- 后端：`ai_commands.rs` - 在 `ai_chat_stream` 中处理规划工具调用
- 前端：`chatStore.ts` - 添加 `workPlan` 状态字段

#### 3.1.2 隐式上下文自动收集

**技术实现**：
- **文件扫描服务**：建立工作区文件索引服务
- **相关性评分算法**：
  - 文件名匹配（关键词匹配）
  - 路径相关性（目录层级关系）
  - 内容相关性（关键词、符号匹配）
- **上下文变量服务**：统一的变量解析服务（`IChatVariablesService`）
  - 支持隐式变量（自动检测）
  - 支持显式变量（用户引用）

**实现位置**：
- 后端：新建 `context_collection_service.rs`
- 前端：在提示词构建时自动收集上下文

#### 3.1.3 分步执行机制

**技术实现**：
- **步骤状态管理**：
  - 步骤状态机：pending → executing → completed/failed
  - 步骤依赖解析：构建依赖图，按顺序执行
  - 步骤取消机制：支持按步骤 ID 取消
- **工具调用链**：
  - 工具注册表：统一的工具注册机制
  - 工具权限控制：只读、读写、危险操作分级
  - 工具调用上下文：传递会话 ID、请求 ID

**实现位置**：
- 后端：`tool_service.rs` - 扩展工具执行逻辑
- 前端：`chatStore.ts` - 添加 `executionSteps` 状态字段

#### 3.1.4 工作过程展示

**层次一/二（静默执行）**：
- 技术逻辑：工作规划在后台执行，不展示任何过程
- 实现方式：在提示词中要求 AI 直接执行，不调用规划工具
- 结果展示：只显示最终结果（幽灵文字或 Diff 视图）

**层次三（完整展示）**：
- **工作规划展示**：
  - UI 组件：`WorkPlanCard.tsx`
  - 展示内容：文档列表、网站列表、步骤规划
  - 交互：用户确认/修改规划
- **分步执行展示**：
  - UI 组件：`ExecutionStepCard.tsx`、`ToolCallDetailCard.tsx`
  - 展示内容：步骤状态、工具调用详情、进度反馈
  - 交互：展开/折叠、取消、重试、跳过

**实现位置**：
- 前端：`ChatPanel.tsx` - 集成工作规划和执行展示组件
- 状态管理：`chatStore.ts` - 管理规划和执行状态

---

### 3.2 文档格式和样式匹配

#### 3.2.1 格式识别

**技术实现**：
- **文件扩展名识别**：`.txt`、`.t-docx`、`.md`、`.html` 等
- **编辑器状态获取**：从编辑器实例获取当前文档格式
- **格式信息传递**：在上下文提示词中包含格式信息

**实现位置**：
- 前端：`editorStore.ts` - 获取当前文档格式
- 后端：`ai_commands.rs` - 在提示词构建时添加格式信息

#### 3.2.2 样式匹配

**技术实现**：
- **提示词增强**：在系统提示词中明确说明当前文档格式和样式要求
- **输出格式控制**：
  - TXT：要求纯文本，无格式标记
  - t-docx：要求匹配 t-docx 样式（标题、粗体、斜体、列表等）
  - Markdown：要求使用 Markdown 语法
  - HTML：要求使用 HTML 标签
- **格式转换**：如果 AI 生成的内容格式不匹配，自动转换

**实现位置**：
- 后端：`ai_commands.rs` - 在提示词构建时添加格式要求
- 前端：`utils/contentParser.ts` - 格式转换工具函数

#### 3.2.3 样式继承

**技术实现**：
- **光标位置样式获取**：从编辑器获取当前光标位置的样式
- **样式信息传递**：在上下文提示词中包含样式信息
- **应用时样式保持**：插入内容时继承当前样式

**实现位置**：
- 前端：`TipTapEditor.tsx` - 获取和应用样式
- 工具：`edit_current_editor_document` - 保持样式

---

### 3.3 智能 Chunk 分割

#### 3.3.1 分割策略

**技术实现**：
- **句子边界识别**：使用正则表达式识别句子边界（句号、问号、感叹号等）
- **Offset 跟踪**：跟踪已解析的文本位置，避免重复解析
- **智能分割**：按句子边界分割，避免在单词中间分割

**实现位置**：
- 后端：新建 `chunk_parser.rs` - 实现智能分割逻辑
- 前端：`ChatPanel.tsx` - 使用分割后的 chunk 更新 UI

#### 3.3.2 去重机制

**技术实现**：
- **后端去重**：累积文本跟踪，跳过重复 chunk
- **前端去重**：`accumulatedTextRef` 跟踪每个 tab 的累积文本
- **空 chunk 过滤**：跳过空事件，避免日志污染

**实现位置**：
- 后端：`ai_commands.rs` - 在流式响应处理中实现
- 前端：`ChatPanel.tsx` - 在流式事件处理中实现

---

### 3.4 工具调用优化

#### 3.4.1 工具注册和发现机制

**技术实现**：
- **工具注册表**：统一的工具注册表（`ToolRegistry`）
- **工具分类**：extension、mcp、internal
- **工具发现**：动态发现可用工具
- **工具权限**：工具权限分级（只读、读写、危险）

**实现位置**：
- 后端：新建 `tool_registry.rs` - 工具注册表实现
- 后端：`tool_definitions.rs` - 工具定义和注册

#### 3.4.2 工具调用取消机制

**技术实现**：
- **请求 ID 管理**：每个工具调用分配唯一请求 ID
- **取消信号**：使用 `CancellationToken` 传递取消信号
- **取消处理**：工具执行时检查取消信号，及时停止

**实现位置**：
- 后端：`tool_service.rs` - 添加取消机制
- 前端：`ToolCallCard.tsx` - 添加取消按钮

#### 3.4.3 JSON 修复机制

**技术实现**：
- **修复策略**：
  - 修复键名缺少引号
  - 修复缺失的结束括号
  - 修复不完整的 JSON 结构
- **修复位置**：前端和后端双重修复
- **修复失败处理**：修复失败时返回友好错误提示

**实现位置**：
- 后端：`ai_commands.rs` - `repair_json_arguments` 函数
- 前端：`utils/jsonRepair.ts` - JSON 修复工具函数

---

### 3.5 错误处理优化

#### 3.5.1 错误级别分类

**技术实现**：
- **错误级别**：Error（严重）、Warning（警告）、Info（提示）
- **错误分类逻辑**：
  - Error：API Key 无效、网络连接失败、工具执行失败
  - Warning：配额不足、响应超时、工具调用部分失败
  - Info：响应被过滤、部分内容未返回、工具调用被取消
- **错误处理策略**：不同级别采用不同的处理方式

**实现位置**：
- 后端：`ai_commands.rs` - 错误分类逻辑
- 前端：`errorHandler.ts` - 错误处理和展示

#### 3.5.2 错误详情扩展

**技术实现**：
- **响应状态检测**：
  - `responseIsIncomplete`：检测响应是否不完整
  - `responseIsFiltered`：检测响应是否被过滤
  - `isQuotaExceeded`：检测配额是否超限
- **错误详情传递**：在错误对象中包含详细信息
- **用户友好提示**：将技术错误转换为用户友好的提示

**实现位置**：
- 后端：`ai_service.rs` - 响应状态检测
- 前端：`errorHandler.ts` - 错误详情展示

---

### 3.6 会话持久化

#### 3.6.1 会话序列化

**技术实现**：
- **序列化格式**：JSON 格式
- **序列化内容**：
  - 会话 ID、标题
  - 消息列表（用户消息、AI 消息）
  - 工作规划（如有）
  - 执行步骤状态（如有）
  - 创建时间、更新时间
- **数据压缩**：大会话数据可压缩存储

**实现位置**：
- 前端：新建 `chatStorageService.ts` - 会话序列化/反序列化
- 后端：`workspace_commands.rs` - 会话存储到工作区

#### 3.6.2 会话加载和恢复

**技术实现**：
- **加载时机**：打开工作区时自动加载会话
- **加载策略**：限制最大会话数（如 25 个），自动清理旧会话
- **恢复逻辑**：恢复消息列表、工作规划、执行步骤状态

**实现位置**：
- 前端：`chatStorageService.ts` - 会话加载逻辑
- 前端：`ChatPanel.tsx` - 会话恢复 UI

---

### 3.7 敏感信息过滤

#### 3.7.1 敏感信息检测

**技术实现**：
- **检测类型**：密码、密钥、API Key、个人信息等
- **检测算法**：正则表达式匹配 + 关键词匹配
- **检测位置**：发送给 AI 前检测

**实现位置**：
- 后端：新建 `sensitive_info_filter.rs` - 敏感信息检测
- 前端：`InlineChatInput.tsx` - 输入时检测

#### 3.7.2 敏感信息处理

**技术实现**：
- **脱敏处理**：敏感信息替换为占位符
- **用户警告**：检测到敏感信息时提示用户
- **日志记录**：记录敏感信息使用情况（不记录具体内容）

**实现位置**：
- 后端：`sensitive_info_filter.rs` - 脱敏处理逻辑
- 前端：`Toast.tsx` - 警告提示

---

## 四、层次一：自动补全开发方案

### 4.1 工作逻辑

**技术实现**：
- **静默执行**：工作规划在后台执行，不展示任何过程
- **提示词策略**：在提示词中要求 AI 直接执行，不调用规划工具
- **结果展示**：只显示最终结果（幽灵文字）

**实现位置**：
- 前端：`useAutoComplete.ts` - Hook 实现
- 后端：`ai_commands.rs::ai_autocomplete` - 后端接口

### 4.2 格式和样式匹配

**技术实现**：
- **格式识别**：从编辑器获取当前文档格式
- **提示词增强**：在提示词中说明格式要求
- **样式匹配**：生成内容需匹配当前文档格式

**实现位置**：
- 前端：`useAutoComplete.ts` - 获取格式信息
- 后端：`ai_commands.rs::ai_autocomplete` - 添加格式要求

### 4.3 错误处理

**技术实现**：
- **错误级别分类**：Error、Warning、Info
- **静默失败**：错误时不显示提示，不影响用户操作
- **自动重试**：网络错误自动重试（最多 3 次）

**实现位置**：
- 后端：`ai_commands.rs::ai_autocomplete` - 错误处理
- 前端：`useAutoComplete.ts` - 错误处理

---

## 五、层次二：Inline Assist 开发方案

### 5.1 工作逻辑

**技术实现**：
- **静默执行**：工作规划在后台执行，不展示任何过程
- **提示词策略**：在提示词中要求 AI 直接执行，不调用规划工具
- **结果展示**：只显示最终结果（Diff 视图）

**实现位置**：
- 前端：`useInlineAssist.ts` - Hook 实现
- 后端：`ai_commands.rs::ai_inline_assist` - 后端接口

### 5.2 格式和样式匹配

**技术实现**：
- **格式识别**：从编辑器获取当前文档格式
- **提示词增强**：在提示词中说明格式要求
- **格式转换**：如果指令要求格式转换，按指令执行；否则保持当前格式

**实现位置**：
- 前端：`useInlineAssist.ts` - 获取格式信息
- 后端：`ai_commands.rs::ai_inline_assist` - 添加格式要求

### 5.3 流式显示（可选）

**技术实现**：
- **智能 Chunk 分割**：按句子边界分割
- **流式更新**：逐步显示 AI 生成内容
- **去重机制**：前端和后端双重去重

**实现位置**：
- 后端：`ai_commands.rs::ai_inline_assist` - 流式响应
- 前端：`useInlineAssist.ts` - 流式更新 UI

---

## 六、层次三：聊天窗口开发方案

### 6.1 工作规划和执行展示

#### 6.1.1 工作规划展示

**技术实现**：
- **规划生成**：AI 调用 `plan_workflow` 工具生成规划
- **规划展示组件**：`WorkPlanCard.tsx`
  - 显示文档列表（路径、名称、选择原因）
  - 显示网站列表（URL、浏览目的）
  - 显示步骤规划（步骤列表、依赖关系）
- **用户交互**：确认/修改规划、添加/删除文档或网站

**实现位置**：
- 前端：新建 `WorkPlanCard.tsx` - 规划展示组件
- 前端：`ChatPanel.tsx` - 集成规划展示
- 状态管理：`chatStore.ts` - 管理规划状态

#### 6.1.2 分步执行展示

**技术实现**：
- **步骤状态管理**：
  - 步骤状态机：pending → executing → completed/failed
  - 状态更新：响应工具调用结果
- **执行展示组件**：
  - `ExecutionStepCard.tsx`：步骤状态卡片
  - `ToolCallDetailCard.tsx`：工具调用详情卡片
  - `ExecutionProgressBar.tsx`：执行进度条
- **用户交互**：展开/折叠、取消、重试、跳过

**实现位置**：
- 前端：新建 `ExecutionStepCard.tsx`、`ToolCallDetailCard.tsx`、`ExecutionProgressBar.tsx`
- 前端：`ChatPanel.tsx` - 集成执行展示
- 状态管理：`chatStore.ts` - 管理执行步骤状态

### 6.2 快捷应用到文档

#### 6.2.1 内容识别

**技术实现**：
- **代码块识别**：Markdown 代码块语法（```语言\n代码\n```）
- **段落识别**：按空行分割
- **列表识别**：Markdown 列表语法（-、*、1. 等）
- **智能解析**：解析 AI 响应，识别可应用的内容块

**实现位置**：
- 前端：新建 `utils/contentParser.ts` - 内容识别工具函数

#### 6.2.2 应用方式

**技术实现**：
- **应用选项**：
  - 插入到光标位置
  - 替换选中文本
  - 追加到文档末尾
  - 应用到工作区文档（创建新文件）
- **应用预览**：Diff 视图预览
- **部分应用**：用户选择要应用的段落

**实现位置**：
- 前端：新建 `QuickApplyButton.tsx` - 快捷应用按钮
- 前端：`MessageContextMenu.tsx` - 右键菜单扩展

### 6.3 文档修改可视化

#### 6.3.1 Diff 视图

**技术实现**：
- **Diff 计算**：文本对比算法（字符级别或单词级别）
- **可视化展示**：红删绿增（删除用红色，添加用绿色）
- **显示位置**：在编辑器中显示（重要）

**实现位置**：
- 前端：`DocumentDiffView.tsx` - Diff 视图组件（需要扩展）
- 前端：`TipTapEditor.tsx` - 集成 Diff 视图到编辑器

#### 6.3.2 多层确认机制

**技术实现**：
- **段落级别确认**：每个修改段落有独立的确认按钮
- **文档级别确认**：每个被修改的文档有确认按钮
- **全部确认**：一次性确认所有修改
- **跳过功能**：支持跳过段落、跳过文档

**实现位置**：
- 前端：`DocumentDiffView.tsx` - 确认按钮实现

---

## 七、性能优化方案

### 7.1 请求优化

**技术实现**：
- **请求去重**：相同请求的缓存和复用（基于参数哈希）
- **请求优先级**：更细粒度的优先级（0-10 级）
- **请求批处理**：批量处理相似请求

**实现位置**：
- 后端：`ai_service.rs` - 请求管理逻辑

### 7.2 响应优化

**技术实现**：
- **响应缓存**：相似请求的响应缓存（可选，需谨慎使用）
- **响应压缩**：大响应的压缩传输
- **响应预加载**：预测性响应预加载（可选）

**实现位置**：
- 后端：`ai_service.rs` - 响应处理逻辑

### 7.3 上下文优化

**技术实现**：
- **上下文索引**：建立工作区文件索引
- **上下文缓存**：常用上下文的缓存
- **上下文压缩**：智能摘要生成、关键信息提取

**实现位置**：
- 后端：新建 `context_index_service.rs` - 上下文索引服务

---

## 八、安全性方案

### 8.1 API Key 安全

**技术实现**：
- **加密存储**：使用系统密钥链（macOS Keychain、Windows Credential Manager）
- **使用监控**：监控 API Key 使用频率、调用次数
- **轮换机制**：支持 API Key 轮换

**实现位置**：
- 后端：`ai_service.rs` - API Key 管理
- 后端：新建 `api_key_monitor.rs` - 使用监控

### 8.2 敏感信息过滤

**技术实现**：
- **自动检测**：检测密码、密钥、API Key、个人信息等
  - 正则表达式匹配（密码模式、API Key 模式等）
  - 关键词匹配（password、secret、key 等）
  - 上下文分析（结合上下文判断是否为敏感信息）
- **检测位置**：发送给 AI 前检测（前端和后端双重检测）
- **脱敏处理**：敏感信息替换为占位符（如 `[REDACTED]`）
- **用户警告**：检测到敏感信息时提示用户，询问是否继续
- **日志记录**：记录敏感信息使用情况（不记录具体内容）

**实现位置**：
- 后端：新建 `sensitive_info_filter.rs` - 敏感信息检测和脱敏
- 前端：`InlineChatInput.tsx` - 输入时检测
- 前端：`Toast.tsx` - 警告提示

### 8.3 权限控制

**技术实现**：
- **工具权限分级**：
  - 只读权限：read_file、list_files、search_files
  - 读写权限：create_file、update_file、create_folder
  - 危险操作：delete_file、move_file、edit_current_editor_document
- **权限确认机制**：
  - 只读操作：自动执行，无需确认
  - 读写操作：自动执行，记录日志
  - 危险操作：需要用户明确确认
- **权限审计日志**：记录所有工具调用（工具名称、参数、结果、时间）

**实现位置**：
- 后端：`tool_service.rs` - 权限控制逻辑
- 后端：新建 `tool_permission.rs` - 权限定义和检查
- 前端：`ToolCallCard.tsx` - 危险操作确认按钮

---

## 九、进度反馈和用户体验

### 9.1 进度反馈机制

**技术实现**：
- **进度类型**：
  - 工作规划进度：规划生成中、规划完成
  - 执行步骤进度：步骤状态、已完成步骤数/总步骤数
  - 工具调用进度：工具执行中、工具完成
  - 流式响应进度：已接收字符数、预计剩余时间
- **进度展示**：
  - 进度条：整体进度百分比
  - 步骤列表：每个步骤的状态
  - 工具调用列表：每个工具调用的状态
  - 时间估算：基于历史数据估算剩余时间

**实现位置**：
- 前端：`ExecutionProgressBar.tsx` - 进度条组件
- 前端：`ChatPanel.tsx` - 集成进度展示
- 状态管理：`chatStore.ts` - 管理进度状态

### 9.2 用户交互优化

**技术实现**：
- **取消机制**：
  - 取消整个任务：取消所有步骤和工具调用
  - 取消单个步骤：取消正在执行的步骤
  - 取消工具调用：取消正在执行的工具调用
- **重试机制**：
  - 重试失败步骤：重新执行失败的步骤
  - 重试工具调用：重新执行失败的工具调用
- **跳过机制**：
  - 跳过步骤：跳过不需要的步骤
  - 跳过工具调用：跳过不需要的工具调用

**实现位置**：
- 前端：`ExecutionStepCard.tsx` - 取消/重试/跳过按钮
- 前端：`ToolCallDetailCard.tsx` - 取消/重试按钮
- 后端：`tool_service.rs` - 取消/重试逻辑

---

## 十、数据流和状态管理

### 10.1 数据流设计

**前端到后端**：
- 用户输入 → Tauri Command → AI 服务
- 状态更新 → Zustand Store → UI 更新

**后端到前端**：
- AI 响应 → Tauri Event → 前端事件处理
- 工具调用结果 → Tauri Event → 状态更新

**流式响应处理**：
- 后端：流式返回 chunk → 前端：累积更新 UI
- 去重机制：前端和后端双重去重
- 空 chunk 过滤：跳过空事件

### 10.2 状态管理设计

**Zustand Store 结构**：
- `chatStore.ts`：
  - `tabs`：标签页列表
  - `activeTabId`：当前活动标签页
  - `messages`：消息列表（按 tab_id 分组）
  - `workPlan`：工作规划（新增）
  - `executionSteps`：执行步骤状态（新增）
  - `toolCalls`：工具调用列表
  - `references`：引用列表

**状态更新策略**：
- 响应式更新：响应流式事件自动更新状态
- 批量更新：合并多个状态更新，减少渲染次数
- 持久化：关键状态自动持久化到 LocalStorage

---

## 十一、实现优先级和开发计划

### 11.1 P0 优先级（MVP 1.0 必须实现）

1. **工作规划和执行展示**（层次三）
   - 工作规划生成和展示
   - 分步执行展示
   - 步骤状态管理
   - 工具调用详情展示

2. **文档格式和样式匹配**（所有层次）
   - 格式识别
   - 样式匹配
   - 格式转换

3. **智能 Chunk 分割**（层次三）
   - 句子边界分割
   - Offset 跟踪
   - 去重机制

4. **工具调用取消机制**（层次三）
   - 请求 ID 管理
   - 取消信号传递
   - 取消处理逻辑

5. **错误级别分类**（所有层次）
   - Error/Warning/Info 三级分类
   - 不同级别的处理策略

6. **敏感信息过滤**（所有层次）
   - 敏感信息检测
   - 脱敏处理
   - 用户警告

### 11.2 P1 优先级（重要功能）

1. **隐式上下文自动收集**
   - 文件扫描服务
   - 相关性评分算法
   - 上下文变量服务

2. **会话持久化**
   - 会话序列化/反序列化
   - 会话存储到工作区
   - 会话加载和恢复

3. **工具注册和发现机制**
   - 工具注册表
   - 工具分类
   - 工具权限控制

4. **快捷应用到文档**（层次三）
   - 内容识别
   - 应用方式
   - 应用预览

5. **进度反馈**
   - 进度类型
   - 进度展示
   - 时间估算

### 11.3 P2 优先级（优化功能）

1. **上下文索引**（大工作区优化）
2. **请求去重机制**（性能优化）
3. **变量解析进度通知**（用户体验优化）
4. **多种编辑策略**（可选功能）

---

## 十二、技术难点和解决方案

### 12.1 工作规划生成

**难点**：AI 如何准确识别需要读取的文档和浏览的网站

**解决方案**：
- 在系统提示词中明确要求 AI 先分析任务
- 提供工作区文件列表给 AI（文件名、路径、大小）
- AI 根据任务需求选择相关文件
- 支持用户手动添加/删除文件

### 12.2 步骤依赖解析

**难点**：如何正确解析和执行有依赖关系的步骤

**解决方案**：
- 构建步骤依赖图（DAG）
- 使用拓扑排序确定执行顺序
- 支持并行执行无依赖关系的步骤
- 步骤失败时，依赖该步骤的后续步骤自动标记为失败

### 12.3 格式转换

**难点**：如何将 AI 生成的内容转换为目标格式

**解决方案**：
- 建立格式转换规则表
- Markdown → t-docx：使用 Pandoc 或自定义转换逻辑
- HTML → t-docx：提取内容，转换为 t-docx 样式
- 纯文本 → 其他格式：保持纯文本，不添加格式

### 12.4 流式响应去重

**难点**：如何避免重复显示相同的 chunk

**解决方案**：
- 后端：累积文本跟踪，跳过重复 chunk
- 前端：`accumulatedTextRef` 跟踪每个 tab 的累积文本
- 双重去重：前端和后端都进行去重检查

---

## 十三、测试策略

### 13.1 单元测试

**测试重点**：
- 工作规划生成逻辑
- 步骤依赖解析
- 格式转换逻辑
- 敏感信息检测
- JSON 修复机制

### 13.2 集成测试

**测试重点**：
- 完整的工作流程（规划 → 执行 → 结果）
- 工具调用链
- 流式响应处理
- 错误处理和重试

### 13.3 用户体验测试

**测试重点**：
- 工作规划和执行展示的可用性
- 进度反馈的准确性
- 取消/重试/跳过功能的正确性
- 错误提示的友好性

---

## 十四、总结

### 14.1 核心特性

1. **三层独立架构**：层次一/二静默执行，层次三完整展示
2. **工作规划和执行**：自动规划、分步执行、可视化展示
3. **格式和样式匹配**：自动识别格式，匹配样式要求
4. **智能 Chunk 分割**：按句子边界分割，提升流式显示质量
5. **工具调用优化**：注册机制、取消机制、权限控制
6. **错误处理优化**：三级分类、详情扩展、友好提示
7. **安全性保障**：API Key 安全、敏感信息过滤、权限控制

### 14.2 技术栈总结

- **前端**：React + TypeScript + Zustand + TipTap
- **后端**：Rust + Tauri + AI Providers
- **存储**：Zustand Store + LocalStorage + 文件系统
- **加密**：系统密钥链

### 14.3 开发建议

1. **分阶段实施**：按照优先级逐步实施
2. **向后兼容**：确保新功能不影响现有功能
3. **测试覆盖**：增加测试用例，确保质量
4. **文档更新**：及时更新设计文档和开发文档

---

**文档版本**：v2.0  
**创建日期**：2025年  
**最后更新**：2025年  
**维护者**：Binder 开发团队