# Binder（合页）第一阶段开发计划

## 文档信息

- **阶段名称**：基础架构搭建
- **开发周期**：4 周（Week 1-4）
- **开发目标**：稳定性和落地性为首要目标
- **版本**：v1.1（关键问题修复版）
- **创建日期**：2025年
- **最后更新**：2025年
- **更新说明**：修复了 Pandoc 二进制、文件树刷新、工作区显示等关键问题

## 总体目标

搭建可运行的应用框架，实现基础布局系统和文件树显示功能，为后续开发奠定坚实基础。

**核心原则**：
- ✅ **稳定性优先**：每个功能都要有完整的错误处理和边界情况处理
- ✅ **落地性保证**：每个功能都要有具体的代码实现路径和验收标准
- ✅ **零盲点**：功能的每个环节、流程的每个逻辑链、UI的每个像素都要有明确的设计

---

## Week 1-2：项目初始化和基础框架

### 目标
创建 Tauri 项目，配置开发环境，搭建项目目录结构，实现基础的前后端通信。

### 1.1 项目创建和配置（Day 1-2）

#### 1.1.1 Tauri 项目初始化

**任务**：创建 Tauri + React + TypeScript 项目

**具体步骤**：

1. **初始化 Tauri 项目**
   ```bash
   npm create tauri-app@latest binder-app
   cd binder-app
   ```
   - 选择：React + TypeScript
   - 选择：Vite 作为构建工具
   - 选择：Tauri 2.x 版本

2. **验证项目结构**
   ```
   binder-app/
   ├── src/                    # 前端源代码
   ├── src-tauri/              # Rust 后端源代码
   │   ├── src/
   │   │   └── main.rs
   │   ├── Cargo.toml
   │   └── tauri.conf.json
   ├── package.json
   ├── tsconfig.json
   └── vite.config.ts
   ```

3. **测试项目运行**
   - 运行 `npm run tauri dev`，确保应用能正常启动
   - 验证热重载功能
   - 验证前端和后端通信正常

**验收标准**：
- ✅ 项目能够正常启动
- ✅ 前端 React 应用正常渲染
- ✅ 后端 Rust 代码正常编译
- ✅ 无编译错误和警告

#### 1.1.2 开发环境配置

**任务**：配置开发工具和代码规范

**具体步骤**：

1. **配置 TypeScript**
   - 修改 `tsconfig.json`，启用严格模式
   ```json
   {
     "compilerOptions": {
       "strict": true,
       "noUnusedLocals": true,
       "noUnusedParameters": true,
       "noImplicitReturns": true
     }
   }
   ```

2. **配置 ESLint + Prettier**
   - 安装依赖：`npm install -D eslint prettier @typescript-eslint/eslint-plugin @typescript-eslint/parser`
   - 创建 `.eslintrc.json`
   - 创建 `.prettierrc`
   - 配置 VSCode 设置（`.vscode/settings.json`）

3. **配置 Rust 工具链**
   - 安装 `rustfmt`：`rustup component add rustfmt`
   - 安装 `clippy`：`rustup component add clippy`
   - 创建 `.rustfmt.toml` 配置文件

4. **准备 Pandoc 二进制文件** ⚠️ **关键：必须在此阶段完成**
   - 下载 Pandoc 静态二进制文件：
     - macOS arm64：`pandoc-macos-arm64`
     - macOS x64：`pandoc-macos-x64`
     - Windows x64：`pandoc-windows-x64.exe`
     - Linux x64：`pandoc-linux-x64`
   - 创建目录：`src-tauri/resources/bin/`
   - 放置二进制文件到对应目录
   - 总大小约 70MB（每个平台约 17-18MB）

4. **配置 Git**
   - 创建 `.gitignore`
   - 初始化 Git 仓库
   - 创建初始提交

**验收标准**：
- ✅ TypeScript 严格模式启用
- ✅ ESLint 和 Prettier 正常运作
- ✅ Rust 代码格式化正常
- ✅ Git 仓库初始化完成

#### 1.1.3 项目目录结构搭建

**任务**：按照开发方案创建完整的目录结构

**具体步骤**：

1. **前端目录结构**
   ```
   src/
   ├── components/
   │   ├── Layout/
   │   ├── FileTree/
   │   ├── Editor/
   │   ├── Chat/
   │   └── Common/
   ├── stores/
   ├── services/
   ├── hooks/
   ├── utils/
   ├── types/
   └── App.tsx
   ```

2. **后端目录结构**
   ```
   src-tauri/src/
   ├── main.rs
   ├── services/
   │   ├── mod.rs
   │   ├── file_system.rs
   │   ├── file_tree.rs
   │   └── workspace.rs
   ├── commands/
   │   ├── mod.rs
   │   └── file_commands.rs
   ├── models/
   │   ├── mod.rs
   │   └── file.rs
   └── utils/
       ├── mod.rs
       └── path_utils.rs
   ```

3. **创建基础文件**
   - 创建所有目录
   - 创建 `mod.rs` 文件用于模块导出
   - 创建空的 TypeScript 接口文件

**验收标准**：
- ✅ 目录结构完整
- ✅ 所有 `mod.rs` 文件正确导出
- ✅ 项目能够正常编译

#### 1.1.4 依赖安装和配置

**任务**：安装所有必需的依赖包

**具体步骤**：

1. **前端依赖**
   ```bash
   npm install react react-dom
   npm install -D @types/react @types/react-dom
   npm install zustand
   npm install tailwindcss postcss autoprefixer
   npm install @headlessui/react
   npm install react-draggable react-resizable
   ```

2. **配置 Tailwind CSS**
   - 运行 `npx tailwindcss init -p`
   - 配置 `tailwind.config.js`
   - 创建 `src/index.css`，导入 Tailwind 指令

3. **后端依赖**
   在 `Cargo.toml` 中添加：
   ```toml
   [dependencies]
   tauri = { version = "2.0", features = ["macos-private-api"] }
   serde = { version = "1.0", features = ["derive"] }
   serde_json = "1.0"
   tokio = { version = "1.0", features = ["full"] }
   notify = "6.0"
   dirs = "5.0"
   which = "5.0"  # 用于查找系统 Pandoc
   ```

4. **配置 Pandoc 资源打包** ⚠️ **关键：必须在此阶段完成**
   
   修改 `tauri.conf.json`：
   ```json
   {
     "tauri": {
       "bundle": {
         "resources": [
           "resources/bin/**"
         ]
       }
     }
   }
   ```
   
   确保 Pandoc 二进制文件会被打包到应用中。

4. **验证依赖**
   - 运行 `npm install`
   - 运行 `cargo build`
   - 确保无依赖冲突

**验收标准**：
- ✅ 所有依赖安装成功
- ✅ Tailwind CSS 配置正确
- ✅ 前端和后端都能正常构建

### 1.2 基础框架搭建（Day 3-5）

#### 1.2.1 前端基础架构

**任务**：搭建 React 应用基础架构

**具体步骤**：

1. **创建 App.tsx**
   ```typescript
   // src/App.tsx
   import { useState } from 'react';
   import MainLayout from './components/Layout/MainLayout';
   
   function App() {
     return <MainLayout />;
   }
   
   export default App;
   ```

2. **创建基础状态管理**
   ```typescript
   // src/stores/layoutStore.ts
   import { create } from 'zustand';
   
   interface LayoutState {
     // 待实现
   }
   
   export const useLayoutStore = create<LayoutState>(() => ({}));
   ```

3. **创建基础组件**
   - `src/components/Common/Button.tsx`：基础按钮组件
   - `src/components/Common/Modal.tsx`：基础模态框组件

4. **配置路由（如需要）**
   - 目前阶段不需要路由，所有内容都在 MainLayout 中

**验收标准**：
- ✅ App.tsx 正常渲染
- ✅ Zustand store 能够正常使用
- ✅ 基础组件能够正常显示

#### 1.2.2 后端基础架构

**任务**：搭建 Rust 后端基础架构

**具体步骤**：

1. **配置 main.rs**
   ```rust
   // src-tauri/src/main.rs
   #![cfg_attr(
       all(not(debug_assertions), target_os = "windows"),
       windows_subsystem = "windows"
   )]
   
   mod commands;
   mod models;
   mod services;
   mod utils;
   
   fn main() {
       tauri::Builder::default()
           .invoke_handler(tauri::generate_handler![])
           .run(tauri::generate_context!())
           .expect("error while running tauri application");
   }
   ```

2. **实现 Pandoc 服务（基础框架）** ⚠️ **关键：必须在此阶段完成**
   ```rust
   // src-tauri/src/services/pandoc_service.rs
   use std::path::{Path, PathBuf};
   use which::which;
   
   pub struct PandocService {
       pandoc_path: Option<PathBuf>,
   }
   
   impl PandocService {
       pub fn new() -> Self {
           // 1. 优先查找系统 Pandoc
           let system_pandoc = which("pandoc").ok();
           
           // 2. 如果系统没有，使用内置 Pandoc
           let bundled_pandoc = if system_pandoc.is_none() {
               Self::get_bundled_pandoc_path()
           } else {
               None
           };
           
           Self {
               pandoc_path: system_pandoc.or(bundled_pandoc),
           }
       }
       
       fn get_bundled_pandoc_path() -> Option<PathBuf> {
           // 获取资源目录路径
           let resource_dir = tauri::api::path::resource_dir()
               .expect("无法获取资源目录");
           
           #[cfg(target_os = "macos")]
           let binary_name = if cfg!(target_arch = "aarch64") {
               "pandoc-macos-arm64"
           } else {
               "pandoc-macos-x64"
           };
           
           #[cfg(target_os = "windows")]
           let binary_name = "pandoc-windows-x64.exe";
           
           #[cfg(target_os = "linux")]
           let binary_name = "pandoc-linux-x64";
           
           let pandoc_path = resource_dir
               .join("bin")
               .join(binary_name);
           
           if pandoc_path.exists() {
               Some(pandoc_path)
           } else {
               None
           }
       }
       
       pub fn is_available(&self) -> bool {
           self.pandoc_path.is_some()
       }
       
       pub fn get_path(&self) -> Option<&PathBuf> {
           self.pandoc_path.as_ref()
       }
   }
   ```
   
   在 `services/mod.rs` 中导出：
   ```rust
   pub mod pandoc_service;
   ```
   
   **验收标准**：
   - ✅ 能够正确检测系统 Pandoc
   - ✅ 系统 Pandoc 不可用时，能够找到内置 Pandoc
   - ✅ Pandoc 路径能够正确返回

2. **创建模块文件**
   - `src-tauri/src/services/mod.rs`
   - `src-tauri/src/commands/mod.rs`
   - `src-tauri/src/models/mod.rs`
   - `src-tauri/src/utils/mod.rs`

3. **创建基础服务框架**
   ```rust
   // src-tauri/src/services/file_system.rs
   pub struct FileSystemService;
   
   impl FileSystemService {
       pub fn new() -> Self {
           Self
       }
   }
   ```

**验收标准**：
- ✅ main.rs 能够正常编译
- ✅ 所有模块文件正确导出
- ✅ 应用能够正常启动

#### 1.2.3 Tauri IPC 通信实现

**任务**：实现基础的前后端通信

**具体步骤**：

1. **创建测试命令（后端）**
   ```rust
   // src-tauri/src/commands/file_commands.rs
   use serde::{Deserialize, Serialize};
   
   #[derive(Debug, Serialize, Deserialize)]
   pub struct TestResponse {
       pub message: String,
   }
   
   #[tauri::command]
   pub async fn test_command(message: String) -> Result<TestResponse, String> {
       Ok(TestResponse {
           message: format!("Echo: {}", message),
       })
   }
   ```

2. **注册命令**
   ```rust
   // src-tauri/src/commands/mod.rs
   pub mod file_commands;
   
   pub use file_commands::test_command;
   ```

3. **在 main.rs 中注册**
   ```rust
   use commands::test_command;
   
   .invoke_handler(tauri::generate_handler![test_command])
   ```

4. **前端调用测试**
   ```typescript
   // src/services/fileService.ts
   import { invoke } from '@tauri-apps/api/core';
   
   export const testCommand = async (message: string) => {
     return await invoke<{ message: string }>('test_command', { message });
   };
   ```

5. **在组件中测试**
   ```typescript
   // src/App.tsx
   import { testCommand } from './services/fileService';
   
   useEffect(() => {
     testCommand('Hello from frontend').then(console.log);
   }, []);
   ```

**验收标准**：
- ✅ 前端能够成功调用后端命令
- ✅ 后端能够返回正确的数据
- ✅ 通信过程无错误

### 1.3 构建和打包配置（Day 6-7）

#### 1.3.1 开发构建配置

**任务**：配置开发环境的构建流程

**具体步骤**：

1. **配置 Vite**
   - 检查 `vite.config.ts`
   - 配置开发服务器端口
   - 配置代理（如需要）

2. **配置 Tauri**
   - 检查 `tauri.conf.json`
   - 配置应用信息（名称、版本等）
   - 配置窗口设置（大小、可调整等）

3. **测试开发流程**
   - 运行 `npm run tauri dev`
   - 验证热重载
   - 验证前端和后端代码修改都能生效

**验收标准**：
- ✅ 开发服务器正常启动
- ✅ 热重载功能正常
- ✅ 前端和后端代码修改都能实时生效

#### 1.3.2 生产构建配置

**任务**：配置生产环境的构建和打包

**具体步骤**：

1. **配置生产构建**
   - 测试 `npm run tauri build`
   - 验证应用能够正常打包

2. **配置代码压缩和优化**
   - Vite 自动处理前端代码压缩
   - Rust 使用 release 模式构建

3. **测试打包产物**
   - 运行打包后的应用
   - 验证所有功能正常

**验收标准**：
- ✅ 应用能够正常打包
- ✅ 打包后的应用能够正常运行
- ✅ 打包体积在合理范围内

---

## Week 3：布局系统

### 目标
实现可拖拽布局系统，包括边缘吸附功能和欢迎对话框。

### 3.1 布局状态管理（Day 8-9）

#### 3.1.1 创建布局 Store

**任务**：使用 Zustand 创建布局状态管理

**具体实现**：

```typescript
// src/stores/layoutStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface LayoutState {
  // 文件树状态
  fileTree: {
    position: 'left' | 'right' | 'top' | 'bottom' | 'floating';
    width: number;
    visible: boolean;
  };
  
  // 编辑器状态
  editor: {
    position: 'center' | 'left' | 'right' | 'full';
  };
  
  // 聊天窗口状态
  chat: {
    position: 'right' | 'left' | 'top' | 'bottom' | 'floating';
    width: number;
    visible: boolean;
    isFloating: boolean;
    floatingPosition: { x: number; y: number };
  };
  
  // 首次打开标志
  isFirstOpen: boolean;
  showWelcomeDialog: boolean;
  
  // Actions
  setFileTreePosition: (position: LayoutState['fileTree']['position']) => void;
  setFileTreeWidth: (width: number) => void;
  setFileTreeVisible: (visible: boolean) => void;
  setChatPosition: (position: LayoutState['chat']['position']) => void;
  setChatWidth: (width: number) => void;
  setChatVisible: (visible: boolean) => void;
  setChatFloating: (isFloating: boolean, position?: { x: number; y: number }) => void;
  setShowWelcomeDialog: (show: boolean) => void;
  markFirstOpenComplete: () => void;
}

const defaultState = {
  fileTree: {
    position: 'left' as const,
    width: 250,
    visible: true,
  },
  editor: {
    position: 'center' as const,
  },
  chat: {
    position: 'right' as const,
    width: 350,
    visible: true,
    isFloating: false,
    floatingPosition: { x: 0, y: 0 },
  },
  isFirstOpen: true,
  showWelcomeDialog: true,
};

export const useLayoutStore = create<LayoutState>()(
  persist(
    (set) => ({
      ...defaultState,
      
      setFileTreePosition: (position) =>
        set((state) => ({
          fileTree: { ...state.fileTree, position },
        })),
      
      setFileTreeWidth: (width) =>
        set((state) => ({
          fileTree: { ...state.fileTree, width },
        })),
      
      setFileTreeVisible: (visible) =>
        set((state) => ({
          fileTree: { ...state.fileTree, visible },
        })),
      
      setChatPosition: (position) =>
        set((state) => ({
          chat: { ...state.chat, position },
        })),
      
      setChatWidth: (width) =>
        set((state) => ({
          chat: { ...state.chat, width },
        })),
      
      setChatVisible: (visible) =>
        set((state) => ({
          chat: { ...state.chat, visible },
        })),
      
      setChatFloating: (isFloating, position) =>
        set((state) => ({
          chat: {
            ...state.chat,
            isFloating,
            floatingPosition: position || state.chat.floatingPosition,
          },
        })),
      
      setShowWelcomeDialog: (show) =>
        set({ showWelcomeDialog: show }),
      
      markFirstOpenComplete: () =>
        set({ isFirstOpen: false }),
    }),
    {
      name: 'binder-layout-storage',
    }
  )
);
```

**验收标准**：
- ✅ Store 能够正常创建和使用
- ✅ 状态持久化功能正常
- ✅ 所有 action 函数正常工作

#### 3.1.2 布局类型定义

**任务**：创建布局相关的 TypeScript 类型定义

**具体实现**：

```typescript
// src/types/layout.ts
export type PanelPosition = 'left' | 'right' | 'top' | 'bottom' | 'floating';

export type EditorPosition = 'center' | 'left' | 'right' | 'full';

export interface PanelState {
  position: PanelPosition;
  width: number;
  visible: boolean;
}

export interface ChatState extends PanelState {
  isFloating: boolean;
  floatingPosition: { x: number; y: number };
}

export interface LayoutState {
  fileTree: PanelState;
  editor: {
    position: EditorPosition;
  };
  chat: ChatState;
  isFirstOpen: boolean;
  showWelcomeDialog: boolean;
}
```

**验收标准**：
- ✅ 所有类型定义完整
- ✅ 类型检查通过
- ✅ 与 Store 类型一致

### 3.2 主布局组件（Day 10-12）

#### 3.2.1 MainLayout 组件实现

**任务**：实现主布局组件，包含三个面板的基本结构

**具体实现**：

```typescript
// src/components/Layout/MainLayout.tsx
import React from 'react';
import { useLayoutStore } from '../../stores/layoutStore';
import WelcomeDialog from './WelcomeDialog';
import FileTreePanel from '../FileTree/FileTreePanel';
import EditorPanel from '../Editor/EditorPanel';
import ChatPanel from '../Chat/ChatPanel';

const MainLayout: React.FC = () => {
  const { showWelcomeDialog, setShowWelcomeDialog } = useLayoutStore();
  const { fileTree, chat, editor } = useLayoutStore();

  return (
    <div className="w-screen h-screen overflow-hidden bg-gray-50 dark:bg-gray-900 flex">
      {/* 欢迎对话框 */}
      {showWelcomeDialog && (
        <WelcomeDialog onClose={() => setShowWelcomeDialog(false)} />
      )}

      {/* 文件树面板 */}
      {fileTree.visible && (
        <FileTreePanel
          position={fileTree.position}
          width={fileTree.width}
        />
      )}

      {/* 编辑器面板 */}
      <EditorPanel position={editor.position} />

      {/* 聊天面板 */}
      {chat.visible && (
        <ChatPanel
          position={chat.position}
          width={chat.width}
          isFloating={chat.isFloating}
          floatingPosition={chat.floatingPosition}
        />
      )}
    </div>
  );
};

export default MainLayout;
```

**验收标准**：
- ✅ 三个面板基本结构显示正常
- ✅ 布局状态能够正确应用
- ✅ 欢迎对话框能够正常显示和关闭

#### 3.2.2 面板基础组件

**任务**：创建三个面板的基础组件

**具体实现**：

1. **FileTreePanel 组件**
```typescript
// src/components/FileTree/FileTreePanel.tsx
import React from 'react';

interface FileTreePanelProps {
  position: 'left' | 'right' | 'top' | 'bottom' | 'floating';
  width: number;
}

const FileTreePanel: React.FC<FileTreePanelProps> = ({ position, width }) => {
  const getPositionClasses = () => {
    switch (position) {
      case 'left':
        return 'border-r border-gray-200 dark:border-gray-700';
      case 'right':
        return 'border-l border-gray-200 dark:border-gray-700';
      case 'top':
        return 'border-b border-gray-200 dark:border-gray-700';
      case 'bottom':
        return 'border-t border-gray-200 dark:border-gray-700';
      default:
        return '';
    }
  };

  return (
    <div
      className={`bg-white dark:bg-gray-800 ${getPositionClasses()}`}
      style={{ width: position === 'left' || position === 'right' ? width : '100%' }}
    >
      <div className="p-4">
        <h2 className="text-lg font-semibold">文件树</h2>
        {/* 文件树内容将在 Week 4 实现 */}
      </div>
    </div>
  );
};

export default FileTreePanel;
```

2. **EditorPanel 组件**
```typescript
// src/components/Editor/EditorPanel.tsx
import React from 'react';

interface EditorPanelProps {
  position: 'center' | 'left' | 'right' | 'full';
}

const EditorPanel: React.FC<EditorPanelProps> = ({ position }) => {
  return (
    <div className="flex-1 bg-white dark:bg-gray-900">
      <div className="p-4">
        <h2 className="text-lg font-semibold">编辑器</h2>
        {/* 编辑器内容将在后续阶段实现 */}
      </div>
    </div>
  );
};

export default EditorPanel;
```

3. **ChatPanel 组件**
```typescript
// src/components/Chat/ChatPanel.tsx
import React from 'react';

interface ChatPanelProps {
  position: 'right' | 'left' | 'top' | 'bottom' | 'floating';
  width: number;
  isFloating: boolean;
  floatingPosition: { x: number; y: number };
}

const ChatPanel: React.FC<ChatPanelProps> = ({
  position,
  width,
  isFloating,
  floatingPosition,
}) => {
  if (isFloating) {
    return (
      <div
        className="fixed bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg"
        style={{
          width,
          left: floatingPosition.x,
          top: floatingPosition.y,
          zIndex: 1000,
        }}
      >
        <div className="p-4">
          <h2 className="text-lg font-semibold">AI 聊天</h2>
        </div>
      </div>
    );
  }

  const getPositionClasses = () => {
    switch (position) {
      case 'left':
        return 'border-r border-gray-200 dark:border-gray-700';
      case 'right':
        return 'border-l border-gray-200 dark:border-gray-700';
      case 'top':
        return 'border-b border-gray-200 dark:border-gray-700';
      case 'bottom':
        return 'border-t border-gray-200 dark:border-gray-700';
      default:
        return '';
    }
  };

  return (
    <div
      className={`bg-white dark:bg-gray-800 ${getPositionClasses()}`}
      style={{ width: position === 'left' || position === 'right' ? width : '100%' }}
    >
      <div className="p-4">
        <h2 className="text-lg font-semibold">AI 聊天</h2>
      </div>
    </div>
  );
};

export default ChatPanel;
```

**验收标准**：
- ✅ 三个面板组件都能正常渲染
- ✅ 面板位置和大小能够正确应用
- ✅ 浮动模式能够正常显示

### 3.3 简化布局方案（Day 13-15）⚠️ **方案调整：简化拖拽逻辑**

#### 3.3.1 简化布局方案

**任务**：采用固定三栏布局 + 聊天窗口可折叠方案（参考 Cursor）

**原因**：react-draggable + react-resizable 实现成本高，容易出 bug。固定布局更稳定，用户体验也足够好。

**具体步骤**：

1. **更新布局 Store（简化）**
   ```typescript
   // src/stores/layoutStore.ts（更新）
   interface LayoutState {
     // 文件树：固定在左侧，可调整宽度
     fileTree: {
       width: number;
       visible: boolean;
     };
     
     // 编辑器：始终在中间，占满剩余空间
     editor: {
       // 不需要位置配置
     };
     
     // 聊天窗口：固定在右侧，可折叠，可调整宽度
     chat: {
       width: number;
       visible: boolean;
     };
   }
   ```

2. **简化 MainLayout 组件**
   ```typescript
   // src/components/Layout/MainLayout.tsx（更新）
   const MainLayout: React.FC = () => {
     const { fileTree, chat } = useLayoutStore();
     
     return (
       <div className="w-screen h-screen overflow-hidden bg-gray-50 dark:bg-gray-900 flex">
         {/* 文件树：左侧固定 */}
         {fileTree.visible && (
           <div
             className="bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700"
             style={{ width: fileTree.width }}
           >
             <FileTree />
           </div>
         )}
         
         {/* 编辑器：中间自适应 */}
         <div className="flex-1">
           <EditorPanel />
         </div>
         
         {/* 聊天窗口：右侧固定 */}
         {chat.visible && (
           <div
             className="bg-white dark:bg-gray-800 border-l border-gray-200 dark:border-gray-700"
             style={{ width: chat.width }}
           >
             <ChatPanel />
           </div>
         )}
       </div>
     );
   };
   ```

3. **添加面板宽度调整功能（可选）**
   - 在面板边缘添加可拖拽的分隔条
   - 使用简单的鼠标事件处理，不依赖复杂库

**验收标准**：
- ✅ 三栏布局显示正常
- ✅ 文件树和聊天窗口可以调整宽度
- ✅ 聊天窗口可以折叠/展开

2. **创建可拖拽面板组件**
   ```typescript
   // src/components/Layout/DraggablePanel.tsx
   import React from 'react';
   import Draggable from 'react-draggable';

   interface DraggablePanelProps {
     children: React.ReactNode;
     onDrag: (position: { x: number; y: number }) => void;
     initialPosition?: { x: number; y: number };
   }

   const DraggablePanel: React.FC<DraggablePanelProps> = ({
     children,
     onDrag,
     initialPosition = { x: 0, y: 0 },
   }) => {
     return (
       <Draggable
         defaultPosition={initialPosition}
         onDrag={(e, data) => onDrag({ x: data.x, y: data.y })}
       >
         <div>{children}</div>
       </Draggable>
     );
   };

   export default DraggablePanel;
   ```

**验收标准**：
- ✅ 拖拽库安装成功
- ✅ 可拖拽面板组件能够正常工作

#### 3.3.2 面板宽度调整功能（可选，简化方案）

**任务**：实现面板边缘可拖拽调整宽度

**具体实现**（如果采用简化方案，这部分可选）：

```typescript
// src/hooks/useEdgeSnap.ts
import { useCallback } from 'react';

interface EdgeSnapConfig {
  threshold: number; // 吸附阈值（像素）
  snapDistance: number; // 吸附距离（像素）
}

const defaultConfig: EdgeSnapConfig = {
  threshold: 50,
  snapDistance: 0,
};

export const useEdgeSnap = (config: EdgeSnapConfig = defaultConfig) => {
  const checkEdgeSnap = useCallback(
    (
      position: { x: number; y: number },
      containerSize: { width: number; height: number },
      panelSize: { width: number; height: number }
    ) => {
      const { threshold, snapDistance } = config;
      let snappedPosition = { ...position };
      let snapEdge: 'left' | 'right' | 'top' | 'bottom' | null = null;

      // 检查左边缘
      if (position.x <= threshold && position.x >= -threshold) {
        snappedPosition.x = snapDistance;
        snapEdge = 'left';
      }
      // 检查右边缘
      else if (
        position.x >= containerSize.width - panelSize.width - threshold &&
        position.x <= containerSize.width - panelSize.width + threshold
      ) {
        snappedPosition.x = containerSize.width - panelSize.width - snapDistance;
        snapEdge = 'right';
      }

      // 检查上边缘
      if (position.y <= threshold && position.y >= -threshold) {
        snappedPosition.y = snapDistance;
        snapEdge = 'top';
      }
      // 检查下边缘
      else if (
        position.y >= containerSize.height - panelSize.height - threshold &&
        position.y <= containerSize.height - panelSize.height + threshold
      ) {
        snappedPosition.y = containerSize.height - panelSize.height - snapDistance;
        snapEdge = 'bottom';
      }

      return {
        position: snappedPosition,
        snapEdge,
      };
    },
    [config]
  );

  return { checkEdgeSnap };
};
```

**验收标准**：
- ✅ 边缘吸附逻辑正确实现
- ✅ 阈值和距离配置生效
- ✅ 能够正确识别四个边缘

#### 3.3.3 聊天窗口折叠/展开功能

**任务**：实现聊天窗口的折叠和展开

**具体实现**：

```typescript
// src/components/Chat/ChatPanel.tsx（简化版）
import React from 'react';
import { useLayoutStore } from '../../stores/layoutStore';

const ChatPanel: React.FC = () => {
  const { chat, setChatVisible, setChatWidth } = useLayoutStore();

  const handleToggle = () => {
    setChatVisible(!chat.visible);
  };

  return (
    <>
      {/* 折叠按钮（当窗口隐藏时显示） */}
      {!chat.visible && (
        <button
          onClick={handleToggle}
          className="fixed right-0 top-1/2 transform -translate-y-1/2 bg-blue-600 text-white px-2 py-4 rounded-l-lg hover:bg-blue-700 transition-colors z-10"
        >
          ▶
        </button>
      )}

      {/* 聊天面板 */}
      {chat.visible && (
        <div
          className="bg-white dark:bg-gray-800 border-l border-gray-200 dark:border-gray-700 flex flex-col"
          style={{ width: chat.width }}
        >
          <div className="flex justify-between items-center p-2 border-b border-gray-200 dark:border-gray-700">
            <h2 className="text-lg font-semibold">AI 聊天</h2>
            <button
              onClick={handleToggle}
              className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            >
              ✕
            </button>
          </div>
          <div className="flex-1 overflow-y-auto">
            {/* 聊天内容 */}
          </div>
        </div>
      )}
    </>
  );
};

export default ChatPanel;
```

**验收标准**：
- ✅ 聊天窗口可以折叠/展开
- ✅ 折叠时显示展开按钮
- ✅ 按钮位置和样式正确

### 3.4 欢迎对话框（Day 16-17）

#### 3.4.1 WelcomeDialog 组件实现

**任务**：实现欢迎对话框 UI

**具体实现**：

```typescript
// src/components/Layout/WelcomeDialog.tsx
import React, { useState, useEffect } from 'react';
import { useLayoutStore } from '../../stores/layoutStore';
import { invoke } from '@tauri-apps/api/core';

interface WelcomeDialogProps {
  onClose: () => void;
}

const WelcomeDialog: React.FC<WelcomeDialogProps> = ({ onClose }) => {
  const [recentWorkspaces, setRecentWorkspaces] = useState<string[]>([]);

  useEffect(() => {
    // 加载最近工作区
    loadRecentWorkspaces();
  }, []);

  const loadRecentWorkspaces = async () => {
    try {
      const workspaces = await invoke<string[]>('load_workspaces');
      setRecentWorkspaces(workspaces);
    } catch (error) {
      console.error('加载最近工作区失败:', error);
    }
  };

  const handleOpenWorkspace = async () => {
    try {
      // 调用后端命令打开工作区（Week 4 实现）
      // const path = await invoke<string>('open_workspace_dialog');
      // if (path) {
      //   onClose();
      // }
      console.log('打开工作区');
    } catch (error) {
      console.error('打开工作区失败:', error);
    }
  };

  const handleCreateWorkspace = async () => {
    try {
      // 调用后端命令创建工作区（Week 4 实现）
      console.log('创建工作区');
    } catch (error) {
      console.error('创建工作区失败:', error);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl p-8">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-2xl font-bold">欢迎使用 Binder</h1>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            ✕
          </button>
        </div>

        <div className="space-y-4 mb-6">
          <button
            onClick={handleOpenWorkspace}
            className="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            打开工作区
          </button>
          <button
            onClick={handleCreateWorkspace}
            className="w-full px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
          >
            新建工作区
          </button>
        </div>

        <div>
          <h2 className="text-lg font-semibold mb-3">最近的工作区</h2>
          {recentWorkspaces.length > 0 ? (
            <div className="space-y-2">
              {recentWorkspaces.map((workspace, index) => (
                <button
                  key={index}
                  onClick={async () => {
                    try {
                      // 调用后端命令打开工作区
                      await invoke('open_workspace', { path: workspace });
                      onClose();
                    } catch (error) {
                      console.error('打开工作区失败:', error);
                      alert('打开工作区失败');
                    }
                  }}
                  className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                >
                  {workspace}
                </button>
              ))}
            </div>
          ) : (
            <div className="text-gray-500 dark:text-gray-400 text-sm">
              暂无最近工作区
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default WelcomeDialog;
```

**验收标准**：
- ✅ 欢迎对话框 UI 完整
- ✅ 打开/新建工作区按钮功能正常
- ✅ 最近工作区列表能够显示（Week 4 实现数据加载）

---

## Week 4：文件树基础

### 目标
实现文件树的基础功能，包括文件树构建、文件选择和打开、新建文件下拉菜单。

### 4.1 后端文件系统服务（Day 18-20）

#### 4.1.1 文件树服务实现

**任务**：实现 Rust 后端的文件树构建逻辑

**具体实现**：

```rust
// src-tauri/src/services/file_tree.rs
use std::path::{Path, PathBuf};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTreeNode {
    pub name: String,
    pub path: String,
    pub is_directory: bool,
    pub children: Option<Vec<FileTreeNode>>,
}

pub struct FileTreeService;

impl FileTreeService {
    pub fn new() -> Self {
        Self
    }

    pub fn build_tree(&self, root: &Path, max_depth: usize) -> Result<FileTreeNode, String> {
        if !root.exists() {
            return Err(format!("路径不存在: {}", root.display()));
        }

        if !root.is_dir() {
            return Err(format!("路径不是目录: {}", root.display()));
        }

        self.build_node(root, max_depth, 0)
    }

    fn build_node(
        &self,
        path: &Path,
        max_depth: usize,
        current_depth: usize,
    ) -> Result<FileTreeNode, String> {
        let name = path
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("")
            .to_string();

        let is_directory = path.is_dir();

        let children = if is_directory && current_depth < max_depth {
            match self.read_directory(path) {
                Ok(mut entries) => {
                    // 排序：目录在前，然后按名称排序
                    entries.sort_by(|a, b| {
                        match (a.is_directory, b.is_directory) {
                            (true, false) => std::cmp::Ordering::Less,
                            (false, true) => std::cmp::Ordering::Greater,
                            _ => a.name.cmp(&b.name),
                        }
                    });

                    Some(
                        entries
                            .into_iter()
                            .filter_map(|entry| {
                                self.build_node(&PathBuf::from(&entry.path), max_depth, current_depth + 1)
                                    .ok()
                            })
                            .collect(),
                    )
                }
                Err(_) => None,
            }
        } else {
            None
        };

        Ok(FileTreeNode {
            name,
            path: path.to_string_lossy().to_string(),
            is_directory,
            children,
        })
    }

    fn read_directory(&self, path: &Path) -> Result<Vec<FileTreeNode>, String> {
        let entries = std::fs::read_dir(path)
            .map_err(|e| format!("读取目录失败: {}", e))?;

        let mut nodes = Vec::new();

        for entry in entries {
            let entry = entry.map_err(|e| format!("读取目录项失败: {}", e))?;
            let path = entry.path();
            let name = entry
                .file_name()
                .to_string_lossy()
                .to_string();

            // 跳过隐藏文件（以 . 开头，除了 . 和 ..）
            if name.starts_with('.') && name != "." && name != ".." {
                continue;
            }

            nodes.push(FileTreeNode {
                name,
                path: path.to_string_lossy().to_string(),
                is_directory: path.is_dir(),
                children: None,
            });
        }

        Ok(nodes)
    }
}
```

**验收标准**：
- ✅ 能够正确构建文件树
- ✅ 目录排序正确（目录在前）
- ✅ 隐藏文件被正确过滤
- ✅ 错误处理完整

#### 4.1.2 文件系统操作命令

**任务**：实现 Tauri 命令用于文件操作

**具体实现**：

```rust
// src-tauri/src/commands/file_commands.rs
use crate::services::file_tree::FileTreeService;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

#[tauri::command]
pub async fn build_file_tree(root_path: String, max_depth: usize) -> Result<FileTreeNode, String> {
    let service = FileTreeService::new();
    let root = PathBuf::from(root_path);
    service.build_tree(&root, max_depth)
}

#[tauri::command]
pub async fn read_file_content(path: String) -> Result<String, String> {
    std::fs::read_to_string(&path)
        .map_err(|e| format!("读取文件失败: {}", e))
}

#[tauri::command]
pub async fn write_file(path: String, content: String) -> Result<(), String> {
    std::fs::write(&path, content)
        .map_err(|e| format!("写入文件失败: {}", e))
}

#[tauri::command]
pub async fn create_file(path: String, file_type: &str) -> Result<(), String> {
    let path_buf = PathBuf::from(&path);
    
    // 确保父目录存在
    if let Some(parent) = path_buf.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("创建目录失败: {}", e))?;
    }

    // 创建文件
    std::fs::File::create(&path)
        .map_err(|e| format!("创建文件失败: {}", e))?;

    // 如果是特定类型，写入初始内容
    match file_type {
        "docx" => {
            // DOCX 文件需要特殊处理，后续实现
        }
        "md" => {
            std::fs::write(&path, "# 新文档\n")
                .map_err(|e| format!("写入初始内容失败: {}", e))?;
        }
        "html" => {
            std::fs::write(&path, "<!DOCTYPE html>\n<html><head><title>新文档</title></head><body></body></html>\n")
                .map_err(|e| format!("写入初始内容失败: {}", e))?;
        }
        _ => {}
    }

    Ok(())
}
```

**验收标准**：
- ✅ 所有命令能够正常编译
- ✅ 文件树构建命令能够返回正确数据
- ✅ 文件读写命令能够正常工作

#### 4.1.3 工作区服务实现

**任务**：实现工作区管理服务

**具体实现**：

```rust
// src-tauri/src/services/workspace.rs
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::fs;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Workspace {
    pub path: String,
    pub name: String,
    pub opened_at: String, // ISO 8601 格式
}

pub struct WorkspaceService {
    config_path: PathBuf,
}

impl WorkspaceService {
    pub fn new() -> Result<Self, String> {
        let config_dir = dirs::config_dir()
            .ok_or("无法获取配置目录")?;
        let binder_dir = config_dir.join("binder");
        
        // 创建配置目录
        fs::create_dir_all(&binder_dir)
            .map_err(|e| format!("创建配置目录失败: {}", e))?;

        Ok(Self {
            config_path: binder_dir.join("workspaces.json"),
        })
    }

    pub fn save_workspace(&self, workspace: &Workspace) -> Result<(), String> {
        let mut workspaces = self.load_workspaces()?;
        
        // 移除已存在的同路径工作区
        workspaces.retain(|w| w.path != workspace.path);
        
        // 添加到开头
        workspaces.insert(0, workspace.clone());
        
        // 只保留最近 10 个
        workspaces.truncate(10);
        
        // 保存到文件
        let json = serde_json::to_string_pretty(&workspaces)
            .map_err(|e| format!("序列化失败: {}", e))?;
        fs::write(&self.config_path, json)
            .map_err(|e| format!("写入配置文件失败: {}", e))?;

        Ok(())
    }

    pub fn load_workspaces(&self) -> Result<Vec<Workspace>, String> {
        if !self.config_path.exists() {
            return Ok(Vec::new());
        }

        let content = fs::read_to_string(&self.config_path)
            .map_err(|e| format!("读取配置文件失败: {}", e))?;
        
        serde_json::from_str(&content)
            .map_err(|e| format!("解析配置文件失败: {}", e))
    }

    pub fn open_workspace(&self, path: &str) -> Result<Workspace, String> {
        let workspace = Workspace {
            path: path.to_string(),
            name: PathBuf::from(path)
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("未命名工作区")
                .to_string(),
            opened_at: chrono::Utc::now().to_rfc3339(),
        };

        // 保存到最近工作区列表
        self.save_workspace(&workspace)?;

        Ok(workspace)
    }
}
```

在 `Cargo.toml` 中添加 chrono 依赖：
```toml
chrono = { version = "0.4", features = ["serde"] }
```

添加工作区命令：
```rust
// src-tauri/src/commands/file_commands.rs（添加）
#[tauri::command]
pub async fn load_workspaces() -> Result<Vec<String>, String> {
    let service = crate::services::workspace::WorkspaceService::new()
        .map_err(|e| format!("初始化工作区服务失败: {}", e))?;
    
    let workspaces = service.load_workspaces()?;
    Ok(workspaces.into_iter().map(|w| w.path).collect())
}

#[tauri::command]
pub async fn open_workspace(path: String) -> Result<(), String> {
    let service = crate::services::workspace::WorkspaceService::new()
        .map_err(|e| format!("初始化工作区服务失败: {}", e))?;
    
    service.open_workspace(&path)?;
    Ok(())
}
```
```

**验收标准**：
- ✅ 工作区服务能够正常创建
- ✅ 工作区保存和加载功能正常
- ✅ 配置文件格式正确

### 4.2 前端文件树组件（Day 21-23）

#### 4.2.1 文件树状态管理

**任务**：创建文件树相关的状态管理

**具体实现**：

```typescript
// src/stores/fileStore.ts
import { create } from 'zustand';
import { FileTreeNode } from '../types/file';

interface FileState {
  currentWorkspace: string | null;
  fileTree: FileTreeNode | null;
  selectedFile: string | null;
  openFiles: string[]; // 打开的文件路径列表
  
  setCurrentWorkspace: (path: string | null) => void;
  setFileTree: (tree: FileTreeNode | null) => void;
  setSelectedFile: (path: string | null) => void;
  addOpenFile: (path: string) => void;
  removeOpenFile: (path: string) => void;
}

export const useFileStore = create<FileState>((set) => ({
  currentWorkspace: null,
  fileTree: null,
  selectedFile: null,
  openFiles: [],

  setCurrentWorkspace: (path) => set({ currentWorkspace: path }),
  setFileTree: (tree) => set({ fileTree: tree }),
  setSelectedFile: (path) => set({ selectedFile: path }),
  addOpenFile: (path) =>
    set((state) => ({
      openFiles: state.openFiles.includes(path)
        ? state.openFiles
        : [...state.openFiles, path],
    })),
  removeOpenFile: (path) =>
    set((state) => ({
      openFiles: state.openFiles.filter((p) => p !== path),
    })),
}));
```

**验收标准**：
- ✅ 文件状态管理正常工作
- ✅ 所有 action 函数正常工作

#### 4.2.2 文件服务实现

**任务**：实现前端文件服务，调用后端命令

**具体实现**：

```typescript
// src/services/fileService.ts
import { invoke } from '@tauri-apps/api/core';
import { FileTreeNode } from '../types/file';

export const fileService = {
  async buildFileTree(rootPath: string, maxDepth: number = 5): Promise<FileTreeNode> {
    return await invoke<FileTreeNode>('build_file_tree', {
      rootPath,
      maxDepth,
    });
  },

  async readFile(path: string): Promise<string> {
    return await invoke<string>('read_file_content', { path });
  },

  async writeFile(path: string, content: string): Promise<void> {
    await invoke('write_file', { path, content });
  },

  async createFile(path: string, fileType: string): Promise<void> {
    await invoke('create_file', { path, fileType });
  },
};
```

**验收标准**：
- ✅ 所有服务方法能够正常调用
- ✅ 类型定义正确
- ✅ 错误处理完整

#### 4.2.3 FileTree 组件实现

**任务**：实现文件树 UI 组件

**具体实现**：

1. **更新 FileTreePanel 组件**
```typescript
// src/components/FileTree/FileTreePanel.tsx（更新）
import React, { useRef } from 'react';
import FileTree, { FileTreeRef } from './FileTree';
import NewFileButton from './NewFileButton';

interface FileTreePanelProps {
  position: 'left' | 'right' | 'top' | 'bottom' | 'floating';
  width: number;
}

const FileTreePanel: React.FC<FileTreePanelProps> = ({ position, width }) => {
  const fileTreeRef = useRef<FileTreeRef>(null);

  const getPositionClasses = () => {
    switch (position) {
      case 'left':
        return 'border-r border-gray-200 dark:border-gray-700';
      case 'right':
        return 'border-l border-gray-200 dark:border-gray-700';
      case 'top':
        return 'border-b border-gray-200 dark:border-gray-700';
      case 'bottom':
        return 'border-t border-gray-200 dark:border-gray-700';
      default:
        return '';
    }
  };

  return (
    <div
      className={`bg-white dark:bg-gray-800 ${getPositionClasses()}`}
      style={{ width: position === 'left' || position === 'right' ? width : '100%' }}
    >
      <div className="p-2 border-b border-gray-200 dark:border-gray-700">
        <NewFileButton fileTreeRef={fileTreeRef} />
      </div>
      <div className="flex-1 overflow-hidden">
        <FileTree ref={fileTreeRef} />
      </div>
    </div>
  );
};
```

2. **FileTree 组件实现（支持刷新）**
```typescript
// src/components/FileTree/FileTree.tsx
import React, { useState, useEffect, useImperativeHandle, forwardRef } from 'react';
import { useFileStore } from '../../stores/fileStore';
import { fileService } from '../../services/fileService';
import FileTreeNode from './FileTreeNode';

export interface FileTreeRef {
  refresh: () => Promise<void>;
}

const FileTree = forwardRef<FileTreeRef>((props, ref) => {
  const { currentWorkspace, fileTree, setFileTree, setSelectedFile } = useFileStore();
  const [expandedPaths, setExpandedPaths] = useState<Set<string>>(new Set());
  const [isLoading, setIsLoading] = useState(false);

  const loadFileTree = async () => {
    if (!currentWorkspace) return;
    setIsLoading(true);
    try {
      const tree = await fileService.buildFileTree(currentWorkspace, 5);
      setFileTree(tree);
      // 默认展开根目录
      setExpandedPaths(new Set([tree.path]));
    } catch (error) {
      console.error('加载文件树失败:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // 导出刷新函数供外部调用
  useImperativeHandle(ref, () => ({
    refresh: loadFileTree,
  }));

  useEffect(() => {
    if (currentWorkspace) {
      loadFileTree();
    }
  }, [currentWorkspace]);

  const toggleExpand = (path: string) => {
    setExpandedPaths((prev) => {
      const next = new Set(prev);
      if (next.has(path)) {
        next.delete(path);
      } else {
        next.add(path);
      }
      return next;
    });
  };

  if (!fileTree) {
    return (
      <div className="p-4 text-gray-500 dark:text-gray-400">
        请选择工作区
      </div>
    );
  }

  return (
    <div className="h-full overflow-y-auto flex flex-col">
      {/* 工作区根目录显示 ⚠️ 关键：必须显示当前工作区 */}
      {currentWorkspace && (
        <div className="px-3 py-2 bg-gray-100 dark:bg-gray-700 border-b border-gray-200 dark:border-gray-600">
          <div className="text-xs text-gray-600 dark:text-gray-400 mb-1">当前工作区</div>
          <div className="text-sm font-semibold text-gray-800 dark:text-gray-200 truncate" title={currentWorkspace}>
            {currentWorkspace.split('/').pop() || currentWorkspace}
          </div>
          <div className="text-xs text-gray-500 dark:text-gray-500 truncate" title={currentWorkspace}>
            {currentWorkspace}
          </div>
        </div>
      )}

      {/* 文件树内容 */}
      <div className="flex-1 overflow-y-auto">
        {fileTree ? (
          <FileTreeNode
            node={fileTree}
            level={0}
            expandedPaths={expandedPaths}
            onToggleExpand={toggleExpand}
            onSelectFile={handleFileSelect}
          />
        ) : (
          <div className="p-4 text-center text-gray-500 dark:text-gray-400">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-2"></div>
            <div>加载文件树中...</div>
          </div>
        )}
      </div>
    </div>
  );
};

});

FileTree.displayName = 'FileTree';

export default FileTree;
export type { FileTreeRef };
```

#### 4.2.4 安装图标库

**任务**：安装并使用图标库替代 emoji

**具体步骤**：

1. **安装图标库**
   ```bash
   npm install @heroicons/react
   # 或
   npm install lucide-react
   ```

2. **创建文件图标组件**
   ```typescript
   // src/components/FileTree/FileIcon.tsx
   import { DocumentIcon, FolderIcon } from '@heroicons/react/24/outline';
   import { FolderOpenIcon } from '@heroicons/react/24/solid';
   
   interface FileIconProps {
     isDirectory: boolean;
     isExpanded?: boolean;
     fileName: string;
   }
   
   const FileIcon: React.FC<FileIconProps> = ({ isDirectory, isExpanded, fileName }) => {
     if (isDirectory) {
       return isExpanded ? (
         <FolderOpenIcon className="w-5 h-5 text-blue-500" />
       ) : (
         <FolderIcon className="w-5 h-5 text-blue-400" />
       );
     }
     
     const ext = fileName.split('.').pop()?.toLowerCase();
     // 可以根据扩展名返回不同图标
     return <DocumentIcon className="w-5 h-5 text-gray-400" />;
   };
   
   export default FileIcon;
   ```

#### 4.2.5 FileTreeNode 组件实现

**任务**：实现文件树节点组件，支持展开/折叠和选择

**具体实现**：

```typescript
// src/components/FileTree/FileTreeNode.tsx
import React from 'react';
import { FileTreeNode as FileTreeNodeType } from '../../types/file';

interface FileTreeNodeProps {
  node: FileTreeNodeType;
  level: number;
  expandedPaths: Set<string>;
  onToggleExpand: (path: string) => void;
  onSelectFile: (path: string) => void;
}

const FileTreeNode: React.FC<FileTreeNodeProps> = ({
  node,
  level,
  expandedPaths,
  onToggleExpand,
  onSelectFile,
}) => {
  const isExpanded = expandedPaths.has(node.path);
  const hasChildren = node.children && node.children.length > 0;

  const handleClick = () => {
    if (node.is_directory) {
      onToggleExpand(node.path);
    } else {
      onSelectFile(node.path);
    }
  };

  // 使用图标库替代 emoji
  import FileIcon from './FileIcon';

  return (
    <div>
      <div
        className={`flex items-center px-2 py-1 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer ${
          !node.is_directory ? 'select-none' : ''
        }`}
        style={{ paddingLeft: `${level * 16 + 8}px` }}
        onClick={handleClick}
      >
        {node.is_directory && (
          <span className="mr-1 text-xs text-gray-400">
            {isExpanded ? '▼' : '▶'}
          </span>
        )}
        <FileIcon 
          isDirectory={node.is_directory} 
          isExpanded={isExpanded} 
          fileName={node.name}
        />
        <span className="ml-2 flex-1 truncate">{node.name}</span>
      </div>
      {isExpanded && hasChildren && (
        <div>
          {node.children!.map((child) => (
            <FileTreeNode
              key={child.path}
              node={child}
              level={level + 1}
              expandedPaths={expandedPaths}
              onToggleExpand={onToggleExpand}
              onSelectFile={onSelectFile}
            />
          ))}
        </div>
      )}
    </div>
  );
};

export default FileTreeNode;
```

**验收标准**：
- ✅ 文件树能够正常显示
- ✅ 展开/折叠功能正常
- ✅ 文件选择功能正常
- ✅ 图标显示正确

### 4.3 新建文件功能（Day 24-25）

**注意**：创建文件后必须刷新文件树（见 4.4 节）

#### 4.3.1 新建文件下拉菜单

**任务**：实现新建文件按钮和下拉菜单

**具体实现**：

```typescript
// src/components/FileTree/NewFileButton.tsx
import React, { useState, useRef, useEffect } from 'react';
import { useFileStore } from '../../stores/fileStore';
import { fileService } from '../../services/fileService';
import { FileTreeRef } from './FileTree';

interface NewFileButtonProps {
  fileTreeRef?: React.RefObject<FileTreeRef>;
}

const NewFileButton: React.FC<NewFileButtonProps> = ({ fileTreeRef }) => {
  const [isOpen, setIsOpen] = useState(false);
  const { currentWorkspace } = useFileStore();
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleCreateFile = async (fileType: string) => {
    if (!currentWorkspace) {
      alert('请先选择工作区');
      return;
    }

    const fileName = prompt(`请输入文件名（${fileType}）:`);
    if (!fileName) return;

    const extension = fileType === 'folder' ? '' : `.${fileType}`;
    const filePath = `${currentWorkspace}/${fileName}${extension}`;

    try {
      if (fileType === 'folder') {
        // 创建文件夹（后续实现）
        console.log('创建文件夹:', filePath);
      } else {
        await fileService.createFile(filePath, fileType);
      }
      setIsOpen(false);
      // ⚠️ 关键：刷新文件树
      if (fileTreeRef?.current) {
        await fileTreeRef.current.refresh();
      }
    } catch (error) {
      console.error('创建文件失败:', error);
      alert('创建文件失败');
    }
  };

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
      >
        + 新建
      </button>
      {isOpen && (
        <div className="absolute top-full left-0 mt-1 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded shadow-lg z-10 min-w-[150px]">
          <button
            onClick={() => handleCreateFile('docx')}
            className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700"
          >
            📄 新建文档 (.docx)
          </button>
          <button
            onClick={() => handleCreateFile('md')}
            className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700"
          >
            📝 新建 Markdown (.md)
          </button>
          <button
            onClick={() => handleCreateFile('html')}
            className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700"
          >
            🌐 新建 HTML (.html)
          </button>
          <div className="border-t border-gray-200 dark:border-gray-700" />
          <button
            onClick={() => handleCreateFile('folder')}
            className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700"
          >
            📁 新建文件夹
          </button>
        </div>
      )}
    </div>
  );
};

export default NewFileButton;
```

**验收标准**：
- ✅ 新建按钮正常显示
- ✅ 下拉菜单能够正常打开和关闭
- ✅ 创建文件功能正常
- ✅ 点击外部区域能够关闭菜单

### 4.4 文件树刷新机制（Day 26）⚠️ **关键：必须实现**

#### 4.4.1 文件树刷新实现

**任务**：实现文件树自动刷新机制

**具体实现**：

1. **方案一：手动刷新（简单）**
   ```typescript
   // src/components/FileTree/FileTree.tsx（更新）
   const refreshFileTree = async () => {
     if (!currentWorkspace) return;
     try {
       const tree = await fileService.buildFileTree(currentWorkspace, 5);
       setFileTree(tree);
     } catch (error) {
       console.error('刷新文件树失败:', error);
     }
   };

   // 导出刷新函数供其他组件调用
   export { refreshFileTree };
   ```

2. **方案二：事件驱动刷新（推荐）** ⚠️ **更优雅的方案**
   
   后端实现：
   ```rust
   // src-tauri/src/services/file_tree.rs（添加）
   use tauri::Manager;
   
   impl FileTreeService {
       pub fn watch_and_emit_changes(
           workspace_path: &Path,
           app_handle: tauri::AppHandle,
       ) -> Result<(), String> {
           use notify::{Watcher, RecursiveMode};
           
           let mut watcher = notify::recommended_watcher(move |result| {
               match result {
                   Ok(event) => {
                       // 防抖：500ms 内的事件合并
                       // 发送事件到前端
                       app_handle.emit_all("file-tree-changed", ()).ok();
                   }
                   Err(e) => eprintln!("文件监听错误: {:?}", e),
               }
           })
           .map_err(|e| format!("创建文件监听器失败: {}", e))?;
           
           watcher
               .watch(workspace_path, RecursiveMode::Recursive)
               .map_err(|e| format!("监听目录失败: {}", e))?;
           
           Ok(())
       }
   }
   ```
   
   前端监听：
   ```typescript
   // src/components/FileTree/FileTree.tsx（更新）
   import { listen } from '@tauri-apps/api/event';
   
   useEffect(() => {
     const setupFileWatcher = async () => {
       if (!currentWorkspace) return;
       
       // 启动后端文件监听
       await invoke('start_file_watcher', { workspacePath: currentWorkspace });
       
       // 监听文件变化事件
       const unlisten = await listen('file-tree-changed', () => {
         // 防抖处理
         const timer = setTimeout(() => {
           loadFileTree();
         }, 500);
         
         return () => clearTimeout(timer);
       });
       
       return () => {
         unlisten();
       };
     };
     
     setupFileWatcher();
   }, [currentWorkspace]);
   ```

3. **在文件操作后触发刷新**
   ```typescript
   // 在新建文件、删除文件等操作后
   // 方案一：直接调用 refreshFileTree()
   // 方案二：等待事件自动触发刷新
   ```

**验收标准**：
- ✅ 创建文件后，文件树能够自动刷新
- ✅ 删除文件后，文件树能够自动刷新
- ✅ 刷新过程流畅，不阻塞 UI
- ✅ 事件监听不会造成内存泄漏

### 4.5 文件打开功能（Day 27）

#### 4.5.1 文件选择处理

**任务**：实现文件选择后的处理逻辑

**具体实现**：

```typescript
// src/components/FileTree/FileTree.tsx（更新）
const handleFileSelect = async (path: string) => {
  setSelectedFile(path);
  
  // 检查文件类型，决定如何打开
  const ext = path.split('.').pop()?.toLowerCase();
  
  if (ext === 'docx' || ext === 'md' || ext === 'html') {
    // 添加到打开文件列表
    addOpenFile(path);
    
    // TODO: 在编辑器中打开文件（后续阶段实现）
    console.log('打开文件:', path);
  } else {
    // 其他文件类型，可以显示提示
    console.log('不支持的文件类型:', ext);
  }
};
```

**验收标准**：
- ✅ 文件选择功能正常
- ✅ 支持的文件类型能够正确识别
- ✅ 打开文件列表能够正确更新

#### 4.5.2 工作区选择对话框

**任务**：实现选择工作区的对话框（后端命令）

**具体实现**：

```rust
// src-tauri/src/commands/file_commands.rs（添加）
#[tauri::command]
pub async fn open_workspace_dialog() -> Result<Option<String>, String> {
    use tauri::api::dialog::blocking::FileDialogBuilder;
    
    let path = FileDialogBuilder::new()
        .set_title("选择工作区")
        .set_directory(true)
        .pick_folder();
    
    Ok(path.map(|p| p.to_string_lossy().to_string()))
}
```

**前端调用**：

```typescript
// src/services/fileService.ts（添加）
export const openWorkspaceDialog = async (): Promise<string | null> => {
  const path = await invoke<string | null>('open_workspace_dialog');
  return path;
};
```

**验收标准**：
- ✅ 工作区选择对话框能够正常打开
- ✅ 选择的路径能够正确返回
- ✅ 文件树能够正确加载

---

## 验收标准总结

### Week 1-2 验收标准
- ✅ Tauri 项目创建成功，能够正常运行
- ✅ 开发环境配置完整（TypeScript、ESLint、Prettier、Rust）
- ✅ 项目目录结构完整
- ✅ 基础的前后端通信正常
- ✅ 构建和打包配置正确
- ✅ **Pandoc 二进制文件已准备并配置打包**（关键！）
- ✅ **Pandoc 服务框架已实现**（能够检测系统和内置 Pandoc）

### Week 3 验收标准
- ✅ 布局状态管理正常工作（简化版）
- ✅ 三个面板（文件树、编辑器、聊天）基本结构显示正常
- ✅ **固定三栏布局正常工作**
- ✅ **聊天窗口可以折叠/展开**
- ✅ **面板宽度调整功能正常**（可选）
- ✅ 欢迎对话框 UI 完整，功能正常

### Week 4 验收标准
- ✅ 文件树服务能够正确构建文件树
- ✅ 文件树 UI 组件能够正常显示
- ✅ 文件展开/折叠功能正常
- ✅ 文件选择功能正常
- ✅ 新建文件下拉菜单功能正常
- ✅ 文件创建功能正常
- ✅ 工作区选择对话框功能正常
- ✅ 文件树能够正确加载和刷新

---

## 注意事项

1. **错误处理**：所有功能都要有完整的错误处理和用户提示
2. **类型安全**：TypeScript 和 Rust 都要使用严格类型检查
3. **性能优化**：文件树加载要考虑性能，避免阻塞 UI
4. **用户体验**：所有交互都要有视觉反馈（加载状态、错误提示等）
5. **代码质量**：遵循代码规范，保持代码整洁和可维护

---

## 关键问题修复总结

### ⚠️ 高危问题（必须修复）

1. **Pandoc 内置二进制** ✅ 已修复
   - 在 Week 1-2 Day 2 完成 Pandoc 二进制文件准备
   - 在 Week 1-2 Day 6 完成 Pandoc 服务框架实现
   - 在 `tauri.conf.json` 中配置资源打包

2. **文件树刷新机制** ✅ 已修复
   - 在 Week 4 Day 26 实现文件树刷新功能
   - 提供两种方案：手动刷新（简单）和事件驱动刷新（推荐）
   - 在所有文件操作后自动刷新

3. **工作区根目录显示** ✅ 已修复
   - 在 Week 4 Day 21 添加工作区根目录显示区域
   - 显示工作区名称和完整路径

4. **欢迎对话框的最近工作区** ✅ 已修复
   - 在 Week 4 Day 23 连接后端 `load_workspaces` 命令
   - 在欢迎对话框中显示最近工作区列表

### ⚠️ 中危问题（建议修复）

5. **简化布局方案** ✅ 已修复
   - 采用固定三栏布局 + 聊天窗口可折叠方案
   - 移除复杂的拖拽和边缘吸附逻辑
   - 更稳定，更容易维护

6. **FileTreeNode 性能优化** 📝 建议添加
   - 如果文件树层级很深（>5层）或节点很多（>500个），建议添加虚拟滚动
   - 可以后续根据实际性能情况决定是否添加

7. **文件图标优化** ✅ 已修复
   - 在 Week 4 Day 21 添加图标库支持
   - 使用 @heroicons/react 替代 emoji

8. **加载状态** ✅ 已修复
   - 在文件树加载时显示 spinner
   - 在文件树组件中添加加载状态显示

## 补充说明

### 缺失的类型定义

需要在第一阶段补充以下类型定义文件：

1. **文件类型定义**
```typescript
// src/types/file.ts
export interface FileTreeNode {
  name: string;
  path: string;
  is_directory: boolean;
  children?: FileTreeNode[];
}
```

2. **工作区类型定义**
```typescript
// src/types/workspace.ts
export interface Workspace {
  path: string;
  name: string;
  opened_at: string;
}
```

### 必要的依赖补充

在 `Cargo.toml` 中需要添加：

```toml
[dependencies]
dirs = "5.0"  # 用于获取配置目录
```

### 关键实现细节

1. **文件树刷新机制**：当创建新文件后，需要手动刷新文件树（Week 4 Day 27 需要实现）

2. **文件树更新优化**：考虑使用事件监听（第二阶段实现），目前使用手动刷新

3. **错误边界**：需要在 React 应用中添加错误边界组件，防止单个组件错误导致整个应用崩溃

4. **加载状态**：所有异步操作都要显示加载状态，提升用户体验

### 测试要求

每个功能完成后需要：
- ✅ 手动测试所有功能点
- ✅ 测试错误情况处理
- ✅ 测试边界情况
- ✅ 验证 UI 显示正确
- ✅ 验证状态管理正确

---

## 下一步

第一阶段完成后，进入第二阶段：文档编辑器核心功能（Week 5-10）

