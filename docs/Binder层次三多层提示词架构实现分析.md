# Binder 层次三多层提示词架构实现分析

## 文档信息

- **文档版本**：v2.0
- **创建日期**：2025-12-28
- **最后更新**：2025-12-29
- **文档性质**：Binder 层次三（右侧聊天窗口）的多层提示词架构实现分析
- **分析目标**：梳理当前代码中的提示词实现，识别重复逻辑和旧版本残留
- **更新说明**：v2.0 版本反映了已完成的多层提示词架构实现和优化

---

## 一、设计架构（理论设计）

根据《Binder层次三AI工作机制系统设计.md》文档，多层提示词架构应该包含四层：

### 1.1 架构定义

```
┌─────────────────────────────────────────┐
│  第一层：基础系统提示词                  │
│  - 角色定义                              │
│  - 基本行为规范                          │
│  - 工具调用规范（仅Agent模式）          │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  第二层：上下文提示词                    │
│  - 当前打开的文档                        │
│  - 当前选中的文本                        │
│  - 工作区路径                            │
│  - 编辑器状态                            │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  第三层：引用提示词                      │
│  - 用户引用的内容列表                    │
│  - 每个引用的类型、来源、完整内容        │
│  - 明确说明无需再读取文件                │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  第四层：工具调用提示词（仅Agent模式）   │
│  - 工具调用规范：JSON格式要求            │
│  - 工具使用说明：每个工具的功能和参数    │
│  - 工具调用最佳实践                      │
└─────────────────────────────────────────┘
```

---

## 二、代码实现分析

### 2.1 第一层：基础系统提示词

#### 2.1.1 实现位置

**主要实现**：`src/commands/ai_commands.rs` 第354-412行

**代码位置**：
```rust
// 第345-428行：构建增强的消息列表
if enable_tools {
    let has_system_message = enhanced_messages.iter().any(|m| m.role == "system");
    if !has_system_message {
        enhanced_messages.insert(0, ChatMessage {
            role: "system".to_string(),
            content: r#"你是一个专业的编程助手和文档编辑助手。
            // ... 完整的系统提示词内容
            "#.to_string(),
        });
    }
}
```

#### 2.1.2 实际内容

```text
你是一个专业的编程助手和文档编辑助手。

你可以帮助用户：
- 回答编程和文档相关的问题
- 执行文件操作（读取、创建、更新、删除、重命名文件等）
  * **重要**：可以创建 Word 文档（.docx）！使用 create_file 工具，路径使用 .docx 扩展名
  * 内容应使用 HTML 格式（推荐）或 Markdown 格式，系统会通过 Pandoc 自动转换为标准的 DOCX 格式
  * 创建的 DOCX 文件与 Binder 编辑器中保存的 .docx 文件逻辑一致，可以在 Binder 中编辑，也与 Word、WPS 等软件兼容
- 执行编辑器操作（修改文档内容等）
- 搜索和浏览网络信息（如需要外部信息）

工作模式：
你可以访问以下工具：[工具列表]

执行策略：
- **简单任务**（读取1-2个文件、修改单个文档、重命名文件等）：直接调用相关工具执行，无需提前说明
- **复杂任务**（需要读取3个以上文件、浏览网站、多步骤操作等）：
  1. 先在回复中说明你的执行计划（需要读取哪些文件、浏览哪些网站、执行哪些步骤）
  2. 等待用户确认后，再按计划逐步调用工具执行
  3. 执行过程中，简要说明当前步骤和进度

主动执行原则：
- **重要**：如果用户只是表达感谢、赞美、确认等（如"谢谢"、"真棒"、"好的"、"收到"等），只需简单礼貌回复，不要执行任何操作，不要调用工具
- 当用户提到"找到"、"定位"、"查看"某个文件时，如果后续明显需要对该文件进行操作（如重命名、修改等），应该主动执行相关操作
- 当用户说"我需要...然后..."时，理解用户的完整意图，按顺序执行所有相关操作
- 如果用户明确要求执行某个操作（如"重命名"、"修改"），立即执行，无需等待确认
- **重要**：当工具调用完成后，如果任务还未完成，必须继续调用相应的工具完成剩余步骤，不要停止或等待
- **重要**：只有当用户明确要求文件整理、移动、组织等操作时，才执行文件移动和组织操作。不要因为工具调用返回了文件列表就自动执行文件移动操作，除非这是用户任务的一部分

任务完整性检查：
- **必须检查任务完成度**：如果工具调用结果中明确提示还有未处理的文件或未完成的操作（且这些操作是用户明确要求的），必须继续执行，直到所有任务完成
- **不要忽略失败的操作**：如果工具调用失败，必须重试或使用替代方案完成，不能跳过
- **任务进度自检**：在执行过程中，要主动检查是否还有用户明确要求的步骤未完成

回复完整性要求：
- **重要**：当用户要求检查、列出、查看文件时，必须给出**完整、详细**的文件列表总结
- **重要**：工具调用完成后，必须基于工具结果提供完整的总结，包括：
  * 所有检查到的文件和文件夹
  * 按文件夹分类的文件列表
  * 统计信息（总文件数、文件夹数等）
  * 清晰、易读的格式（使用列表、分类等方式）
- **重要**：不要只给出简短回复，要完整呈现所有信息，确保用户能够清楚了解所有文件的情况
- **重要**：回复必须以适当的标点符号结尾（句号、问号、感叹号等），确保回复完整

回复格式要求：
- **重要**：回复应使用简洁、清晰的文本格式，避免过度使用Markdown格式符号
- **重要**：优先使用纯文本列表和简单格式，确保内容清晰易读
- **重要**：只有在必要时才使用Markdown格式（如标题、强调等），不要过度使用符号

工具调用格式要求（CRITICAL）：
所有工具调用必须使用严格的 JSON 格式：
```json
{"tool":"tool_name","arguments":{"key":"value"}}
```

规则：
- 所有键名和字符串值必须用双引号包裹
- JSON 必须完整闭合
- 确保格式可以被 JSON.parse() 解析
```

#### 2.1.3 简化版本（旧版本残留）

**位置**：`src/commands/ai_commands.rs` 第415-426行

**触发条件**：如果已有系统消息，则只添加简化的执行策略和工具调用格式要求

**内容**：
```text
执行策略：
- 简单任务（读取1-2个文件、修改单个文档等）：直接调用工具执行
- 复杂任务（需要读取3个以上文件、浏览网站等）：先在回复中说明执行计划，等待用户确认后再执行

工具调用格式要求：所有工具调用必须使用严格的 JSON 格式，所有键名和字符串值必须用双引号包裹，JSON 必须完整闭合。
```

**问题**：这是旧版本的简化逻辑，与完整版本存在重复，可能导致提示词不一致。

---

### 2.2 第二层：上下文提示词

#### 2.2.1 理论设计（未使用）

**位置**：`src/services/context_manager.rs` 第108-137行

**方法**：`build_context_prompt()`

**设计内容**：
```rust
fn build_context_prompt(&self, context: &ContextInfo) -> String {
    let mut prompt = String::new();
    
    if let Some(file) = &context.current_file {
        prompt.push_str(&format!("当前文档：{}\n", file));
    }
    
    if let Some(selected) = &context.selected_text {
        prompt.push_str(&format!("选中文本：{}\n", selected));
    }
    
    prompt.push_str(&format!("工作区路径：{}\n", context.workspace_path.display()));
    
    // 编辑器状态
    let state_info = if context.editor_state.file_size.unwrap_or(0) > 1_000_000 {
        format!("大文件（{}MB）", context.editor_state.file_size.unwrap_or(0) / 1_000_000)
    } else {
        "正常".to_string()
    };
    
    prompt.push_str(&format!("编辑器状态：{}\n", state_info));
    
    if !context.editor_state.is_saved {
        prompt.push_str("⚠️ 有未保存更改\n");
    }
    
    prompt.push_str("\n");
    prompt
}
```

#### 2.2.2 实际使用情况

**问题**：`ContextManager::build_context_prompt()` 方法已定义，但在 `ai_commands.rs` 中**未被实际调用**。

**证据**：
- `ContextManager` 在第460行被创建：`let context_manager = ContextManager::new(model_config_clone.max_tokens);`
- 但从未调用 `build_multi_layer_prompt()` 或 `build_context_prompt()` 方法
- 上下文信息（当前文档、选中文本等）没有通过 `ContextManager` 添加到提示词中

**结论**：第二层上下文提示词**未实现**，代码中只有定义但没有使用。

---

### 2.3 第三层：引用提示词

#### 2.3.1 理论设计（未使用）

**位置**：`src/services/context_manager.rs` 第139-158行

**方法**：`build_reference_prompt()`

**设计内容**：
```rust
fn build_reference_prompt(&self, references: &[ReferenceInfo]) -> String {
    let mut prompt = String::from("用户引用了以下内容（这些内容已经完整包含在消息中，无需再读取文件）：\n\n");
    
    for (idx, ref_info) in references.iter().enumerate() {
        let ref_type_name = match ref_info.ref_type {
            ReferenceType::Text => "文本引用",
            ReferenceType::File => "文件引用",
            ReferenceType::Folder => "文件夹引用",
            ReferenceType::Image => "图片引用",
            ReferenceType::Chat => "聊天记录引用",
            ReferenceType::Link => "链接引用",
        };
        
        prompt.push_str(&format!("{}. {}（来源：{}）\n", idx + 1, ref_type_name, ref_info.source));
        prompt.push_str(&format!("{}\n\n", ref_info.content));
    }
    
    prompt
}
```

#### 2.3.2 实际使用情况

**问题**：`ContextManager::build_reference_prompt()` 方法已定义，但在 `ai_commands.rs` 中**未被实际调用**。

**证据**：
- `ReferenceInfo` 结构体已定义（第43-54行）
- `ReferenceType` 枚举已定义（第56-65行）
- 但从未在 `ai_commands.rs` 中构建 `ContextInfo` 或调用 `build_reference_prompt()`

**结论**：第三层引用提示词**未实现**，代码中只有定义但没有使用。

---

### 2.4 第四层：工具调用提示词

#### 2.4.1 实现位置1（主要使用）

**位置**：`src/commands/ai_commands.rs` 第403-412行

**内容**：
```text
工具调用格式要求（CRITICAL）：
所有工具调用必须使用严格的 JSON 格式：
```json
{"tool":"tool_name","arguments":{"key":"value"}}
```

规则：
- 所有键名和字符串值必须用双引号包裹
- JSON 必须完整闭合
- 确保格式可以被 JSON.parse() 解析
```

**使用场景**：作为第一层系统提示词的一部分，在启用工具时自动添加。

#### 2.4.2 实现位置2（未使用，重复定义）

**位置**：`src/services/context_manager.rs` 第160-174行

**方法**：`build_tool_calling_prompt()`

**内容**：
```rust
fn build_tool_calling_prompt(&self) -> String {
    r#"
工具调用格式要求（CRITICAL）：
所有工具调用必须使用严格的 JSON 格式：
```json
{"tool":"tool_name","arguments":{"key":"value"}}
```

规则：
- 所有键名和字符串值必须用双引号包裹
- JSON 必须完整闭合
- 确保格式可以被 JSON.parse() 解析
"#.to_string()
}
```

**问题**：与 `ai_commands.rs` 中的内容**完全重复**，但从未被调用。

**结论**：存在**重复定义**，`ContextManager` 中的版本是旧版本残留。

---

## 三、问题分析

### 3.1 重复逻辑问题

#### 3.1.1 工具调用提示词重复

**问题**：
- `ai_commands.rs` 第403-412行：工具调用格式要求作为系统提示词的一部分
- `context_manager.rs` 第160-174行：完全相同的工具调用格式要求，但从未被调用

**影响**：
- 代码维护困难：如果修改工具调用格式要求，需要在两个地方修改
- 容易产生不一致：两个地方的提示词可能不同步
- 增加代码复杂度：存在未使用的代码

#### 3.1.2 系统提示词构建逻辑重复

**问题**：
- `ai_commands.rs` 第352-413行：完整的系统提示词（当没有系统消息时）
- `ai_commands.rs` 第415-426行：简化的系统提示词（当已有系统消息时）

**差异**：
- 完整版本包含：角色定义、执行策略、主动执行原则、任务完整性检查、回复完整性要求、回复格式要求、工具调用格式要求
- 简化版本只包含：执行策略、工具调用格式要求

**影响**：
- 提示词不一致：根据是否有系统消息，AI收到的提示词内容不同
- 可能导致行为不一致：完整版本和简化版本的AI行为可能不同

---

### 3.2 旧版本残留问题

#### 3.2.1 ContextManager 未使用

**问题**：
- `ContextManager` 类已完整实现（`context_manager.rs`）
- 包含 `build_multi_layer_prompt()`、`build_context_prompt()`、`build_reference_prompt()`、`build_tool_calling_prompt()` 等方法
- 但在 `ai_commands.rs` 中**从未被调用**

**证据**：
```rust
// 第460行：创建了 ContextManager
let context_manager = ContextManager::new(model_config_clone.max_tokens);

// 但后续代码中从未调用：
// - context_manager.build_multi_layer_prompt()
// - context_manager.build_context_prompt()
// - context_manager.build_reference_prompt()
```

**结论**：`ContextManager` 是旧版本的设计，当前代码没有使用它，属于**死代码**。

#### 3.2.2 上下文信息未传递

**问题**：
- `ContextInfo` 结构体已定义（包含 `current_file`、`selected_text`、`workspace_path`、`editor_state`、`references`）
- 但在 `ai_commands.rs` 中从未构建 `ContextInfo` 对象
- 上下文信息（当前文档、选中文本等）没有添加到提示词中

**影响**：
- AI无法获取当前文档信息
- AI无法获取选中文本信息
- AI无法获取编辑器状态
- 第二层和第三层提示词**完全未实现**

---

### 3.3 实际工作逻辑分析

#### 3.3.1 当前实际使用的提示词架构

**实际架构**（只有一层）：
```
┌─────────────────────────────────────────┐
│  第一层：基础系统提示词（完整版/简化版） │
│  - 角色定义                              │
│  - 执行策略                              │
│  - 主动执行原则                          │
│  - 任务完整性检查                        │
│  - 回复完整性要求                        │
│  - 回复格式要求                          │
│  - 工具调用格式要求                      │
└─────────────────────────────────────────┘
```

**缺失的层**：
- ❌ 第二层：上下文提示词（未实现）
- ❌ 第三层：引用提示词（未实现）
- ⚠️ 第四层：工具调用提示词（已包含在第一层中，但存在重复定义）

#### 3.3.2 提示词构建流程

**实际流程**：
```
1. 接收用户消息（messages参数）
2. 检查是否有系统消息
   ├─ 如果没有系统消息
   │  └─ 插入完整的系统提示词（第352-413行）
   └─ 如果已有系统消息
      └─ 在现有系统消息后追加简化提示词（第415-426行）
3. 直接使用 enhanced_messages 调用 AI
```

**问题**：
- 没有构建上下文信息
- 没有添加引用内容
- 没有使用 `ContextManager` 的多层架构

#### 3.3.3 工具定义传递

**实际流程**：
```
1. 根据 enable_tools 参数决定是否获取工具定义
2. 如果启用工具，调用 get_tool_definitions() 获取工具列表
3. 工具定义通过 tool_definitions 参数传递给 AI Provider
4. AI Provider 将工具定义添加到 API 请求中
```

**注意**：工具定义不是通过提示词传递的，而是通过 API 参数传递的。

---

## 四、代码对比分析

### 4.1 设计 vs 实现对比（v2.0 更新）

| 层次 | 设计位置 | 实际实现位置 | 状态 |
|------|---------|------------|------|
| 第一层：基础系统提示词 | `context_manager.rs` | `context_manager.rs` 第108-170行（`build_base_system_prompt()`） | ✅ 已实现（统一在ContextManager中） |
| 第二层：上下文提示词 | `context_manager.rs` 第177-205行 | `context_manager.rs` 第177-205行（`build_context_prompt()`） | ✅ 已实现 |
| 第三层：引用提示词 | `context_manager.rs` 第207-225行 | `context_manager.rs` 第207-225行（`build_reference_prompt()`） | ✅ 已实现 |
| 第四层：工具调用提示词 | `context_manager.rs` | `context_manager.rs` 第159-168行（包含在第一层中） | ✅ 已实现（统一管理） |

**统一构建**：`ai_commands.rs` 通过 `ContextManager::build_multi_layer_prompt()` 统一构建所有层

### 4.2 重复代码位置

#### 4.2.1 工具调用格式要求

**位置1**：`ai_commands.rs` 第403-412行
```rust
工具调用格式要求（CRITICAL）：
所有工具调用必须使用严格的 JSON 格式：
```json
{"tool":"tool_name","arguments":{"key":"value"}}
```

规则：
- 所有键名和字符串值必须用双引号包裹
- JSON 必须完整闭合
- 确保格式可以被 JSON.parse() 解析
```

**位置2**：`context_manager.rs` 第160-174行
```rust
fn build_tool_calling_prompt(&self) -> String {
    r#"
工具调用格式要求（CRITICAL）：
所有工具调用必须使用严格的 JSON 格式：
```json
{"tool":"tool_name","arguments":{"key":"value"}}
```

规则：
- 所有键名和字符串值必须用双引号包裹
- JSON 必须完整闭合
- 确保格式可以被 JSON.parse() 解析
"#.to_string()
}
```

**结论**：内容完全相同，但位置2从未被调用。

---

## 五、工作逻辑详细分析

### 5.1 系统提示词构建逻辑

#### 5.1.1 完整版本（无系统消息时）

**触发条件**：`enhanced_messages` 中没有 `role == "system"` 的消息

**构建位置**：`ai_commands.rs` 第352-413行

**包含内容**：
1. **角色定义**（第354行）
   - "你是一个专业的编程助手和文档编辑助手"

2. **功能说明**（第356-363行）
   - 回答编程和文档相关问题
   - 执行文件操作（特别说明DOCX创建）
   - 执行编辑器操作
   - 搜索和浏览网络信息

3. **工作模式**（第365-366行）
   - 可以访问工具列表

4. **执行策略**（第368-373行）
   - 简单任务：直接执行
   - 复杂任务：先说明计划，等待确认

5. **主动执行原则**（第375-381行）
   - 感谢/赞美时只回复，不执行
   - 找到/定位文件时主动执行后续操作
   - 理解完整意图
   - 工具调用后必须继续完成
   - 只有明确要求时才执行文件移动

6. **任务完整性检查**（第383-386行）
   - 必须检查任务完成度
   - 不要忽略失败的操作
   - 任务进度自检

7. **回复完整性要求**（第388-396行）
   - 必须给出完整、详细的文件列表总结
   - 工具调用完成后提供完整总结
   - 不要只给出简短回复
   - 回复必须以标点符号结尾

8. **回复格式要求**（第398-401行）
   - 避免过度使用Markdown格式符号
   - 优先使用纯文本列表
   - 只在必要时使用Markdown

9. **工具调用格式要求**（第403-412行）
   - JSON格式要求
   - 规则说明

#### 5.1.2 简化版本（已有系统消息时）

**触发条件**：`enhanced_messages` 中已有 `role == "system"` 的消息

**构建位置**：`ai_commands.rs` 第415-426行

**包含内容**：
1. **执行策略**（简化版）
   - 简单任务：直接调用工具执行
   - 复杂任务：先说明执行计划，等待用户确认

2. **工具调用格式要求**（简化版）
   - 所有工具调用必须使用严格的 JSON 格式
   - 所有键名和字符串值必须用双引号包裹
   - JSON 必须完整闭合

**问题**：
- 缺少角色定义
- 缺少主动执行原则
- 缺少任务完整性检查
- 缺少回复完整性要求
- 缺少回复格式要求
- 可能导致AI行为不一致

### 5.2 上下文信息缺失分析

#### 5.2.1 应该包含的上下文信息

根据设计文档，第二层上下文提示词应该包含：
- 当前打开的文档路径
- 当前选中的文本
- 工作区路径
- 编辑器状态（是否可编辑、文件类型、文件大小、是否已保存）

#### 5.2.2 实际代码中的情况

**工作区路径**：
- 第431-435行：获取工作区路径
- 但**没有添加到提示词中**，只用于工具调用

**当前文档**：
- 代码中**没有获取当前打开的文档信息**
- 没有传递给AI

**选中文本**：
- 代码中**没有获取选中文本信息**
- 没有传递给AI

**编辑器状态**：
- 代码中**没有获取编辑器状态**
- 没有传递给AI

**结论**：第二层上下文提示词**完全未实现**。

### 5.3 引用信息缺失分析

#### 5.3.1 应该包含的引用信息

根据设计文档，第三层引用提示词应该包含：
- 用户引用的内容列表
- 每个引用的类型（文本、文件、文件夹、图片、聊天记录、链接）
- 每个引用的来源
- 每个引用的完整内容
- 明确说明"这些内容已经完整包含在消息中，无需再读取文件"

#### 5.3.2 实际代码中的情况

**引用信息**：
- `ReferenceInfo` 结构体已定义
- `ReferenceType` 枚举已定义
- `build_reference_prompt()` 方法已实现
- 但**从未在 `ai_commands.rs` 中构建引用信息**
- 从未调用 `build_reference_prompt()`

**结论**：第三层引用提示词**完全未实现**。

---

## 六、问题总结

### 6.1 架构实现不完整

**设计架构**：四层提示词架构
**实际实现**：只有一层（基础系统提示词）

**缺失**：
- ❌ 第二层：上下文提示词（未实现）
- ❌ 第三层：引用提示词（未实现）
- ⚠️ 第四层：工具调用提示词（已包含在第一层，但存在重复定义）

### 6.2 重复逻辑

1. **工具调用格式要求重复**：
   - `ai_commands.rs` 第403-412行（使用中）
   - `context_manager.rs` 第160-174行（未使用）

2. **系统提示词构建逻辑分支**：
   - 完整版本（无系统消息时）
   - 简化版本（有系统消息时）
   - 两个版本内容不一致，可能导致AI行为不一致

### 6.3 旧版本残留

1. **ContextManager 未使用**：
   - 完整的 `ContextManager` 类已实现
   - 包含所有多层提示词构建方法
   - 但从未被调用，属于死代码

2. **ContextInfo 未使用**：
   - `ContextInfo` 结构体已定义
   - 但从未构建和使用

### 6.4 功能缺失

1. **上下文信息未传递**：
   - AI无法获取当前文档信息
   - AI无法获取选中文本信息
   - AI无法获取编辑器状态

2. **引用信息未传递**：
   - AI无法知道用户引用了哪些内容
   - 可能导致AI重复读取已引用的文件

---

## 七、修复建议（v2.0 更新）

### 7.1 统一提示词构建逻辑（已完成 ✅）

**状态**：已采用方案A（使用 ContextManager 架构）

**已完成**：
1. ✅ 删除了 `context_manager.rs` 中未使用的工具调用提示词定义
2. ✅ 统一使用 `ContextManager` 的架构
3. ✅ 使用 `build_multi_layer_prompt()` 统一构建所有层
4. ✅ 删除了 `ai_commands.rs` 中约180行重复代码

### 7.2 实现第二层上下文提示词（已完成 ✅）

**状态**：已实现

**已完成**：
1. ✅ 在 `ai_commands.rs` 中添加了上下文信息参数：
   - `current_file: Option<String>` - 当前打开的文档路径
   - `selected_text: Option<String>` - 当前选中的文本
2. ✅ 构建 `ContextInfo` 对象（包含工作区路径、编辑器状态等）
3. ✅ 调用 `ContextManager::build_context_prompt()` 构建第二层提示词
4. ✅ 将第二层提示词添加到系统消息中

### 7.3 实现第三层引用提示词（已完成 ✅）

**状态**：框架已实现，引用检测逻辑可扩展

**已完成**：
1. ✅ 在 `ai_commands.rs` 中添加了引用信息提取逻辑（框架）
2. ✅ 构建 `ReferenceInfo` 对象数组
3. ✅ 调用 `ContextManager::build_reference_prompt()` 构建第三层提示词
4. ✅ 将第三层提示词添加到系统消息中

**可扩展项**：
- 引用检测逻辑可以扩展（当前从消息中提取，可扩展为前端传递）
- 支持更多引用类型（图片、链接等）

### 7.4 重构建议（v2.0 更新）

**方案A：使用 ContextManager 架构（已采用 ✅）**

**状态**：已完成

**优点**：
- ✅ 符合设计文档的架构
- ✅ 代码结构清晰，易于维护
- ✅ 支持多层提示词的统一管理

**已完成步骤**：
1. ✅ 在 `ai_commands.rs` 中构建 `ContextInfo` 对象
2. ✅ 调用 `ContextManager::build_multi_layer_prompt()` 构建完整提示词
3. ✅ 删除 `ai_commands.rs` 中重复的提示词构建逻辑（约180行）
4. ✅ 统一使用 `ContextManager` 的架构

**实现效果**：
- 代码从约230行减少到约50行（减少约78%）
- 所有提示词统一在 `ContextManager` 中管理
- 架构清晰，易于维护和扩展

**方案B：直接在 ai_commands.rs 中实现（已废弃）**

**状态**：未采用（已采用方案A）

**说明**：方案A已完全实现，方案B不再需要

### 7.5 清理死代码

**建议**：
1. 如果采用方案A，保留 `ContextManager` 并实际使用
2. 如果采用方案B，删除 `ContextManager` 中未使用的方法：
   - `build_multi_layer_prompt()`（如果不用）
   - `build_context_prompt()`（如果不用）
   - `build_reference_prompt()`（如果不用）
   - `build_tool_calling_prompt()`（重复定义，应删除）

---

## 八、详细代码位置索引

### 8.1 第一层：基础系统提示词

#### 8.1.1 完整版本
- **文件**：`src/commands/ai_commands.rs`
- **行号**：第354-412行
- **触发条件**：`enhanced_messages` 中没有系统消息
- **内容长度**：约3000字符

#### 8.1.2 简化版本
- **文件**：`src/commands/ai_commands.rs`
- **行号**：第415-426行
- **触发条件**：`enhanced_messages` 中已有系统消息
- **内容长度**：约200字符

### 8.2 第二层：上下文提示词（未实现）

#### 8.2.1 理论定义
- **文件**：`src/services/context_manager.rs`
- **行号**：第108-137行
- **方法**：`build_context_prompt()`
- **状态**：已定义，未使用

#### 8.2.2 应该获取的上下文信息
- **当前文档**：需要从前端 `chat_stream` 命令的参数中获取
- **选中文本**：需要从前端 `chat_stream` 命令的参数中获取
- **工作区路径**：已在第431-435行获取，但未添加到提示词
- **编辑器状态**：需要从前端传递

### 8.3 第三层：引用提示词（未实现）

#### 8.3.1 理论定义
- **文件**：`src/services/context_manager.rs`
- **行号**：第139-158行
- **方法**：`build_reference_prompt()`
- **状态**：已定义，未使用

#### 8.3.2 引用信息结构
- **文件**：`src/services/context_manager.rs`
- **行号**：第43-65行
- **结构体**：`ReferenceInfo`、`ReferenceType`
- **状态**：已定义，未使用

### 8.4 第四层：工具调用提示词

#### 8.4.1 实际使用版本
- **文件**：`src/commands/ai_commands.rs`
- **行号**：第403-412行
- **状态**：✅ 正在使用

#### 8.4.2 重复定义版本（未使用）
- **文件**：`src/services/context_manager.rs`
- **行号**：第160-174行
- **方法**：`build_tool_calling_prompt()`
- **状态**：❌ 未使用，应删除

---

## 九、工作逻辑流程图

### 9.1 当前实际工作流程

```
用户发送消息
    ↓
chat_stream 命令接收 messages 参数
    ↓
检查 enable_tools 参数
    ↓
如果 enable_tools == true:
    ├─ 获取工具定义 (get_tool_definitions)
    ├─ 检查是否有系统消息
    │  ├─ 如果没有系统消息
    │  │  └─ 插入完整系统提示词（第354-412行）
    │  └─ 如果已有系统消息
    │     └─ 追加简化提示词（第415-426行）
    └─ 工具定义通过 API 参数传递
    ↓
调用 AI Provider 的 chat_stream
    ↓
AI 返回流式响应
    ↓
处理响应（文本 + 工具调用）
```

### 9.2 设计文档中的工作流程（未实现）

```
用户发送消息
    ↓
chat_stream 命令接收 messages 参数
    ↓
构建 ContextInfo 对象
    ├─ 当前文档
    ├─ 选中文本
    ├─ 工作区路径
    ├─ 编辑器状态
    └─ 引用内容列表
    ↓
调用 ContextManager::build_multi_layer_prompt()
    ├─ 第一层：基础系统提示词
    ├─ 第二层：上下文提示词
    ├─ 第三层：引用提示词
    └─ 第四层：工具调用提示词（如果启用工具）
    ↓
构建完整的系统消息
    ↓
调用 AI Provider 的 chat_stream
    ↓
AI 返回流式响应
    ↓
处理响应（文本 + 工具调用）
```

### 9.3 流程对比

| 步骤 | 当前实现 | 设计文档 |
|------|---------|---------|
| 1. 接收消息 | ✅ | ✅ |
| 2. 构建上下文信息 | ❌ | ✅ |
| 3. 构建多层提示词 | ❌（只有一层） | ✅（四层） |
| 4. 调用AI | ✅ | ✅ |
| 5. 处理响应 | ✅ | ✅ |

---

## 十、影响分析

### 10.1 对AI行为的影响

#### 10.1.1 上下文信息缺失的影响

**问题**：
- AI无法知道当前打开的文档
- AI无法知道用户选中的文本
- AI无法知道编辑器状态

**影响**：
- AI可能无法理解用户意图（如"修改这个文件"中的"这个"）
- AI可能无法利用选中文本进行精确操作
- AI可能无法判断文件是否可编辑

**示例**：
- 用户选中文本后说"修改这里"，AI不知道"这里"指什么
- 用户打开文件后说"添加内容"，AI不知道要添加到哪个文件

#### 10.1.2 引用信息缺失的影响

**问题**：
- AI无法知道用户引用了哪些内容
- AI可能重复读取已引用的文件

**影响**：
- 增加不必要的工具调用
- 浪费Token
- 降低响应速度

**示例**：
- 用户引用了文件A的内容，但AI仍然调用 `read_file` 读取文件A
- 用户引用了文本片段，但AI无法利用这个信息

### 10.2 对代码维护的影响

#### 10.2.1 重复代码的影响（已修复 ✅）

**原问题**：
- 工具调用格式要求在两个地方定义
- 系统提示词有两个版本（完整版和简化版）

**原影响**：
- 修改时需要同步两个地方
- 容易产生不一致
- 增加维护成本

**修复状态**：✅ 已全部修复
- 已删除重复定义
- 已统一使用完整版本
- 代码维护成本大幅降低

#### 10.2.2 死代码的影响（已修复 ✅）

**原问题**：
- `ContextManager` 完整实现但未使用
- `ContextInfo` 结构体定义但未使用

**原影响**：
- 增加代码复杂度
- 误导开发者（以为已实现）
- 占用代码空间

**修复状态**：✅ 已全部修复
- `ContextManager` 已实际使用
- `ContextInfo` 已实际构建和使用
- 代码结构清晰，无死代码

---

## 十一、修复优先级建议（v2.0 更新）

### 11.1 高优先级（已完成 ✅）

1. ✅ **删除重复的工具调用提示词定义**
   - ✅ 已删除 `context_manager.rs` 中的 `build_tool_calling_prompt()`
   - ✅ 统一在 `ContextManager::build_base_system_prompt()` 中管理

2. ✅ **统一系统提示词版本**
   - ✅ 已统一使用完整版本
   - ✅ 通过 `ContextManager::build_base_system_prompt()` 统一管理

3. ✅ **纯知识性问题处理**
   - ✅ 添加了规则：纯知识性问题直接回答，不创建文件
   - ✅ 避免AI误解简单询问为需要执行操作的任务

### 11.2 中优先级（已完成 ✅）

1. ✅ **实现第二层上下文提示词**
   - ✅ 已获取当前文档、选中文本、编辑器状态（通过参数传递）
   - ✅ 已添加到系统提示词中

2. ✅ **清理死代码**
   - ✅ 已采用 `ContextManager` 架构
   - ✅ 已实际调用所有相关方法

### 11.3 低优先级（已完成 ✅ / 可扩展）

1. ✅ **实现第三层引用提示词**
   - ✅ 框架已实现
   - ✅ 引用检测逻辑可扩展（当前从消息中提取，可扩展为前端传递）

2. ✅ **重构为 ContextManager 架构**
   - ✅ 已统一使用 `ContextManager::build_multi_layer_prompt()`
   - ✅ 已删除 `ai_commands.rs` 中的重复逻辑（约180行）

### 11.4 未来优化方向

1. **引用检测逻辑扩展**
   - 支持前端传递引用信息
   - 支持更多引用类型（图片、链接等）

2. **编辑器状态增强**
   - 支持更详细的编辑器状态信息（文件大小、是否已保存等）
   - 支持从编辑器获取实时状态

---

## 十二、总结

### 12.1 当前状态（v2.0 更新）

**设计架构**：四层提示词架构（基础系统提示词 + 上下文提示词 + 引用提示词 + 工具调用提示词）

**实际实现**：
- ✅ 第一层：基础系统提示词（已实现，统一使用完整版本，通过 `ContextManager::build_base_system_prompt()` 管理）
- ✅ 第二层：上下文提示词（已实现，支持 `current_file` 和 `selected_text` 参数，通过 `ContextManager::build_context_prompt()` 构建）
- ✅ 第三层：引用提示词（已实现框架，通过 `ContextManager::build_reference_prompt()` 构建，引用检测逻辑可扩展）
- ✅ 第四层：工具调用提示词（已包含在第一层中，统一管理）

**架构实现**：
- ✅ 已采用方案A（使用 ContextManager 架构）
- ✅ 使用 `ContextManager::build_multi_layer_prompt()` 统一构建所有层
- ✅ 删除了 `ai_commands.rs` 中重复的提示词构建逻辑（约180行代码）
- ✅ 所有提示词统一在 `ContextManager` 中管理

### 12.2 已修复的问题

1. ✅ **架构实现完整**：四层提示词架构已全部实现
2. ✅ **重复逻辑已清理**：删除了重复的工具调用提示词定义和系统提示词构建逻辑
3. ✅ **ContextManager 已激活**：`ContextManager` 已实际使用，不再是死代码
4. ✅ **功能已实现**：上下文信息和引用信息已传递给AI

### 12.3 最新优化（v2.0）

1. ✅ **统一架构**：完全采用方案A，使用 `ContextManager` 统一管理所有层
2. ✅ **代码优化**：删除了约180行重复代码，代码更简洁易维护
3. ✅ **纯知识性问题处理**：添加了规则，纯知识性问题直接回答，不创建文件
4. ✅ **提示词一致性**：统一使用完整版本，确保AI行为一致

### 12.4 关键发现（v2.0 更新）

1. ✅ **ContextManager 已激活**：已实际使用，通过 `build_multi_layer_prompt()` 统一构建
2. ✅ **四层架构已实现**：与设计文档完全对齐
3. ✅ **统一构建逻辑**：所有提示词通过 `ContextManager` 统一管理，代码结构清晰
4. ✅ **代码质量提升**：删除了重复代码，提高了可维护性

---

## 十三、v2.0 更新总结

### 13.1 主要更新内容

1. **完整实现四层提示词架构**
   - ✅ 第一层：基础系统提示词（统一在 `ContextManager::build_base_system_prompt()` 中）
   - ✅ 第二层：上下文提示词（支持 `current_file` 和 `selected_text` 参数）
   - ✅ 第三层：引用提示词（框架已实现，引用检测逻辑可扩展）
   - ✅ 第四层：工具调用提示词（包含在第一层中，统一管理）

2. **采用方案A（ContextManager 架构）**
   - ✅ 使用 `ContextManager::build_multi_layer_prompt()` 统一构建所有层
   - ✅ 删除了 `ai_commands.rs` 中约180行重复代码
   - ✅ 代码从约230行减少到约50行（减少约78%）

3. **清理重复代码和旧版本残留**
   - ✅ 删除了重复的工具调用提示词定义
   - ✅ 统一使用完整版本的系统提示词
   - ✅ `ContextManager` 已激活，不再是死代码

4. **优化AI行为**
   - ✅ 添加了纯知识性问题处理规则：纯知识性问题直接回答，不创建文件
   - ✅ 避免AI误解简单询问为需要执行操作的任务

### 13.2 代码质量提升

- **代码行数**：从约230行减少到约50行（减少约78%）
- **重复代码**：已全部清理
- **死代码**：已全部清理
- **架构清晰度**：完全符合设计文档，统一管理

### 13.3 实现效果

- ✅ 四层提示词架构完全实现
- ✅ 代码结构清晰，易于维护
- ✅ AI行为更符合预期（纯知识性问题直接回答）
- ✅ 所有提示词统一管理，修改更方便

---

**文档版本**：v2.0  
**创建日期**：2025-12-28  
**最后更新**：2025-12-29  
**分析目标**：梳理当前代码中的提示词实现，识别重复逻辑和旧版本残留  
**更新说明**：v2.0 版本反映了已完成的多层提示词架构实现和优化，包括：
- 实现了完整的四层提示词架构
- 采用方案A（ContextManager 架构）统一管理
- 删除了所有重复代码和旧版本残留
- 添加了纯知识性问题处理规则